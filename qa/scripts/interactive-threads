:open cmu-test-suite
:debug
:show threads
:create-thread cmu
:show threads
:set thread 4
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 5
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 6
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 7
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 8
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 9
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 10
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 11
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 12
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 13
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 14
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 15
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 16
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 17
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 18
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 19
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 20
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 21
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 22
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 23
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 24
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 25
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 26
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 27
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 28
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 29
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 30
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 31
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 32
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 33
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 34
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 35
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 36
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 37
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 38
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 39
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 40
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 41
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 42
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 43
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 44
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 45
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 46
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 47
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 48
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 49
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:create-thread cmu
:show threads
:set thread 50
1;
1 + 3;
$1 * 10;
do-tautologies;
tautologies;
do-tautologies(tautologies);
define method keytest1 (x :: <bar>, #key bar)  x; pair(bar, next-method()) end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 1 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 2 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 3 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 4 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 5 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 6 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 7 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method tautology(arg == #"symbols")  format-out("\n### Running verion 8 of tautology on symbols\n"); instance?(#"foo", <symbol>)		| signal("instance?(#\"foo\", <symbol>) is false!\n");  instance?(#"foo", <symbol>)		| signal("instance?(foo:, <symbol>) is false!\n");  (#"foo" = #"FOO")			| signal("#\"foo\" is not FOO:!\n");  (as(<symbol>, "FOO") = #"foo")	| signal("as(<symbol>, \"FOO\") is not foo:!\n");  (as(<string>, #"Foo") = "foo")	| signal("as(<string>, Foo:) is not \"foo\"! It's %=\n",						 as(<string>, Foo:)); end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 1 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 2 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
define method do-tautologies(tests :: <sequence>) => (result :: <integer>);  format-out("\n### Running verion 3 of do-tautology on <sequence>\n"); let (warnings, errors) = values(0, 0);  let handler <warning>     = method(condition, next)        format-out("Warning in tautologies: %=. Continuing...\n", condition);        warnings := warnings + 1;      end method;  let (elapsed-seconds, elapsed-microseconds) =    timing ()      for (test in tests)	block ()	  if (test)	    format-out("Tautologies on %S\n", as(<string>, test));	    tautology(test);	  end if;	exception (the-error :: <error>)  	  format-out("Error in tautologies: %=.  Skipping to %=\n",	    the-error, head(tests));	  errors := errors + 1;	end;      end for;    end timing;  format-out("Tautology completed with %D warnings and %D fatal errors\n", warnings, errors);  if (elapsed-seconds ~= 0 | elapsed-microseconds ~= 0)    format-out("Tautology tests completed in %D.%S seconds\n",	       elapsed-seconds, integer-to-string(elapsed-microseconds, size: 6))  end if;  warnings + errors;end method;
do-tautologies(tautologies);
check("typeunion method call 1", \==, method() analyze-typeunion(#f) end, #"integer-union");
:quit