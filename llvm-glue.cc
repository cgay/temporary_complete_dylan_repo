#include <llvm/BasicBlock.h>#include <llvm/Module.h>namespace d2c{  struct Obj  {    struct Class* c;  };    template <typename PREFIX, typename ELEM>  struct ArrayObject : PREFIX  {    std::size_t elems;    ELEM arr[];    typedef ELEM* iterator;    iterator begin(void) { return arr; }    iterator end(void) { return arr + elems; }  };  struct ByteString : ArrayObject<Obj, unsigned char>  {    operator std::string (void) const    {      const char* start(reinterpret_cast<const char*>(arr));      return std::string(start, elems);    }  };  struct Symbol : Obj  {    ByteString* print_name;  };  struct Class : Obj  {    Symbol* name;  };    struct desc  {    Obj* heapptr;    union {        long l;        float f;        void *ptr;    } dataword;  };  struct SimpleObjectVector : ArrayObject<Obj, desc>  {  };}using namespace llvm;using namespace d2c;extern "C" void* make_llvm_BasicBlock(void/*NAME, FUNC, BEFORE*/){  return new BasicBlock();}extern "C" void delete_llvm_Value(Value* v){  delete v;}extern "C" void* make_llvm_Module(const ByteString* name){  return new Module(*name);}extern "C" void delete_llvm_Module(Module* m){  delete m;}extern "C" void dump_llvm_Module(Module* m){  m->dump();}extern "C" void* make_llvm_Function(FunctionType* type, const ByteString* name, Module* module){  return new Function(type, GlobalValue::ExternalLinkage, *name, module);}extern "C" void dump_llvm_Value(Value* v){  v->dump();}