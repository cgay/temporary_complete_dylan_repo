#!/u/dylan/local/gema -f

! Dylan cross-reference utility
!
! Usage:
!	dxref <name-options> <dylan-source-files>
! This reads Dylan source files and writes to standard output a report of
! which files and definitions use the names of interest.  A typical line
! of output looks like:
!
!	foo	bar.dylan	frob
!
! which means that the identifier `foo' is referenced within the definition
! of `frob' in file "bar.dylan".  Usually you will want to filter the
! output with `sort -u' or `uniq'.
!
! A common usage is:
!
!   dtags -o TAGS *.dylan
!   dxref -names TAGS *.dylan | sort -f -u > refs.text
!
! This produces a file "refs.text" which is an alphabetical cross reference
! of the uses of each non-local name defined in the files in the current
! directory.  Any number of "-names" options may be used.  Besides "TAGS"
! files, module definition files are also recognized, with the names being
! taken from the export lists; this can be useful for finding which names
! from a particular used library are being referenced:
!
!   dxref -names ../other-lib/library.dylan *.dylan | sort -f -u
!
! Another way to use this is:
!
!   dxref -name foo *.dylan | uniq
!
! which produces a report of where the single name `foo' is referenced.
! This is rather like `grep', except that it shows the name of the
! referencing function instead of the source line, and it will not report
! appearances within comments, strings, or the file header.
!
! The option 
!	-omit <identifier>
! may be used after "-names" to remove a particular name from the search
! list. 
!
!----------------------------------------------------------
!  (The rest of this file is input for the "gema" program.)


! write to standard output:
@ARGV{-out\n-\n}

! case insensitive:
@set-switch{i;1}
! literal characters:
@set-syntax{L;\-\.\(\)}
! discard unmatched input:
@set-switch{match;1}
! additional identifier characters:
@set-parm{idchars;\!\&\*\<\=\>\|\^\$\%\@\_\-\+\~\?\/}

! skip file header
\B<P>\:*\n\W\n=@set{d;}

! skip comments
\/\/*\n=
\/\*<comment>\*\/=
comment:\/\*<comment>\*\/=
comment:\/\/*\n=

! skip constants
\"<string>\"=
string:\\?=\\?;?=?
\'<char>\'=
char:\\?=\\?@end;?=?@end
\#\"<string>\"=
\#\J<I>=
\#\#\J<I>=

! ignore macro arguments
\?\J<I>=
\?\"<string>\"=

! variable "d" is the name of the current definition.
\B=@set{d;}

! remember name of current definition
\Idefine method <defname>\W(\W<i>\W\:\:\W<I><matchparen>\)=@set{d;$1 \($3}\
	@args{$2\:\:$3$4,}

args:\:\:\W<>,=$1
args:\=\=\W<>,=$1
args:?=
(#)=$1

! general definition
\Idefine <adj><I> <defname>=@set{d;$3}@{$2-definer}

defname:of <defname>=$1@end! special case for C-callable-wrapper
defname:<I>=$1@end
defname:\\<-A1><i>=$0@end
defname:=@fail

! old prefix syntax
\N(define-\J<I> <I>=@set{d;$2}

adj:open =$0
adj:sealed =$0
adj:primary =$0
adj:free =$0
adj:abstract =$0
adj:concrete =$0
adj:inline =$0
adj:not-inline =$0
adj:default-inline =$0
adj:may-inline =$0
adj:inline-only =$0
adj:=@end

\Idefine variable\W\(\W<I><matchparen>\)=@set{d;$1}@args{$1$2,}

\Idefine-fluid\W(\W<I>=@set{d;$1}

\Islot <I>=
\Iconstant slot <I>=

matchparen:(#)=(#)
matchparen:\{#\}=\{#\}

! skip reserved words
\Iend <i>\W<i>\W\;=
\Iend\I=
\Ibegin\I=
\Iblock\I=
\Icase\I=
\Ifor\I=
\Iif\I=
\Imethod\I=
\Iselect\I=
\Iunless\I=
\Iuntil\I=
\Iwhile\I=
\Ilet <I>=
\;=
\,=
\:\J\=\I=
\I\=\J\>\I=

! skip whitespace
\S=

! report references
<ref>=$1 @tab{26}@file @tab{44}$d\n

! skip other identifiers
<I>=

ref:=@fail

! command-line options:
ARGV:-find <I>\n=@define{ref\:\\I@quote{$1}\\I\=\$0\@end}
ARGV:-name <I>\n=@define{ref\:\\I@quote{$1}\\I\=\$0\@end}
ARGV:-names <G>\n=@names{@read{$1}}
ARGV:-omit <I>\n=@undefine{ref\:\\I@quote{$1}\\I\=\$0\@end}

names:define <adj><I>=
names:slot =
names:macro =
! ignore file names in TAGS file:
names:\f\n<F>.<F>,<D>\N=
! ignore numbers in TAGS file:
names:\d<D>,<D>\N=
! skip file header
names:\Bmodule\:*\n\W\n=

names:\Idefine library <I> <libdef>\Iend\W<i>\W<i>\W\;=
names:\Idefine module <I> <moduledef>\Iend\W<i>\W<i>\W\;=
libdef:\{#\}=
moduledef:\Iuse <I>=
moduledef:\Iexport\I=
moduledef:<I>\:=
moduledef:\{#\}=\{#\}
! skip import list:
moduledef:\Iimport\:\W\{*\}=
moduledef::names

names:\/\/*\n=
names:\/\*<comment>\*\/=
names:\"<string>\"=
names:\S=
names:<D>\I=
names:<I>=@define{ref\:\\I@quote{$1}\\I\=\$0\@end}
names:?=


