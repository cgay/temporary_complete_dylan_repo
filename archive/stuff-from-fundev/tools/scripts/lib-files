#!/usr/local/bin/perl
# lib-files, gz, April, 1996
#
# Read a .lid file or files and print the list of files in it to standard output.
# Expected use is as command line input using `lib-files ...`.
#   Defaults the file type to .dylan.
#   Prefixes each filename with the lid file's directory unless -noprefix.
#   Includes the lid file itself if -include_lid.
#   If given a directory, does all .lid files in the directory.
#   With no arguments, does current directory (equivalent to "-noprefix ./")
# 
# Revision History:
# On: Nov 9 1996 By: amit Rea: Added -r[emove duplicates] option. This option
# ensures all files reported are unique. It is disabled by default.
# On: Dec 21 1996 By: amit Rea: Added -q[uiet] option. This option ensures
# that no error message is printed when say a file is not found etc.
###########################################################################
# Applcation exit status legend:
# 0: successful
# 1: Lidfile not found
#
$usage = "Usage: lib-files [-n[oprefix]] [-r[emove duplicates]] [-q[uiet]] [-i[nclude_lid]] dir-or-lid-file...\n".
         " e.g.: cd ~dylan/duim; lpr `lib-files` # Print all files in duim library\n".
         "(See $0 for more details)\n";

$prefix = ""; # Someday we might want to specify a -prefix...
$noprefix = 0;
$include_lid = 0;
$remove_dup = 0;
$quiet = 0;
while ($#ARGV >= 0) {
  last unless $ARGV[0] =~ m/^-/;
  $_ = shift(@ARGV);
  last if m/^--$/;
  if (m/^-n(oprefix)?$/) { $noprefix = 1; }
  elsif (m/^-r(emove|emove_duplicates)?$/) { $remove_dup = 1; }
  elsif (m/^-q(u|uiet)?$/) { $quiet = 1; }
  elsif (m/^-i(nclude|nclude_lid)?$/) { $include_lid = 1; }
  else { die $usage; };
}
if ($#ARGV < 0) { unshift(@ARGV, "."); $noprefix = 1; }

for $_ (@ARGV) {
  chop if m|.*/$|;
  $this_prefix = $prefix;
  if (-d $_) { # directory
    $this_prefix = $_ . "/" unless $noprefix;
    $pattern = $_ . "/*.lid";
    while (<${pattern}>) { &collect($_, $this_prefix);  }
  } else { # file
   $_ = $_ . ".lid" unless -e _;  # Try adding .lid if file doesn't exist.
   ($this_prefix) = m|^(.*/)[^/]*$| unless $noprefix;
   &collect($_, $this_prefix);
  };
}

# Remove duplicates if necessary
if ($remove_dup) { @files = &remove_duplicates(@files); }

# Viola!
print join(' ', @files);
print "\n";
exit;

sub collect {
  local($lid_file, $prefix) = @_;
  push(@files, $lid_file) if $include_lid;
  if ($quiet) {
      open lid_file || exit(1);
  } else {
    open lid_file ||
	die "Can't open lid file $lid_file: $!\n";
  }
  # Find the start of Files:
  while (<lid_file>) { last if (/^files:/i); }
  # Collect the filenames
  @new = ();
  while (m|(.*)//.*$|) { $_ = $1; }
  push(@new, split) if ($_) = m|^files:\s*(\S.*)\s*$|i;
  while (<lid_file>) {
    last if (/^\w.*:/);  # start of some other field
    last if (/^\s*$/);   # blank line
    while (m|(.*)//.*$|) { $_ = $1 };
    push(@new, split) if (($_) = m|^\s*(\S.*)\s*$|);
  };
  close lid_file;
  # Normalize
  foreach $file (@new) {
    # Default file type to ".dylan"
    $file = $file . ".dylan" unless ($file =~ /.+[.].+/);
    $file = $prefix . $file;
  };
  # Voila
  push(@files, @new);
};

sub remove_duplicates {
    local(@unpurged_files) = @_;
    local(@purged_files) = ();
    local($curr_file, $hits);
    foreach $curr_file (@unpurged_files) {
	if (grep(/$curr_file/, @purged_files) == 0) {
	    push(@purged_files, $curr_file);
	}
    }
    return (@purged_files);
}
