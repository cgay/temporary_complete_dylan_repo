<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.1//EN" [
 <!ENTITY % entities SYSTEM "entities.sgml">
 %entities;

 <!ENTITY base-lib
   '<link linkend="gdmaint-d2c-base"><dlibrary>Compiler-Base</dlibrary>
    library</link>' >
 <!ENTITY parser-lib
   '<link linkend="gdmaint-d2c-parser"><dlibrary>Compiler-Parser</dlibrary>
    library</link>' >
 <!ENTITY convert-lib
   '<link linkend="gdmaint-d2c-convert"><dlibrary>Compiler-Convert</dlibrary>
    library</link>' >
 <!ENTITY front-lib
   '<link linkend="gdmaint-d2c-front"><dlibrary>Compiler-Front</dlibrary>
    library</link>' >
 <!ENTITY optimize-lib
   '<link linkend="gdmaint-d2c-optimize"><dlibrary>Compiler-Optimize</dlibrary>
    library</link>' >
 <!ENTITY cback-lib
   '<link linkend="gdmaint-d2c-cback"><dlibrary>Compiler-CBack</dlibrary>
    library</link>' >
 <!ENTITY main-lib
   '<link linkend="gdmaint-d2c-main"><dlibrary>Compiler-Main</dlibrary>
    library</link>' >
]>
<BOOK id="gdmaint">
  <title>Gwydion Dylan Porting and Maintenance Guide</title>
  <titleabbrev>Maintenance Guide</titleabbrev>

  <bookinfo>
    <COPYRIGHT>
      <YEAR>1998</YEAR>
      <HOLDER>Carnegie Mellon University</HOLDER>
      <HOLDER>Gwydion Dylan Maintainers</HOLDER>
    </COPYRIGHT>
    &cmu.terms;
    <bookbiblio>
      <date>09 September 1998</date>
      <editor>&person.housel;</editor>
      <editor>&person.emk;</editor>
    </bookbiblio>
  </bookinfo>

  <CHAPTER id="gdmaint-introduction">
    <TITLE>Introduction</TITLE>

    <PARA>This manual serves as a guide to porting and maintaining
    Gywdion &dylan;. It includes:</PARA>

    <ITEMIZEDLIST>
      <LISTITEM>
	<PARA>Suggestions for working with other Gwydion developers.</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>Guidelines for porting &mindy; and &d2c; to new platforms</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>An overview of the &mindy; interpreter</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>A detailed guide to the internals of the &d2c; compiler</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>A guide to the internals of the
	<COMMAND>melange</COMMAND> interface generator</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>An appendix containing the Gwydion Project coding
	guidelines.</PARA>
      </LISTITEM>
    </ITEMIZEDLIST>

  </CHAPTER>

  <chapter id="gdmaint-conventions">
    <docinfo><author>&person.emk;</author></docinfo>
    <title>Development Conventions</title>
    
    <note>
      <para>None of the advice contained in this chapter is binding.
      However, an attempt has been made to accurately represent the working
      style and informal rules followed by the current developers.</para>

      <para>If you think that this chapter does not represent the way we
      work, please tell me and I'll fix it. It's a
      <quote>descriptive</quote> document, not <quote>prescriptive</quote>
      one.</para>
    </note>

    <para>Gwydion Dylan was originally developed by the Gwydion Project at
    CMU. Today, it is maintained by a loose group of volunteers, some of
    whom have been working on it for over a year. This chapter attempts to
    summarize the way we do things.</para>

    <sect1 id="gdmaint-conventions-principles">
      <title>Basic Principles</title>

      <para>We try to follow a few basic principles:</para>

      <itemizedlist>
	<listitem>
	  <formalpara>
	    <title>Decisions are made by consensus</title>

            <para>In general, we make an effort to discuss tricky problems
	    until all the major contributors agree. This is similar to the
	    <acronym>IETF</acronym>'s philosophy of <quote>rough consensus
	    and running code</quote>. If you think a decision is wrong,
	    explain your viewpoint carefully and be prepared to back it up
	    with code. Use the magic phrase often: <quote>Does anybody
	    object to this?</quote></para>
	  </formalpara>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>Final rulings are made by the core team</title>

	    <para>The core team consists of the most prolific Gwydion
      	    developers and those who have been involved the longest. If the
      	    other contributors would feel guilty about making a decision
      	    without considering your opinion, you're effectively a member
      	    of the core team.</para>
	  </formalpara>

	  <para>Decisions within the core team should be made by unanimous
	  consent whenever possible. This seems to have worked well enough
	  historically. If this process ever breaks down in the future, the
	  core team might choose to vote as measure of last resort.</para>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>No due dates</title>
	    
	    <para>As a matter of policy, we do not promise completion dates
	    to outside entities. This is because of the volunteer nature of
	    the project and the traditional unreliablity of software
	    estimation. Of course, individuals may promise due dates of
	    their own, but nobody else will take responsibility for meeting
	    those dates.</para>
	  </formalpara>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>Don't bite off more than you can chew</title>

	    <para>Work on one or two projects at a time. Don't commit to
	    implementing many separate libraries or fixing many separate
	    bugs. By <quote>reserving</quote> too many areas, you
	    effectively discourage others from working on them.</para>
	  </formalpara>
	</listitem>
      </itemizedlist>
    </sect1>

    <sect1 id="gdmaint-conventions-cvs">
      <title>CVS Suggestions</title>

      <para>The source in CVS should always work correctly. Those who break
      the build will be tickled with feathers or suffer a similar
      fate. Always, always, always test your code before committing it. For
      compiler changes, you should at least run the test suites in
      <filename>gd/src/tests</filename> as a smoke test. Also, a full
      bootstrap cycle is strongly recommended before commiting more
      complicated changes.</para>
    </sect1>
  </chapter>

  <CHAPTER id="gdmaint-porting">
    <TITLE>Porting Gwydion Dylan to a New Platform</TITLE>

    <PARA>Here's a rough overview of how to port &d2c;. Take this with a
    grain of salt; the rules change occasionally.</PARA>

    <itemizedlist>
      <listitem>
	<para>Add your platform to the <filename>platforms.descr</filename>
	file and <filename>configure.in</filename>. This will require a bit
	of delibrate research.</para>
      </listitem>
      <listitem>
	<para>Look in other places, such as the various
	<filename>Makegen</filename> files and platform-specific Melange
	code. Do something intelligent.</para>
      </listitem>
      <listitem>
	<para>Make sure that the Boehm GC runs on your platform. If not,
	you need to talk to the Boehm list.</para>
      </listitem>
      <listitem>
	<para>Run <command>configure</command> with the flag
	<literal>--enable-mindy-bootstrap</literal>, then run
	<command>make</command>. Be prepared to wait, and be ready to fix
	any bugs you encounter.</para>
      </listitem>
      <listitem>
	<para>Gripe to <email>gd-hackers@randomhacks.com</email> when it
	breaks. We'll help you sort out the mess.</para>
      </listitem>
    </itemizedlist>

    <para>The more your platform looks like a 32-bit Unix system with the
    GNU tools, the easier things will be. Supporting 64-bit platforms is a
    minor project requiring a number of changes to &d2c; (Mindy already
    works on Alpha Linux, thanks to the efforts of Jeff Dubrule). Windows
    support has been broken slightly since the 2.0 days, but most of the
    problems are in the build system, not the source itself.</para>

    <para>Macintoshes, vendor C compilers and other such oddities are the
    responsibility of those who use them. We'll be happy to help, but
    you'll probably need to find a significant number of dedicated
    volunteers to help you fix any problems you encounter.</para>
  </CHAPTER>

  <CHAPTER id="gdmaint-mindy-internals">
    <TITLE>Mindy Internals Guide</TITLE>

    <PARA>Relatively little has been written down about the internal
    workings of Mindy. Interested parties are encouraged to submit a
    chapter for this manual.</PARA>
  </CHAPTER>

  <chapter id="gdmaint-d2c-internals">
    <docinfo><author>&person.emk;</author></docinfo>
    <title>&d2c; Internals Guide</title>

    <para>The &d2c; compiler was developed by the Gwydion Project at
    CMU. This chapter explains the structure of &d2c; and gives a brief
    overview of how the various components interact.</para>

    <para>&d2c; compiles one library at a time. Each library contains one
    or more modules. A module may be implemented by one or more files. Each
    file contains one or more <glossterm>source records</glossterm>, the
    logical unit of Dylan compilation.</para>

    <para>By compiling many source records at once, &d2c; produces more
    efficient code at the cost of using more memory. In addition to
    processing an entire library's worth of source records, &d2c; also
    performs interlibrary optimizations by looking at certain information
    from previously compiled libraries.</para>

    <para>In its current configuration, &d2c; is not well-suited to
    developing new Dylan code. It is, however, well-suited to building
    production versions of libraries. Obvious future projects include
    reducing the granularity of compilation and implementing a
    selectively-incremental compiler that can modify the object code of a
    running program. The basic architecture was designed with these
    projects in mind.</para>

    <para>The actual compilation process procedes roughly as
    follows:</para>

    <itemizedlist>
      <listitem>
	<formalpara>
	  <title>Load any libraries used by the current library</title>

	  <para>The compiler begins by reading in the
	  <filename>*.lib.du</filename> file for the
	  <dlibrary>Dylan</dlibrary> library. As other libraries are
	  <dlit>use</dlit>d, it loads the appropriate
	  <filename>*.lib.du</filename> files. These contain most of the
	  compiler data structures from the original versions of those
	  libraries.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Parse and macro-expand each of the input files</title>

	  <para>The parser is implemented by the &parser-lib;. As each
          top-level form gets parsed, it is passed to
          <dname>process-top-level-form</dname>, which is implemented by
          the &convert-lib;. At the end of this stage, the input files have
          been completely parsed and macro-expanded.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Finalize the top-level forms</title>

	  <para>Top-level forms may contain forward dependencies within a
	  module. In most cases, these dependencies aren't necessitated by
	  the design of the Dylan language, but they are needed for for
	  efficient compilation. We need to study these dependencies if we
	  want to make incremental compilation work. The implementation of
	  <dname>finalize-top-level-form</dname> lives in
	  &convert-lib;.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Process the class hierarchy</title>

	  <para>Optimizing Dylan code requires careful attention to the
	  object model. Unfortunately, &d2c; uses algorithms which require
	  the entire class hiearchy to be computed before link time. (The
	  biggest problem here appear to be assigning unique IDs to
	  individual classes.) The code to analyze the class hierachy lives
	  in the <link
	  linkend="gdmaint-d2c-base-classes"><dmodule>Classes</dmodule>
	  module</link> of the &base-lib;.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Begin processing top-level definitions
	  individually</title>

	  <para>Up until this point, &d2c; performed each step on the
	  entire library before continuing. The next several steps,
	  however, are completed for each top-level form before moving on
	  to the next top-level form. This process is controlled by
	  <dname>compile-1-tlf</dname> in the &main-lib;</para>
	</formalpara>

	<itemizedlist>
	  <listitem>
	    <formalpara>
	      <title>Convert the parse tree into the front-end
              representation</title>

	      <para>For various unfortunate reasons, &d2c; uses the term
	      <glossterm>front-end representation</glossterm>
	      (<acronym>FER</acronym>) for what other compilers call the
	      <glossterm>intermediate representation</glossterm>. The
	      conversion process is controlled by methods on
	      <dname>convert-top-level-form</dname> provided by the
	      &convert-lib;. These take the parsed representation of a
	      top-level form and convert it to the <acronym>FER</acronym>
	      using the the <link
	      linkend="gdmaint-d2c-front-builder-interface">
	      <dmodule>Builder-Interface</dmodule> module</link>.</para>
	    </formalpara>
	  </listitem>
	  <listitem>
	    <formalpara>
	      <title>Optimize the FER of each top-level form</title>

	      <para>The compiler performs two kinds of optimizations:
	      <glossterm>simplications</glossterm> and required
	      optimizations. The simplications should produce output
	      equivalent to their input. The required optimizations,
	      however, clean up certain artifacts in the code and insert
	      type checks. It is an error to pass a top-level form to the
	      back end before performing the required optimizations. See
	      <xref linkend="gdmaint-d2c-optimize"> for more
	      details.</para>
	    </formalpara>
	  </listitem>
	  <listitem>
	    <formalpara>
	      <title>Emit C code for the FER of each top-level form</title>

	      <para>The &cback-lib; emits the actual C code required to
	      implement each top-level form.</para>
	    </formalpara>
	  </listitem>
	</itemizedlist>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Dump the local and global heaps</title>

	  <para>Each library has a local heap which gets linked into the
	  library itself. This contains as much static data as
	  possible. However, not all data can safely live here; some must
	  live in the executable application. The per-library heap is
	  called the <glossterm>local heap</glossterm> and the
	  per-application heap is called the <glossterm>global
	  heap</glossterm>. The latter is only dumped if the current
	  library will become an executable application. Both dumpers are
	  implemented by the <link linkend="gdmaint-d2c-cback-heap">
          <dmodule>Heap</dmodule> module</link>.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Save a <filename>*.lib.du</filename> file for the current
	  library if necessary</title>

	  <para>If &d2c; is not compiling an executable application, it
	  dumps the data structures used by this library into a
	  <filename>*.lib.du</filename> file. If another Dylan library
	  includes this library, the dumped data structures will be used to
	  perform inter-library optimizations. The dumped data is stored as
	  persistent objects in <glossterm>Object Description
	  Format</glossterm> (<acronym>ODF</acronym>). The dumping process
	  is controlled by the &main-lib;. <acronym>ODF</acronym> is
	  implemented by the <link
	  linkend="gdmaint-d2c-base-od-format"><dmodule>OD-Format</dmodule>
	  module</link>.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Generate a Makefile and run the C compiler</title>
	  
	  <para>The compilation driver in the &main-lib; creates a Makefile
	  and C source files as needed during the compilation process. Once
	  all the necessary code has been generated and the heaps are
	  built, &d2c; invokes <acronym>GNU</acronym>
	  <command>make</command> on the Makefile.</para>
	</formalpara>
      </listitem>
    </itemizedlist>
    
    <sect1 id="gdmaint-d2c-base">
      <title>The <dlibrary>Compiler-Base</dlibrary> Library</title>
      
      <para>The <dlibrary>Compiler-Base</dlibrary> library exports the
      basic data structures used by the compiler. It also provides a number
      of miscellaneous utility modules. Every other library relies on
      <dlibrary>Compiler-Base</dlibrary>.</para>
      
      <sect2 id="gdmaint-d2c-base-miscellaneous">
	<title>Miscellaneous Utility Modules</title>
	
	<para>Several modules in <dlibrary>Compiler-Base</dlibrary> appear
	to contain assorted utility routines used elsewhere in the
	compiler.</para>
	
	<variablelist>
	  <varlistentry>
	    <term><dmodule>Common</dmodule></term>
	    <listitem>
	      <para>This module imports a number of standard modules and
	      re-exports some or all of their constants. Essentially, this
	      module is used to specify a local Dylan dialect for use by
	      the rest of the compiler. It includes
	      <dmodule>Dylan</dmodule>, some of
	      <dmodule>Extensions</dmodule>, a few names from
	      <dmodule>Table-Extensions</dmodule> and several of the
	      <abbrev>I/O</abbrev>-related modules.  </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dmodule>File-System</dmodule></term>
	    <listitem>
	      <para>This module provides a local implementation of parts of
	      the <dlibrary>File-System</dlibrary> library. We can't
	      replace this with the standard implementation without
	      breaking the ability to bootstrap &d2c; with existing version
	      2.2.0 binaries.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dmodule>Utils</dmodule></term>
	    <listitem>
	      <para>This appears to be the <quote>grab bag</quote>
	      module. It holds a mix of completely unrelated minor classes
	      and functions.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect2>

      <sect2 id="gdmaint-d2c-base-od-format">
	<title>The <dmodule>OD-Format</dmodule> Module</title>

	<para>The <dmodule>OD-Format</dmodule> module implements the
	<glossterm>Object Description Format</glossterm>, a binary format
	for storing persistent objects. This is used by the
	<filename>*.lib.du</filename> files emitted by &d2c;, though it
	might be potentially useful elsewhere.</para>

	<para>The file
	<filename>gd/src/d2c/compiler/base/od-format.dylan</filename>
	contains an extensive discussion the module's goals and data
	format. From the top-of-file comment:</para>

	<blockquote>
	  <para>The basic requirement of the "Object Description Format"
          (ODF) is to allow an open-ended variety of objects to be dumped
          into a file, where:</para>

	  <itemizedlist>
	    <listitem>
	      <para>instances may refer to each other in an arbitrary graph
	      structure, and</para>
	    </listitem>
	    <listitem>
	      <para>some of the references may be to objects that are
              defined in distinct object description units (files,
              etc.)</para>
	    </listitem>
	  </itemizedlist>

	  <para>In order to make the design interesting, the ODF attempts
          to satisfy various incompatible requirements:</para>

	  <itemizedlist>
	    <listitem>
	      <para>To support efficient parsing and unparsing on a variety
              of architectures, but also to potentially serve as a
              cross-platform interchange format.</para>
	    </listitem>
	    <listitem>
	      <para>To work well on sequential media (like a socket), but
              also to potentially support random-access demand-loading of
              objects when possible (e.g. on files.)</para>
	    </listitem>
	  </itemizedlist>
	</blockquote>

	<para>We should consider making this into a standalone library at
	some point in the future.</para>

	<dylangenericdef>
	  <defname>dump-od</defname>
	  <defadjectives>Open</defadjectives>
	  <defsummary>Write an object to the dump buffer.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>object</paramname>
	      <paramtype>&lt;object></paramtype>
	      <paramsummary>The object to dump.</paramsummary>
	    </param>
	    <param>
	      <paramname>buffer</paramname>
	      <paramtype>&lt;dump-buffer></paramtype>
	      <paramsummary>The in-memory buffer into which the object
	      should be dumped.</paramsummary>
	    </param>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>This routine is overloaded to dump individual types
	    objects. Methods for primitive Dylan types can be found in
	    <xref linkend="gdmaint-d2c-base-dylan-dump">.</para>
	  </defdescription>
	</dylangenericdef>

	<dylanfunctiondef>
	  <defname>add-od-loader</defname>
	  <defsummary>Register a routine for reading a dumped object back
	  into memory.</defsummary>
	  <defparameters>

	    <param>
	      <paramname>dispatcher</paramname>
	      <paramtype>&lt;dispatcher></paramtype>
	    </param>
	    <param>
	      <paramname>name</paramname>
	      <paramtype>&lt;symbol></paramtype>
	    </param>
	    <param>
	      <paramname>func</paramname>
	      <paramtype>&lt;function></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>This function is the <quote>other half</quote> of
	    <dlit>dump-od</dlit>. It is called to register a routine for
	    reloading dumped objects.</para>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>

      <sect2 id="gdmaint-d2c-base-dylan-dump">
	<title>The <dmodule>Dylan-Dump</dmodule> Module</title>

	<para>This module provides ODF dumping and loading routines for all
	of the primitive types. </para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-compile-time-values">
	<title>The <dmodule>Compile-Time-Values</dmodule> Module</title>

	<para>This module exports <dname>&lt;ct-value></dname>, which
	represents a value known at compile time. It also supplies
	<dname>&lt;literal></dname> and a number of subclasses to represent
	literal strings, integers, lists and other primitive types.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-source">
	<title>The <dmodule>Source</dmodule> Module</title>
      
	<para>&d2c; was designed to fetch source records from several
	sources, including flat text files and eventaully code
	databases. To permit this flexibility, &d2c; uses a very abstract
	interface for representing locations in source code.</para>

	<para>The <dname>&lt;source-location></dname> class is an open,
	abstract class with no slots. All instances must provide a method
	for <dname>describe-source-location</dname>.</para>

	<para>The <dname>source-location</dname> generic takes an arbitrary
	object as an argument and returns a source location. The mix-in
	class <dname>&lt;source-location-mixin></dname> provides the
	init-keyword <dlit>source-location:</dlit> and a method on
	<dlit>source-location</dlit> which returns the value of the keyword
	or <dname>&lt;unknown-source-location></dname>.</para>

	<para>The <dname>&lt;source-file></dname> class reads an entire
	input file into memory and provides access to the contents. It's
	tightly-coupled to the class
	<dname>&lt;file-source-location></dname>, which represents a
	location within a source file. Separating these two classes is not
	feasible. Among other things, this code generates the attractive,
	multiline displays of exactly where an error occured.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-tokens">
	<title>The <dmodule>Tokens</dmodule> Module</title>

	<para>This module provides classes and constants for representing
	tokens and syntax tables.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-header">
	<title>The <dmodule>Header</dmodule> Module</title>

	<para>Dylan source files have <acronym>RFC</acronym> 822 headers,
	similar to those used by Internet e-mail and many other
	protocols. This module provides support for parsing headers at the
	top of a file and extracting the values of keywords. White space at
	the begining and ends of lines is removed automatically.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-platform">
	<title>The <dmodule>Platform</dmodule> Module</title>

	<para>This module contains code to parse
	<filename>platforms.descr</filename>, which contains descriptions
	of the various host platforms supported by &d2c;. A description of
	each of the parameters appears in
	<filename>platforms.descr</filename> itself.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-errors">
	<title>The <dmodule>Errors</dmodule> Module</title>

	<para>This module exports a number of classes and functions related
	to compiler errors and warnings.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-signature">
	<title>The <dmodule>Signature-Interface</dmodule> and
	<dmodule>Signature</dmodule> Modules</title>

	<para>The <dmodule>Signature-Interface</dmodule> module creates a
	group of names which are actually implemented in the
	<dmodule>Signature</dmodule> module. These represent the formal
	parameter and result lists of a Dylan function.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-names">
	<title>The <dmodule>Names</dmodule> Module</title>

	<para>When reporting errors, &d2c; often needs to provide names for
	various functions, anonymous local methods and other things found
	in Dylan programs. This module knows about several different kinds
	of names and how they should be displayed to the user.</para>

	<para>It does not appear that these classes are used in as part of
	the compiler's own computations. A quick look suggests that this is
	merely interface and debugging code.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-definitions">
	<title>The <dmodule>Definitions</dmodule> Module</title>

	<comment>I'm not quite sure what this module does, so take this
	description with a grain of salt. Better yet, figure out what this
	module does and fix this documentation.</comment>

	<para>The top-of-file comment for this module reads:</para>

	<blockquote>
	  <para>Abstract class that all definitions inherit from.  A
          definition is the compilers handle on some run-time value.  In
          addition to the obvious things, definitions exist for things
          like the type of a variable (when it isn't a compile-time
          constant).</para>
	</blockquote>

	<para>It appears that named, top-level forms each get a
	definition. From the comment, it sounds as if the following code
	produces two definitions:</para>

	<programlisting>
define variable foo :: run-time-expression() = #f;
</programlisting>

	<para>One definition refers to the variable itself, and the other
	refers to the type value computed at initialization time. Is this a
	correct assumption?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-variables">
	<title>The <dmodule>Variables</dmodule> Module</title>

	<para>This module is in change of libraries, modules and
	namespaces.  It maintains the global table of libraries, processes
	the various clauses in <dlit>define library</dlit> and <dlit>define
	module</dlit>, and keeps track of where variable definitions
	live. The magic <dmodule>Dylan-User</dmodule> modules get set up
	here as well.</para>

	<para>Each <dname>&lt;variable></dname> object also provides slots
	for the associated definition, transformers and constant
	evaluator. It would appear that this module defines some of the
	more important data structures in the compiler.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-policy">
	<title>The <dmodule>Policy</dmodule> Module</title>

	<para>The <dmodule>Policy</dmodule> represents an
	<glossterm>optimization policy</glossterm>: a set of parameters
	used for making tradeoffs between speed, safety and code size. A
	quick inspection of the code shows that a
	<dname>&lt;policy></dname> object will not survive the dumping and
	loading processes intact. Do these actually get used?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-ctype">
	<title>The <dmodule>CType</dmodule> Module</title>

	<comment>Does <dmodule>ctype</dmodule> stand for <quote>constant
	type</quote>, <quote>compile-time type</quote>, or something else
	entirely?</comment>

	<para>This module contains lots of compile-time type functions,
	including type intesections, type unions and even type
	differences. Their exact role in the bigger scheme of things is
	still unclear.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-transformers">
	<title>The <dmodule>Transformers</dmodule> Module</title>

	<para>Another mystery module. Transformers get attached to function
	definitions and do something complicated to <quote>call
	operations</quote>. Does this have anything to do with compile-time
	method dispatching?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-representation">
	<title>The <dmodule>Representation</dmodule> Module</title>

	<para>This module provides a very abstract interface for choosing
	data representations in generated code. It currently appears to be
	implemented by the <link linkend="gdmaint-d2c-base-c-representation">
        <dmodule>C-Representation</dmodule> module</link>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-classes">
	<title>The <dmodule>Classes</dmodule> Module</title>

	<para>This module contains the guts of the class system, which is
	implemented with classes as a subtype of
	<dname>&lt;ctype></dname>. This module also computes class
	precedence lists, unique class IDs and slot layouts.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-type-dump">
	<title>The <dmodule>Type-Dump</dmodule> Module</title>

	<para>This is an implementation module which contains ODF support
	for various subclasses of <dname>&lt;ctype></dname>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-c-representation">
	<title>The <dmodule>C-Representation</dmodule> Module</title>

	<para>This modules knows about the different C data types. It also
	knows about heap representations, direct representations and
	general representations.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-compile-time-functions">
	<title>The <dmodule>Compile-Time-Functions</dmodule> Module</title>

	<para>From the top-of-file comment:</para>

	<blockquote>
	  <para>A ct-function is a kind of compile-time value used to
          represent a function. ct-functions contain various
          linkage-related information needed to call the function, but
          don't reference the FER for the function (e.g. the
          &lt;function-literal>.)  This information is used both by the
          backend and by the heap builder.</para>
	</blockquote>

	<para>This is also where Peter Housel added the support for
	callback functions. This module includes support for
	<glossterm>general entries</glossterm> and <glossterm>generic
	entries</glossterm>, which are presumably the type-checked and
	dispatched entry points for functions, respectively.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-flow">
	<title>The <dmodule>Flow</dmodule> Module</title>

	<para>This module provides classes representing block-level control
	flow within a function. You should be able to find information on
	this subject in any good compiler textbook.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-parser">
      <title>The <dlibrary>Compiler-Parser</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Parser</dlibrary> library handles
      lexical analysis, parsing and macro expansion. It relies only on the
      &base-lib;.</para>

      <sect2 id="gdmaint-d2c-parser-tokenize">
	<title>The <dmodule>Tokenize</dmodule> Module</title>

	<para>This module provides an abstract class
	<dname>&lt;tokenizer></dname> supporting <dname>get-token</dname>,
	<dname>unget-token</dname> and a few other functions.</para>

	<para>For implementations of this interface, see <xref
        linkend="gdmaint-d2c-parser-lexer"> and <xref
        linkend="gdmaint-d2c-parser-fragments">.</para>
      </sect2>
      
      <sect2 id="gdmaint-d2c-parser-source-utilities">
	<title>The <dmodule>Source-Utilities</dmodule> Module</title>

	<para>This module implements a number of subclasses of
	<dname>&lt;source-location></dname> (see <xref
	linkend="gdmaint-d2c-base-source"> for details) that are used to
	represent the source of tokens during macro expansion.</para>

	<para>There may be slightly more to this module than is apparent at
	first glance.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-lexer">
	<title>The <dmodule>Lexer</dmodule> Module</title>

	<para>This module provides <dname>&lt;lexer></dname>, a subclass of
	<dname>&lt;tokenizer></dname> used to get tokens from a source
	record.</para>
      </sect2>
      
      <sect2 id="gdmaint-d2c-parser-fragments">
	<title>The <dmodule>Fragments</dmodule> Module</title>

	<para>Fragments are the input to and output from macro
	expansion. According to the top-of-file comment:</para>

	<blockquote>
	  <para>The DRM says that:</para>

	  <blockquote>
	    <para>The input to, and output from, a macro expansion is a
            fragment, which is a sequence of elementary fragments.  An
            elementary fragment is one of the following:</para>

	    <itemizedlist>
	      <listitem>
		<para>A token: the output of the lexical grammar. ...</para>
	      </listitem>
	      <listitem>
		<para>A bracketed fragment: balanced brackets ( (), [], or
                {} ) enclosing a fragment.</para>
	      </listitem>
	      <listitem>
		<para>A macro-call fragment: a macro call.</para>
	      </listitem>
	      <listitem>
		<para>A parsed fragment: a single unit that is not
                decomposable into its component tokens.  It has been fully
                parsed by the phrase grammar.  A parsed fragment is either
                an expression, a definition, or a local declaration.</para>
	      </listitem>
	    </itemizedlist>
	  </blockquote>

	  <para>So the parser needs to be able to produce fragments, the
          macro expander needs to be able to destructure and reconstruct
          fragments, and then the parser needs to be able to grovel the
          final results.  This file implements all that.</para>
	</blockquote>

	<para>This module also provides
	<dname>&lt;fragment-tokenizer></dname>, a subclass of
	<dname>&lt;tokenizer></dname> used to get tokens from a macro
	fragment.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-parse-tree">
	<title>The <dmodule>Parse-Tree</dmodule> Module</title>

	<para>This module defines the tree representation used by the
	parser and the macro-expander. (It also includes the classes needed
	to represent the contents of a <dlit>define macro</dlit>
	form.)</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-parser">
	<title>The <dmodule>Parser</dmodule> Module</title>

	<para>This modules takes input from a <dname>&lt;tokenizer></dname>
	and generates a parse tree. It looks like the main entry point is
	<dname>parse-source-record</dname>. There are other entry points
	which are called recursively by the macro expander; these parse a
	single production of Dylan's grammar.</para>

	<para>This module defines the generic function
	<dname>process-top-level-form</dname>. It does not, however, define
	any methods. When the parser has found a top-level form, it calls
	<dname>process-top-level-form</dname> and allows other modules to
	take care of the details. This design may have implications for
	multi-threading and code reuse&mdash;it looks like the parser can
	only be used in one way by any given program.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-macros">
	<title>The <dmodule>Macros</dmodule> Module</title>

	<para>This module implements macro expansion as defined in the
	&drm;. It also provides <dname>&lt;macro-definition></dname> (see
	<xref linkend="gdmaint-d2c-base-definitions">).</para>

	<para>Note that this module only handles those macros which
	expand according to the standard rules. More compilicated macros
	are handled elsewhere by procedural expanders. To define a new
	procedural expander, register it using
	<dname>define-procedural-expander</dname>.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-front">
      <title>The <dlibrary>Compiler-Front</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Front</dlibrary> library is repsonsible
      for processing the <glossterm>Front End Representation</glossterm> of
      a Dylan program. It depends only on the
      &base-lib;.</para>

      <para>Data is passed from the &parser-lib; to the
      <dlibrary>Compiler-Front</dlibrary> library by the
      &convert-lib;.</para>

      <sect2 id="gdmaint-d2c-front-builder-interface">
	<title>The <dmodule>Builder-Interface</dmodule> Module</title>
	
	<para>This module defines an interface which can be used to build
        the <glossterm>front-end representation</glossterm>
        (<acronym>FER</acronym>) of a parsed Dylan program.</para>
	
	<para>Note that this module actually defines two interfaces:
	<dname>&lt;flow-builder></dname>, an abstract interface for
	constructing basic blocks (see <xref
	linkend="gdmaint-d2c-base-flow">); and
	<dname>&lt;fer-builder></dname>, a more specific version of that
	interface which is used to construct the front-end
	representation. It's not apparent that the former, more general
	interface is actually used anywhere else.</para>
	
	<para>This interface is implemented by the <link
	linkend="gdmaint-d2c-front-front"><dmodule>Front</dmodule>
	module</link>.</para>

	<para>The <dname>optimize-component</dname> generic function gets
	implemented by the &optimize-lib;. We need to figure out why it's
	defined here instead of there.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-primitives">
	<title>The <dmodule>Primitives</dmodule> Module</title>

	<para>This module defines the primitive operations which may appear
        in Dylan code.</para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-front">
	<title>The <dmodule>Front</dmodule> Module</title>

	<para>This module does all the heavy lifting for the front-end of
        the compiler. It's split across a number of source files:</para>

	<variablelist>
	  <varlistentry>
	    <term><filename>front.dylan</filename></term>
	    <listitem>
	      <para>The data structures used in the front-end
	      representation.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>builder.dylan</filename></term>
	    <listitem>
	      <para>Abstract classes and generic functions for the
	      <dname>&lt;flow-builder></dname> and
	      <dname>&lt;fer-builder></dname> classes.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>fer-builder.dylan</filename></term>
	    <listitem>
	      <para>The actual implementation of the various builders. This
	      seems to be where the actual front-end code lives.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>fer-dump.dylan</filename></term>
	    <listitem>
	      <para>Code for dumping the front-end representation as
	      text.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>clone.dylan</filename></term>
	    <listitem>
	      <para>Code to clone the data structures representing a
	      top-level function. I'm not sure who uses this or why.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect2>

      <sect2 id="gdmaint-d2c-front-fer-od">
	<title>The <dmodule>FER-OD</dmodule> Module</title>

	<para>This module contains code for dumping the front-end
        representation as ODF (see <xref
        linkend="gdmaint-d2c-base-od-format">). Special case is taken to
        make sure that all dumps start with a
        <dname>&lt;function-literal></dname> object; smaller
        components of the front-end representation can not be dumped
        individually.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-function-definitions">
	<title>The <dmodule>Function-Definitions</dmodule> Module</title>

	<para>This module implements various subclasses of
	<dname>&lt;definition></dname> representing functions (see <xref
	linkend="gdmaint-d2c-base-definitions">). Most of the machinery for
	adding methods to a generic function at compile-time lives here, as
	does a good chunk of code related to sealing.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-variable-definitions">
	<title>The <dmodule>Variable-Definitions</dmodule> Module</title>

	<para>This module implements <dname>&lt;variable-definition></dname>.
        It also contains some of the code for handling load-time type
        expressions.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-top-level-forms">
	<title>The <dmodule>Top-Level-Forms</dmodule> Module</title>

	<para>This is not a very meaty module. It doesn't make much sense
	in the absence of the &convert-lib;. It does, however, contain a
	few classes for describing the things found at the top level of a
	Dylan file and provides the generic function
	<dname>finalize-top-level-form</dname>, which is called by the
	compilation driver once everything has been parsed.</para>

	<para>This should not be confused with the <link
	linkend="gdmaint-d2c-convert-top-level-expressions">
	<dmodule>Top-Level-Expressions</dmodule> module</link>, which
	instantiates the data structures defined in this module.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-convert">
      <title>The <dlibrary>Compiler-Convert</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Convert</dlibrary> library acts as an
      adaptor between the &parser-lib; and the &front-lib;.</para>

      <para>As a rule of thumb, <dlibrary>Compiler-Convert</dlibrary>
      implements those parts of the front end which know about the
      output of the parser.</para>

      <sect2 id="gdmaint-d2c-convert-lexenv">
	<title>The <dmodule>LexEnv</dmodule> Module</title>

	<para>This module implements <glossterm>lexical
	environments</glossterm> (a formal term for <quote>local
	namespaces</quote>). This is the code that associates variable
	names with the correct bindings.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-compile-time-eval">
	<title>The <dmodule>Compile-Time-Eval</dmodule> Module</title>

	<para>This module performs compile-time evaluation of constant
	expressions. It operates on the parsed representation of a Dylan
	program, not the front-end representation.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-expanders">
	<title>The <dmodule>Expanders</dmodule> Module</title>

	<para>This module contains <link
	linkend="gdmaint-d2c-parser-macros">procedural macro
	expanders</link> for basic, built-in macros such as
	<dname>make-if</dname>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-fer-convert">
	<title>The <dmodule>FER-Convert</dmodule> Module</title>

	<para>This module processes chunks of the parse tree and uses the
	<link linkend="gdmaint-d2c-front-builder-interface">
        <dname>&lt;fer-builder></dname></link> to produce the front-end
        representation.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-about-top-level">
	<title>Processing of Top-Level Definitions</title>

	<para>The code to process top-level definitions is spread across
	several libraries. Most of the machinery actually lives here in the
	<dname>Compiler-Convert</dname> library.</para>

	<para>Each top-level form must define methods on three generic
	functions:</para>

	<variablelist>
	  <varlistentry>
	    <term><dname>process-top-level-form</dname></term>
	    <listitem>
	      <para>When the parser finishes with a top-level form, it
	      passes the form to this function, which produces the final
	      parse tree and creates an object representing the top-level
              form. (See <xref linkend="gdmaint-d2c-parser-parser">.)</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dname>finalize-top-level-form</dname></term>
	    <listitem>
	      <para>This function is called by the compilation driver when
	      all the top-level forms have been parsed. It's used to
	      implement various kinds of foward references within a
	      module.
              (See <xref linkend="gdmaint-d2c-front-top-level-forms">.)</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dname>convert-top-level-form</dname></term>
	    <listitem>
	      <para>Once a top-level form has been processed and finalized,
              it can be converted to the appropriate front-end
              representation. Methods on this function use the
              <dname>&lt;fer-builder></dname> interface. (See <xref
	      linkend="gdmaint-d2c-front-top-level-forms"> and <xref
              linkend="gdmaint-d2c-front-builder-interface">.)</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Generally speaking, the parsed representation of a built-in
	<dlit>define foo</dlit> form would be named
	<dname>&lt;define-foo-parse></dname>. The object representing the
	top-level form itself would be named
	<dname>&lt;define-foo-tlf></dname>. There's also a
	<dname>&lt;foo-definition></dname> floating around in most cases.
	The relationships between these three representations need to be
	documented.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-macros">
	<title>The <dmodule>Define-Macros</dmodule> Module</title>

	<para>This module handles <dlit>define macro</dlit> forms and
	<glossterm>macro calls</glossterm> which appear at the top
	level.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-conv-define-lib-and-mod">
	<title>The <dmodule>Define-Libraries-and-Modules</dmodule>
	Module</title>

	<para>This module handles <dlit>define library</dlit> and
	<dlit>define module</dlit> forms.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-functions">
	<title>The <dmodule>Define-Functions</dmodule> Module</title>

	<para>This module handles <dlit>define generic</dlit> and
	<dlit>define method</dlit> forms. (<dlit>define function</dlit>
	forms are expanded by a macro defined in the runtime library.) Most
	of the logic for <glossterm>implicit generic functions</glossterm>
	lives here.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-conv-define-const-and-var">
	<title>The <dmodule>Define-Constants-and-Variables</dmodule>
	Module</title>

	<para>This module handles <dlit>define generic</dlit> and
	<dlit>define method</dlit> forms. It also includes code for
	<glossterm>constant methods</glossterm>, which may get used in a
	few strange places. More research is needed here.</para>

	<para>This module contains an alarming number of <quote>shouldn't
	happen</quote> errors. Is this left-over code, safety checks for a
	fragile area of the compiler, or evidence of some fundamental
	confusion about what's going on?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-classes">
	<title>The <dmodule>Define-Classes</dmodule> Module</title>

	<para>This library handles <dlit>define class</dlit> forms. There's
	a lot in here, including <link
	linkend="gdmaint-d2c-base-ctype"><glossterm>ctype</glossterm>
	calculation</link> for classes and creation of getter and setter
	methods. It's not immediately clear how this relates to the code in
	<link linkend="gdmaint-d2c-base-classes">the module
	<dmodule>Classes</dmodule></link>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-top-level-expressions">
	<title>The <dmodule>Top-Level-Expressions</dmodule> Module</title>

	<para>This module handles actual code appearing at the top
	level. There's also something going on with
	<dname>&lt;magic-interal-primitives-placeholder></dname>, which is
	(of course) excessively magic. If you're the sort of person who
	likes to figure out how magicians do their tricks, feel free to
	figure this out for the rest of us.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-optimize">
      <title>The <dlibrary>Compiler-Optimize</dlibrary> Library</title>

      <para>&d2c; was written as a research project. As such, it contains
      some very sophisticated optimization routines but occasionally omits
      other, more common optimizations.</para>

      <sect2 id="gdmaint-d2c-optimize-cheese">
	<title>The <dmodule>Cheese</dmodule> Module</title>

	<para>For some unknown reason, all of the optimization code found
	in the compiler is contained in a single module named
	<dmodule>Cheese</dmodule>. Furthermore, this module does not
	actually provide an entrance point for optimizing a chunk of code.
	Instead, it adds methods to the generic function
	<dname>optimize-component</dname>, which is exported by the <link
	linkend="gdmaint-d2c-front-builder-interface">
	<dmodule>Builder-Interface</dmodule> module</link>. This interface
	is somewhat less than amusing.</para>

	<para>To study this module, begin by reading the method
	<dname>optimize-component</dname> in the file
	<filename>cheese.dylan</filename>. This calls each of the various
	optimization routines, which are grouped by file.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-cback">
      <title>The <dlibrary>Compiler-CBack</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-CBack</dlibrary> library generates C
      code from the optimized front-end representation of a
      component.</para>

      <sect2 id="gdmaint-d2c-cback-stack-analysis">
	<title>The <dmodule>Stack-Analysis</dmodule> Module</title>

	<para>This module analyzes the stack usage of a function. It's
	relatively straightforward and independent of the rest of the back
	end.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-cback-cback">
	<title>The <dmodule>CBack</dmodule> Module</title>

	<para>This module has two main entry points:
	<dname>emit-tlf-gunk</dname> and <dname>emit-component</dname>. The
	former emits arbitrary C code needed by a given top-level form. The
	latter translates a Dylan function into actual C code.</para>

	<para>The file <filename>cback.dylan</filename> contains more
	documentation about how things work.</para>

	<para>Right now, the back end assumes that the optimizer has been
	run. It's unclear which optimizations can be skipped safely.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-cback-heap">
	<title>The <dmodule>Heap</dmodule> Module</title>

	<para>This module emits local (per library) and global (per
	application) heaps. Extensive documentation can be found in
	<filename>heap.dylan</filename>.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-main">
      <title>The <dlibrary>Compiler-Main</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Main</dlibrary> library contains the
      actual compilation driver.</para>

      <sect2 id="gdmaint-d2c-main-main">
	<title>The <dmodule>Main</dmodule> Module</title>

	<para>This module provides the command-line interface and
	compilation driver for &d2c;. It's relatively safe to make changes
	here, because they generally don't affect the rest of the
	compiler.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-dylan">
      <title>The <dlibrary>Dylan</dlibrary> Runtime Library</title>

      <para>The runtime library is strongly dependent on the internal
      workings of &d2c;. A moderate amount of code duplication occurs:
      &d2c; will contain a compile-time version of a function and the
      runtime will contain a fully dynamic version.</para>
    </sect1>
  </chapter>

  <CHAPTER id="gdmaint-melange-internals">
    <TITLE>Melange Internals Guide</TITLE>

    <PARA>Melange is scheduled to be replaced by Pidgin in a future version
    of Gwydion Dylan. Therefore, this section of the guide will eventually
    contain a description of Pidgin and its public APIs.</PARA>
  </CHAPTER>

  <APPENDIX id="gdmaint-style">
    <TITLE>Gwydion Project Coding Style Guide</TITLE>

    <NOTE>
      <PARA>This appendix lists the Dylan language coding style
      guidelines formerly used by the Gwydion Project.</PARA>
    </NOTE>
    
    <PARA>This file lists two broad categories of style issues for
    Dylan.  One category, called "Recommended", contains style points
    to which Gwydion programmers should adhere, as opposed to "must
    adhere".  If someone sometimes, or even always, breaks a
    recommended style point, then others must to be tolerant of that
    deviation.  You must not modify the original author's code purely
    to satisfy an urge to convert the original author's style to your
    own.  The second category, called "Mandated", contains style
    points to which Gwydion programmers must adhere.  If you find
    someone has deviated from a mandated style point, then you may
    convert the code to be the mandated style.</PARA>

    <SECT1 id="gdmaint-style-recommended">
      <TITLE>Recommended</TITLE>

      <SECT2 id="gdmaint-style-indent-level">
	<TITLE>Indent level</TITLE>

	<PARA> You should use a two-space indentation.  Each time code
	needs to be further indented, you should use one indent level,
	which is two spaces.</PARA>
      </SECT2>

      <SECT2 id="gdmaint-style-wrapping-slot-descriptions">
	<TITLE>Indent wrapping slot descriptions</TITLE>

	<PARA>When a slot description wraps to a new line in a "define
        class" form, the extra lines should be indented one extra
        indent level.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-triple-slash-comments">
	<TITLE>Using <LITERAL>///</LITERAL> comments</TITLE>

	<PARA>If you use <LITERAL>///</LITERAL> comments, they should
        only be used between top-level declarations.
        <LITERAL>///</LITERAL> comments can be used for logical page
        headers, inter-function comments, code section introductions
        (logical page headers), etc., for example:</PARA>

	<PROGRAMLISTING>
...
end method;

/// order-espresso -- Method for Exported GF.
///
/// This method orders espresso at carts on the corner when it is
/// raining.  If it is not raining, this method delegates to
/// next-method. 
///
define method order-espresso (vendor :: &lt;outdoor-espresso-cart&gt;,
                              #next next-method)
  => ();
  ...
end method;</PROGRAMLISTING>
	
	<PARA>Many programmers do not like others to use
        <LITERAL>///</LITERAL> comments.  Rob noted that if these are
        only used between top-level declarations, where the
        <LITERAL>///</LITERAL> indicates a comment of wider scope (as
        over a whole definition or logical page), then the Gwydion
        environment should be able to display such comments however
        any particular user wants to see them.</PARA>
      </SECT2>
      <SECT2 id="gdmaint-style-c-comments">
	<TITLE>Using <LITERAL>/* ... */</LITERAL></TITLE>
	
	<PARA>If you use <LITERAL>/* ... */</LITERAL> comments, they
        should only be used at the beginning of a file or the
        beginning of a logical page so that their use is highly
        localized.  This prevents them from showing up surprisingly in
        random places throughout a file of code.  Using
        <LITERAL>/*...*/</LITERAL> comments should go away once the
        Gwydion environment has a means for linking general commentary
        to logical units of code.  This issue has absolutely nothing
        to do with using <LITERAL>/*...*/</LITERAL> to temporarily
        exclude code fragments.</PARA>
      </SECT2>
      <SECT2 id="gdmaint-style-wrapping-function-headers">
	<TITLE>Wrapping function definition headers</TITLE>

	<PARA>When a function header wraps (that is, a <LITERAL>define
	generic</LITERAL> or a <LITERAL>define module</LITERAL>
	declaration), you should either break the line within the
	parameter list or between the name and the parameter list.  If
	you break the line between the name and parameter list, or
	perhaps after the parameter list, then you should indent any
	extra lines one extra indent level.  There is one exception:
	the first line of the return values specification may be
	indented only one space.  The following are examples of
	recommended style:</PARA>

	<PROGRAMLISTING>
define method some-longer-name-for-effect
    (one :: &lt;class-1&gt;, two :: &lt;class-2&gt;, ...)
    => (result1 :: &lt;type1&gt;, result2 :: &lt;type2&gt;);
  statement1;
  statement2;
  ...;
end method;

define method some-longer-name-for-effect
    (one :: &lt;class-1&gt;, two :: &lt;class-2&gt;, ...)
 => (result1 :: &lt;type1&gt;, result2 :: &lt;type2&gt;);
  statement1;
  statement2;
  ...;
end method;</PROGRAMLISTING>
      </SECT2>
      <SECT2 id="gdmaint-style-indent-keyword-parameters">
	<TITLE>Indent keyword parameters beyond
	<LITERAL>#key</LITERAL> token</TITLE>

	<PARA> If there is more than one keyword parameter specified
	in a function declaration, then all keyword parameter
	specifications should line up with the first specification.
	The following is an example:</PARA>
	
	<PROGRAMLISTING>
define method foo (foo :: &lt;simple-object-vector&gt;,
                   #key start :: &lt;fixed-integer&gt; = 0,
		        stop :: &lt;fixed-integer&gt; = foo.size)
  ...</PROGRAMLISTING>
	
	<PARA>If a parameter list that contains a
        <LITERAL>#key</LITERAL> wraps, then you should wrap the
        parameter list before the <LITERAL>#key</LITERAL>
        token.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-indent-varconst">
	<TITLE>Wrapping variable and constant definitions</TITLE>
	
	<PARA>When a variable or constant definition wraps, you should
        break the line before the <LITERAL>=</LITERAL> token:</PARA>
	
	<PROGRAMLISTING>
define constant western-culture :: &lt;integer&gt;
  = north-america-mask | south-america-mask | europe-mask;</PROGRAMLISTING>
      </SECT2>
      
      <SECT2 id="gdmaint-style-end-foo">
	<TITLE>Using <LITERAL>end <PARAMETER>mumble</PARAMETER></LITERAL>
        to terminate statements</TITLE>
	
	<PARA>You should use <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL>, rather than just
	<LITERAL>end</LITERAL>, whenever there is sufficient vertical
	space between the beginning and the end of the statement to
	hinder readability.  Some programmers like to use <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL> religiously, but those
	same programmers only use "end" when using <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL> would make a
	single-line statement wrap onto a new line.  Programmers may
	add the <LITERAL><PARAMETER>mumble</PARAMETER></LITERAL> to an
	<LITERAL>end</LITERAL> if they feel the code was hard to
	visually scan, but programmers should not add
	<LITERAL><PARAMETER>mumble</PARAMETER></LITERAL>s to all
	<LITERAL>end</LITERAL>s in someone else's code just because
	they like that style.  This policy is consistent with adding
	additional comments to someone else's code to help
	readability.</PARA>
      </SECT2>

      <SECT2 id="gdmaint-style-horizonal">
	<TITLE>Horizontal space for columnization or other visual
	effects</TITLE>

	<PARA>You should NOT use horizontal spacing to columnize
	aspects of Dylan code, or to present other visual effects
	within the program.  If you do this, you should do it rarely.
	The one exception to this rule is the "Indent keyword
	parameters beyond #key token" recommendation.</PARA>
      </SECT2>

      <SECT2 id="gdmaint-style-keyword-syntax">
	<TITLE>Keyword syntax</TITLE>
	
	<PARA> You should only use keyword notation for symbols in
        function calls and function declarations.  You can also use
        keyword notation in slot descriptions within <LITERAL>define
        class</LITERAL>, where you are supplying a symbol to be the
        key for an initialization argument.  When a symbol is a value,
        such as a default value in a declaration or an argument value
        in a call, you should use symbol notation, not keyword
        notation.  The following are examples of recommended
        style:</PARA>

	<PROGRAMLISTING>
define method reposition (stream :: &lt;stream&gt;, offset :: &lt;integer&gt;,
                          #key from: = #"start")


define method foo ()
  ...
  bar(x, y, color: #"red");
  ...
end method;

// In this example, required-init-keyword: would always be in
// keyword notation, and "foo:" is the item to which this style
// recommendation speaks.
//
define class &lt;frob&gt;
  slot gag, required-init-keyword: foo:;
end;
//
// Or ...
//
define class &lt;frob&gt;
  slot gag, required-init-keyword: #"foo";
end;</PROGRAMLISTING>
      </SECT2>

      <SECT2 id="gdmaint-style-blank-lines-before-decls">
	<TITLE>Blank comment line between introductory comments and
	definitions</TITLE>
	
	<PARA> You should include a blank comment line between the
        introductory comments for a function and the function
        definition.  This applies to any top-level declaration for
        which you supply an introductory comment.  The following is an
        example:</PARA>
	
	<PROGRAMLISTING>
// Blah blah blah GINGER blah blah blah.
//
define ...</PROGRAMLISTING>
      </SECT2>
      
      <SECT2 id="gdmaint-style-wrapping-case">
	<TITLE>Wrapping <LITERAL>case</LITERAL> statements (applies to
	<LITERAL>select</LITERAL> too)</TITLE>
	
	<PARA>If any single branch of a <LITERAL>case</LITERAL>
        statement wraps, then you should wrap every branch.  In
        practice, there are common exceptions to this
        recommendation.</PARA>

	<PARA> When wrapping a case statement, you should wrap it
        after the <LITERAL>=></LITERAL> token.  There should be no
        exceptions to this recommendation.</PARA>

	<PARA>	The following exhibit the recommended style:</PARA>

	<PROGRAMLISTING>
case
  test1 => expression1;
  test2 => expression2;
end;

case
  test1 =>
    statement1;
    statement2;
  test2 =>
    statement1;
    statement2;
end;</PROGRAMLISTING>
      </SECT2>

      <SECT2 id="gdmaint-style-otherwise">
	<TITLE>Using <LITERAL>#t</LITERAL> for
	<LITERAL>otherwise</LITERAL> in <LITERAL>case</LITERAL>
	statements</TITLE>
	
	<PARA> You should not use <LITERAL>#t</LITERAL> for
	<LITERAL>otherwise</LITERAL> in <LITERAL>case</LITERAL>
	statements.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-for-clauses">
	<TITLE>Wrapping <LITERAL>for</LITERAL> clauses</TITLE>
	
	<PARA>When an <LITERAL>=</LITERAL>/<LITERAL>then</LITERAL>
        clause needs to wrap, you should wrap before the
        <LITERAL>=</LITERAL> and before the 'then'.  Both the '=' and
        the 'then' should be indented one extra indent level:</PARA>

	<PROGRAMLISTING>
// Correct.
//
... nested levels ...
                 for (some-index
			= initialization-expression(x, y, z)
			then stepper(u, v, w))
	           stuff(some-index);
		 end;

// Incorrect.
//
... nested levels ...
                 for (some-index = initialization-expression(x, y, z)
			then stepper(u, v, w))
		   stuff(some-index);
		 end;</PROGRAMLISTING>
      </SECT2>
    </SECT1>
    
    <SECT1 id="gdmaint-style-mandated">
      <TITLE>Mandated</TITLE>
      
      <SECT2 id="gdmaint-style-open-paren-after-func-def">
	<TITLE>Function name and open paren</TITLE>
	
	<PARA> The <LITERAL>define generic</LITERAL> or
        <LITERAL>define method</LITERAL> declarations must have a
        space or newline between the name of the definition and the
        parameter list.  At any function call site, the name and open
        paren must be adjacent, with no intervening characters.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-wrappping-let">
	<TITLE>Wrapping <LITERAL>let</LITERAL> statements</TITLE>

	<PARA>If a <LITERAL>let</LITERAL> statement wraps, you must
	put the equal sign on a new line and indent it one extra
	indent level.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-semicolons">
	<TITLE>Terminate statements with semicolons</TITLE>

	<PARA>Semicolons are terminators and must appear wherever they
	are optional, except as covered by the "Single-line
	statements" mandate.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-single-line-statements">
	<TITLE>Single-line statements</TITLE>
	
	<PARA> Single-line statement, such as if-else, must not have
        any internal semicolons.  If a single-line statement requires
        an internal semicolon, then you must break the statement into
        multiple lines.  For example, the following would be illegal
        in Gwydion style:</PARA>
	<PROGRAMLISTING>
let x = if (some-test) foo(); 3; else 5; end;
let x = if (some-test) foo(); 3 else 5 end;
let f = method (a, b) foo(); #f; end;</PROGRAMLISTING>
	
	<PARA>These should be formatted as follows (ignoring the
	<LITERAL>end if</LITERAL> issue):</PARA>

	<PROGRAMLISTING>
let x = if (some-test)
   foo();
   3;
 else
   5;
 end;
let f = method (a, b)
   foo();
   #f;
 end;</PROGRAMLISTING>
	
	<PARA> Most programmers felt this rule, by its nature of
        eliminating multiple statements within a block on a single
        line, made code much more readable.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-wrappping-expr">
	<TITLE>Wrapping arithmetic/boolean expressions</TITLE>
	
	<PARA> You must wrap long expressions before operators and
        indent the operators with one extra indent level from the
        beginning of the expression.  Note, assignments are considered
        to be "statements", and the "expression" that wraps is the
        code on the right-hand side of the assignment operator.
        Therefore, the first two examples below are considered to be
        approved style, but the third is not:</PARA>
	
	<PROGRAMLISTING>
my-local := big-computation(arg1, arg2)
       + another-hairy-long-calculation(arg3, arg4, arg5)
my-local := (big-computation(arg1, arg2)
        + another-hairy-long-calculation(arg3, arg4, arg5))
my-local := big-computation(arg1, arg2)
  + another-hairy-long-calculation(arg3, arg4, arg5)</PROGRAMLISTING>
      </SECT2>
    </SECT1>
  </APPENDIX>
</BOOK>
