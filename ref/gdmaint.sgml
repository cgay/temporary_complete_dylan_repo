<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.0//EN" [
 <!ENTITY % entities SYSTEM "entities.sgml">
 %entities;
]>
<BOOK id="gdmaint">
  <title>Gwydion Dylan Porting and Maintenance Guide</title>
  <titleabbrev>Maintenance Guide</titleabbrev>

  <bookinfo>
    <COPYRIGHT>
      <YEAR>1998</YEAR>
      <HOLDER>Carnegie Mellon University</HOLDER>
      <HOLDER>Gwydion Dylan Maintainers</HOLDER>
    </COPYRIGHT>
    &cmu.terms;
    <bookbiblio>
      <date>09 September 1998</date>
      <editor>&person.housel;</editor>
    </bookbiblio>
  </bookinfo>

  <CHAPTER id="gdmaint-introduction">
    <TITLE>Introduction</TITLE>

    <PARA>This manual serves as a guide to porting and maintaining
    Gywdion &dylan;.  It includes:</PARA>

    <ITEMIZEDLIST>
      <LISTITEM>
	<PARA>Guidelines for porting &mindy; and &d2c; to new platforms</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>An overview of the &mindy; interpreter</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>A detailed guide to the internals of the &d2c; compiler</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>A guide to the internals of the
	<COMMAND>melange</COMMAND> interface generator</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>An appendix containing the Gwydion Project coding
	guidelines.</PARA>
      </LISTITEM>
    </ITEMIZEDLIST>

  </CHAPTER>

  <CHAPTER id="gdmaint-porting">
    <TITLE>Porting Gwydion Dylan to a New Platform</TITLE>

    <PARA>Here's a rough overview of how to port &d2c;. Take this with a
    grain of salt; the rules change occasionally.</PARA>

    <itemizedlist>
      <listitem>
	<para>Add your platform to the <filename>platforms.descr</filename>
	file and <filename>configure.in</filename>. This will require a bit
	of delibrate research.</para>
      </listitem>
      <listitem>
	<para>Look in other places, such as the various
	<filename>Makegen</filename> files and platform-specific Melange
	code. Do something intelligent.</para>
      </listitem>
      <listitem>
	<para>Make sure that the Boehm GC runs on your platform. If not,
	you need to talk to the Boehm list.</para>
      </listitem>
      <listitem>
	<para>Run <command>configure</command> with the flag
	<literal>--enable-mindy-bootstrap</literal>, then run
	<command>make</command>. Be prepared to wait, and be ready to fix
	any bugs you encounter.</para>
      </listitem>
      <listitem>
	<para>Gripe to <email>gd-hackers@randomhacks.com</email> when it
	breaks. We'll help you sort out the mess.</para>
      </listitem>
    </itemizedlist>

    <para>The more your platform looks like a 32-bit Unix system with the
    GNU tools, the easier things will be. Supporting 64-bit platforms is a
    minor project requiring a number of changes to &d2c; (Mindy already
    works on Alpha Linux, thanks to the efforts of Jeff Dubrule). Windows
    support has been broken slightly since the 2.0 days, but most of the
    problems are in the build system, not the source itself.</para>

    <para>Macintoshes, vendor C compilers and other such oddities are the
    responsibility of those who use them. We'll be happy to help, but
    you'll probably need to find a significant number of dedicated
    volunteers to help you fix any problems you encounter.</para>
  </CHAPTER>

  <CHAPTER id="gdmaint-mindy-internals">
    <TITLE>Mindy Internals Guide</TITLE>

    <PARA>FIXME: to be supplied later.</PARA>
  </CHAPTER>

  <chapter id="gdmaint-d2c-internals">
    <docinfo><author>&person.emk;</author></docinfo>
    <title>&d2c; Internals Guide</title>

    <para>The &d2c; compiler was developed by the Gwydion Project at
    CMU. This chapter explains the structure of &d2c; and gives a brief
    overview of how the various components interact.</para>

    <sect1 id="gdmaint-d2c-base">
      <title>The <dlibrary>Compiler-Base</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Base</dlibrary> library exports the
      basic data structures used by the compiler. It also provides a number
      of miscellaneous utility modules. Every other library relies on
      <dlibrary>Compiler-Base</dlibrary>.</para>

      <sect2 id="gdmaint-d2c-base-miscellaneous">
	<title>Miscellaneous Utility Modules</title>

	<para>Several modules in <dlibrary>Compiler-Base</dlibrary> appear
	to contain assorted utility routines used elsewhere in the
	compiler.</para>

	<variablelist>
	  <varlistentry>
	    <term><dmodule>Common</dmodule></term>
	    <listitem>
	      <para>This module imports a number of standard modules and
	      re-exports some or all of their constants. Essentially, this
	      module is used to specify a local Dylan dialect for use by
	      the rest of the compiler. It includes
	      <dmodule>Dylan</dmodule>, some of
	      <dmodule>Extensions</dmodule>, a few names from
	      <dmodule>Table-Extensions</dmodule> and several of the
	      <abbrev>I/O</abbrev>-related modules.
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dmodule>File-System</dmodule></term>
	    <listitem>
	      <para>This module provides a local implementation of parts of
	      the <dlibrary>File-System</dlibrary> library. We can't
	      replace this with the standard implementation without
	      breaking the ability to bootstrap &d2c; with existing version
	      2.2.0 binaries.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dmodule>Utils</dmodule></term>
	    <listitem>
	      <para>This appears to be the <quote>grab bag</quote>
	      module. It holds a mix of completely unrelated minor classes
	      and functions.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect2>

      <sect2 id="gdmaint-d2c-base-od-format">
	<title>The <dmodule>OD-Format</dmodule> Module</title>

	<para>The <dmodule>OD-Format</dmodule> module implements the
	<glossterm>Object Description Format</glossterm>, a binary format
	for storing persistent objects. This is used by the
	<filename>*.lib.du</filename> files emitted by &d2c;, though it
	might be potentially useful elsewhere.</para>

	<para>The file
	<filename>gd/src/d2c/compiler/base/od-format.dylan</filename>
	contains an extensive discussion the module's goals and data
	format. From the top-of-file comment:</para>

	<blockquote>
	  <para>The basic requirement of the "Object Description Format"
          (ODF) is to allow an open-ended variety of objects to be dumped
          into a file, where:</para>

	  <itemizedlist>
	    <listitem>
	      <para>instances may refer to each other in an arbitrary graph
	      structure, and</para>
	    </listitem>
	    <listitem>
	      <para>some of the references may be to objects that are
              defined in distinct object description units (files,
              etc.)</para>
	    </listitem>
	  </itemizedlist>

	  <para>In order to make the design interesting, the ODF attempts
          to satisfy various incompatible requirements:</para>

	  <itemizedlist>
	    <listitem>
	      <para>To support efficient parsing and unparsing on a variety
              of architectures, but also to potentially serve as a
              cross-platform interchange format.</para>
	    </listitem>
	    <listitem>
	      <para>To work well on sequential media (like a socket), but
              also to potentially support random-access demand-loading of
              objects when possible (e.g. on files.)</para>
	    </listitem>
	  </itemizedlist>
	</blockquote>

	<para>We should consider making this into a standalone library at
	some point in the future.</para>

	<dylangenericdef>
	  <defname>dump-od</defname>
	  <defadjectives>Open</defadjectives>
	  <defsummary>Write an object to the dump buffer.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>object</paramname>
	      <paramtype>&lt;object></paramtype>
	      <paramsummary>The object to dump.</paramsummary>
	    </param>
	    <param>
	      <paramname>buffer</paramname>
	      <paramtype>&lt;dump-buffer></paramtype>
	      <paramsummary>The in-memory buffer into which the object
	      should be dumped.</paramsummary>
	    </param>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>This routine is overloaded to dump individual types
	    objects. Methods for primitive Dylan types can be found in
	    <xref linkend="gdmaint-d2c-base-dylan-dump">.</para>
	  </defdescription>
	</dylangenericdef>

	<dylanfunctiondef>
	  <defname>add-od-loader</defname>
	  <defsummary>Register a routine for reading a dumped object back
	  into memory.</defsummary>
	  <defparameters>

	    <param>
	      <paramname>dispatcher</paramname>
	      <paramtype>&lt;dispatcher></paramtype>
	    </param>
	    <param>
	      <paramname>name</paramname>
	      <paramtype>&lt;symbol></paramtype>
	    </param>
	    <param>
	      <paramname>func</paramname>
	      <paramtype>&lt;function></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>This function is the <quote>other half</quote> of
	    <dlit>dump-od</dlit>. It is called to register a routine for
	    reloading dumped objects.</para>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>

      <sect2 id="gdmaint-d2c-base-dylan-dump">
	<title>The <dmodule>Dylan-Dump</dmodule> Module</title>

	<para>This module provides ODF dumping and loading routines for all
	of the primitive types. </para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-compile-time-values">
	<title>The <dmodule>Compile-Time-Values</dmodule> Module</title>

	<para>This module exports <dname>&lt;ct-value></dname>, which
	represents a value known at compile time. It also supplies
	<dname>&lt;literal></dname> and a number of subclasses to represent
	literal strings, integers, lists and other primitive types.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-source">
	<title>The <dmodule>Source</dmodule> Module</title>
      
	<para>&d2c; was designed to fetch source records from several
	sources, including flat text files and eventaully code
	databases. To permit this flexibility, &d2c; uses a very abstract
	interface for representing locations in source code.</para>

	<para>The <dname>&lt;source-location></dname> class is an open,
	abstract class with no slots. All instances must provide a method
	for <dname>describe-source-location</dname>.</para>

	<para>The <dname>source-location</dname> generic takes an arbitrary
	object as an argument and returns a source location. The mix-in
	class <dname>&lt;source-location-mixin></dname> provides the
	init-keyword <dlit>source-location:</dlit> and a method on
	<dlit>source-location</dlit> which returns the value of the keyword
	or <dname>&lt;unknown-source-location></dname>.</para>

	<para>The <dname>&lt;source-file></dname> class reads an entire
	input file into memory and provides access to the contents. It's
	tightly-coupled to the class
	<dname>&lt;file-source-location></dname>, which represents a
	location within a source file. Separating these two classes is not
	feasible. Among other things, this code generates the attractive,
	multiline displays of exactly where an error occured.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-tokens">
	<title>The <dmodule>Tokens</dmodule> Module</title>

	<para>This module provides classes and constants for representing
	tokens and syntax tables.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-header">
	<title>The <dmodule>Header</dmodule> Module</title>

	<para>Dylan source files have <acronym>RFC</acronym> 822 headers,
	similar to those used by Internet e-mail and many other
	protocols. This module provides support for parsing headers at the
	top of a file and extracting the values of keywords. White space at
	the begining and ends of lines is removed automatically.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-platform">
	<title>The <dmodule>Platform</dmodule> Module</title>

	<para>This module contains code to parse
	<filename>platforms.descr</filename>, which contains descriptions
	of the various host platforms supported by &d2c;. A description of
	each of the parameters appears in
	<filename>platforms.descr</filename> itself.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-errors">
	<title>The <dmodule>Errors</dmodule> Module</title>

	<para>This module exports a number of classes and functions related
	to compiler errors and warnings.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-signature">
	<title>The <dmodule>Signature-Interface</dmodule> and
	<dmodule>Signature</dmodule> Modules</title>

	<para>The <dmodule>Signature-Interface</dmodule> module creates a
	group of names which are actually implemented in the
	<dmodule>Signature</dmodule> module. These represent the formal
	parameter and result lists of a Dylan function.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-names">
	<title>The <dmodule>Names</dmodule> Module</title>

	<para>When reporting errors, &d2c; often needs to provide names for
	various functions, anonymous local methods and other things found
	in Dylan programs. This module knows about several different kinds
	of names and how they should be displayed to the user.</para>

	<para>It does not appear that these classes are used in as part of
	the compiler's own computations. A quick look suggests that this is
	merely interface and debugging code.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-definitions">
	<title>The <dmodule>Definitions</dmodule> Module</title>

	<comment>I'm not quite sure what this module does, so take this
	description with a grain of salt. Better yet, figure out what this
	module does and fix this documentation.</comment>

	<para>The top-of-file comment for this module reads:</para>

	<blockquote>
	  <para>Abstract class that all definitions inherit from.  A
          definition is the compilers handle on some run-time value.  In
          addition to the obvious things, definitions exist for things
          like the type of a variable (when it isn't a compile-time
          constant).</para>
	</blockquote>

	<para>It appears that named, top-level forms each get a
	definition. From the comment, it sounds as if the following code
	produces two definitions:</para>

	<programlisting>
define variable foo :: run-time-expression() = #f;
</programlisting>

	<para>One definition refers to the variable itself, and the other
	refers to the type value computed at initialization time. Is this a
	correct assumption?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-variables">
	<title>The <dmodule>Variables</dmodule> Module</title>

	<para>This module is in change of libraries, modules and
	namespaces.  It maintains the global table of libraries, processes
	the various clauses in <dlit>define library</dlit> and <dlit>define
	module</dlit>, and keeps track of where variable definitions
	live. The magic <dmodule>Dylan-User</dmodule> modules get set up
	here as well.</para>

	<para>Each <dname>&lt;variable></dname> object also provides slots
	for the associated definition, transformers and constant
	evaluator. It would appear that this module defines some of the
	more important data structures in the compiler.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-policy">
	<title>The <dmodule>Policy</dmodule> Module</title>

	<para>The <dmodule>Policy</dmodule> represents an
	<glossterm>optimization policy</glossterm>: a set of parameters
	used for making tradeoffs between speed, safety and code size. A
	quick inspection of the code shows that a
	<dname>%lt;policy></dname> object will not survive the dumping and
	loading processes intact. Do these actually get used?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-ctype">
	<title>The <dmodule>CType</dmodule> Module</title>

	<comment>Does <dmodule>ctype</dmodule> stand for <quote>constant
	type</quote>, <quote>compile-time type</quote>, or something else
	entirely?</comment>

	<para>This module contains lots of compile-time type functions,
	including type intesections, type unions and even type
	differences. Their exact role in the bigger scheme of things is
	still unclear.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-transformers">
	<title>The <dmodule>Transformers</dmodule> Module</title>

	<para>Another mystery module. Transformers get attached to function
	definitions and do something complicated to <quote>call
	operations</quote>. Does this have anything to do with compile-time
	method dispatching?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-representation">
	<title>The <dmodule>Representation</dmodule> Module</title>

	<para>This module provides a very abstract interface for choosing
	data representations in generated code. It currently appears to be
	implemented by the <link linkend="gdmaint-d2c-base-c-representation">
        <dmodule>C-Representation</dmodule> module</link>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-classes">
	<title>The <dmodule>Classes</dmodule> Module</title>

	<para>This module contains the guts of the class system, which is
	implemented with classes as a subtype of
	<dname>&lt;ctype></dname>. This module also computes class
	precedence lists, unique class IDs and slot layouts.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-type-dump">
	<title>The <dmodule>Type-Dump</dmodule> Module</title>

	<para>This is an implementation module which contains ODF support
	for various subclasses of <dname>&lt;ctype></dname>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-c-representation">
	<title>The <dmodule>C-Representation</dmodule> Module</title>

	<para>This modules knows about the different C data types. It also
	knows about heap representations, direct representations and
	general representations.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-compile-time-functions">
	<title>The <dmodule>Compile-Time-Functions</dmodule> Module</title>

	<para>From the top-of-file comment:</para>

	<blockquote>
	  <para>A ct-function is a kind of compile-time value used to
          represent a function. ct-functions contain various
          linkage-related information needed to call the function, but
          don't reference the FER for the function (e.g. the
          &lt;function-literal>.)  This information is used both by the
          backend and by the heap builder.</para>
	</blockquote>

	<para>This is also where Peter Housel added the support for
	callback functions. This module includes support for
	<glossterm>general entries</glossterm> and <glossterm>generic
	entries</glossterm>, which are presumably the dispatched and
	type-checked entry points for functions, respectively.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-flow">
	<title>The <dmodule>Flow</dmodule> Module</title>

	<para>This module provides classes representing block-level control
	flow within a function. You should be able to find information on
	this subject in any good compiler textbook.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-parser">
      <title>The <dlibrary>Compiler-Parser</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Parser</dlibrary> library handles
      lexical analysis, parsing and macro expansion. It relies only on the
      <dlibrary>Compiler-Base</dlibrary> library.</para>

      <sect2 id="gdmaint-d2c-parser-tokenize">
	<title>The <dmodule>Tokenize</dmodule> Module</title>
	<para></para>
      </sect2>
      
      <sect2 id="gdmaint-d2c-parser-source-utilities">
	<title>The <dmodule>Source-Utilities</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-lexer">
	<title>The <dmodule>Lexer</dmodule> Module</title>
	<para></para>
      </sect2>
      
      <sect2 id="gdmaint-d2c-parser-fragments">
	<title>The <dmodule>Fragments</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-parse-tree">
	<title>The <dmodule>Parse-Tree</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-parser">
	<title>The <dmodule>Parser</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-macros">
	<title>The <dmodule>Macros</dmodule> Module</title>
	<para></para>
      </sect2>      
    </sect1>

    <sect1 id="gdmaint-d2c-front">
      <title>The <dlibrary>Compiler-Front</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Front</dlibrary> library is repsonsible
      for processing the <glossterm>Front End Representation</glossterm> of
      a Dylan program. It depends only on the
      <dlibrary>Compiler-Base</dlibrary> library.</para>

      <para>Data is passed from the <dlibrary>Compiler-Parser</dlibrary>
      library to the <dlibrary>Compiler-Front</dlibrary> by the
      <dlibrary>Compiler-Convert</dlibrary> (see <xref
      linkend="gdmaint-d2c-convert">).</para>

      <sect2 id="gdmaint-d2c-front-builder-interface">
	<title>The <dmodule>Builder-Interface</dmodule> Module</title>
	<para></para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-primitives">
	<title>The <dmodule>Primitives</dmodule> Module</title>
	<para></para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-front">
	<title>The <dmodule>Front</dmodule> Module</title>
	<para></para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-fer-od">
	<title>The <dmodule>FER-OD</dmodule> Module</title>
	<para></para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-function-definitions">
	<title>The <dmodule>Function-Definitions</dmodule> Module</title>
	<para></para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-variable-definitions">
	<title>The <dmodule>Variable-Definitions</dmodule> Module</title>
	<para></para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-top-level-forms">
	<title>The <dmodule>Top-Level-Forms</dmodule> Module</title>
	<para></para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-convert">
      <title>The <dlibrary>Compiler-Convert</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Convert</dlibrary> library acts as an
      adaptor between the <dlibrary>Compiler-Parser</dlibrary> and the
      <dlibrary>Compiler-Front</dlibrary>.</para>

      <sect2 id="gdmaint-d2c-convert-lexenv">
	<title>The <dmodule>LexEnv</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-compile-time-eval">
	<title>The <dmodule>Compile-Time-Eval</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-expanders">
	<title>The <dmodule>Expanders</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-fer-convert">
	<title>The <dmodule>FER-Convert</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-macros">
	<title>The <dmodule>Define-Macros</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-libraries-and-modules">
	<title>The <dmodule>Define-Libraries-and-Modules</dmodule>
	Module</title>

	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-functions">
	<title>The <dmodule>Define-Functions</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-constants-and-variables">
	<title>The <dmodule>Define-Constants-and-Variables</dmodule>
	Module</title>

	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-classes">
	<title>The <dmodule>Define-Classes</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-top-level-expressions">
	<title>The <dmodule>Top-Level-Expressions</dmodule> Module</title>
	<para></para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-optimize">
      <title>The <dlibrary>Compiler-Optimize</dlibrary> Library</title>
      <para></para>

      <sect2 id="gdmaint-d2c-optimize-cheese">
	<title>The <dmodule>Cheese</dmodule> Module</title>
	<para></para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-cback">
      <title>The <dlibrary>Compiler-CBack</dlibrary> Library</title>
      <para></para>

      <sect2 id="gdmaint-d2c-cback-stack-analysis">
	<title>The <dmodule>Stack-Analysis</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-cback-cback">
	<title>The <dmodule>CBack</dmodule> Module</title>
	<para></para>
      </sect2>

      <sect2 id="gdmaint-d2c-cback-heap">
	<title>The <dmodule>Heap</dmodule> Module</title>
	<para></para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-main">
      <title>The <dlibrary>Compiler-Main</dlibrary> Library</title>
      <para></para>

      <sect2 id="gdmaint-d2c-main-main">
	<title>The <dmodule>Main</dmodule> Module</title>
	<para></para>
      </sect2>
    </sect1>

  </chapter>

  <CHAPTER id="gdmaint-melange-internals">
    <TITLE>Melange Internals Guide</TITLE>

    <PARA>FIXME: to be supplied later</PARA>
  </CHAPTER>

  <APPENDIX id="gdmaint-style">
    <TITLE>Gwydion Project Coding Style Guide</TITLE>

    <NOTE>
      <PARA>This appendix lists the Dylan language coding style
      guidelines formerly used by the Gwydion Project.</PARA>
    </NOTE>
    
    <PARA>This file lists two broad categories of style issues for
    Dylan.  One category, called "Recommended", contains style points
    to which Gwydion programmers should adhere, as opposed to "must
    adhere".  If someone sometimes, or even always, breaks a
    recommended style point, then others must to be tolerant of that
    deviation.  You must not modify the original author's code purely
    to satisfy an urge to convert the original author's style to your
    own.  The second category, called "Mandated", contains style
    points to which Gwydion programmers must adhere.  If you find
    someone has deviated from a mandated style point, then you may
    convert the code to be the mandated style.</PARA>

    <SECT1 id="gdmaint-style-recommended">
      <TITLE>Recommended</TITLE>

      <SECT2>
	<TITLE>Indent level</TITLE>

	<PARA> You should use a two-space indentation.  Each time code
	needs to be further indented, you should use one indent level,
	which is two spaces.</PARA>
      </SECT2>

      <SECT2>
	<TITLE>Indent wrapping slot descriptions</TITLE>

	<PARA>When a slot description wraps to a new line in a "define
        class" form, the extra lines should be indented one extra
        indent level.</PARA>
      </SECT2>
      
      <SECT2>
	<TITLE>Using <LITERAL>///</LITERAL> comments</TITLE>

	<PARA>If you use <LITERAL>///</LITERAL> comments, they should
        only be used between top-level declarations.
        <LITERAL>///</LITERAL> comments can be used for logical page
        headers, inter-function comments, code section introductions
        (logical page headers), etc., for example:</PARA>

	<PROGRAMLISTING>
...
end method;

/// order-espresso -- Method for Exported GF.
///
/// This method orders espresso at carts on the corner when it is
/// raining.  If it is not raining, this method delegates to
/// next-method. 
///
define method order-espresso (vendor :: &lt;outdoor-espresso-cart&gt;,
                              #next next-method)
  => ();
  ...
end method;</PROGRAMLISTING>
	
	<PARA>Many programmers do not like others to use
        <LITERAL>///</LITERAL> comments.  Rob noted that if these are
        only used between top-level declarations, where the
        <LITERAL>///</LITERAL> indicates a comment of wider scope (as
        over a whole definition or logical page), then the Gwydion
        environment should be able to display such comments however
        any particular user wants to see them.</PARA>
      </SECT2>
      <SECT2>
	<TITLE>Using <LITERAL>/* ... */</LITERAL></TITLE>
	
	<PARA>If you use <LITERAL>/* ... */</LITERAL> comments, they
        should only be used at the beginning of a file or the
        beginning of a logical page so that their use is highly
        localized.  This prevents them from showing up surprisingly in
        random places throughout a file of code.  Using
        <LITERAL>/*...*/</LITERAL> comments should go away once the
        Gwydion environment has a means for linking general commentary
        to logical units of code.  This issue has absolutely nothing
        to do with using <LITERAL>/*...*/</LITERAL> to temporarily
        exclude code fragments.</PARA>
      </SECT2>
      <SECT2>
	<TITLE>Wrapping function definition headers</TITLE>

	<PARA>When a function header wraps (that is, a <LITERAL>define
	generic</LITERAL> or a <LITERAL>define module</LITERAL>
	declaration), you should either break the line within the
	parameter list or between the name and the parameter list.  If
	you break the line between the name and parameter list, or
	perhaps after the parameter list, then you should indent any
	extra lines one extra indent level.  There is one exception:
	the first line of the return values specification may be
	indented only one space.  The following are examples of
	recommended style:</PARA>

	<PROGRAMLISTING>
define method some-longer-name-for-effect
    (one :: &lt;class-1&gt;, two :: &lt;class-2&gt;, ...)
    => (result1 :: &lt;type1&gt;, result2 :: &lt;type2&gt;);
  statement1;
  statement2;
  ...;
end method;

define method some-longer-name-for-effect
    (one :: &lt;class-1&gt;, two :: &lt;class-2&gt;, ...)
 => (result1 :: &lt;type1&gt;, result2 :: &lt;type2&gt;);
  statement1;
  statement2;
  ...;
end method;</PROGRAMLISTING>
      </SECT2>
      <SECT2>
	<TITLE>Indent keyword parameters beyond
	<LITERAL>#key</LITERAL> token</TITLE>

	<PARA> If there is more than one keyword parameter specified
	in a function declaration, then all keyword parameter
	specifications should line up with the first specification.
	The following is an example:</PARA>
	
	<PROGRAMLISTING>
define method foo (foo :: &lt;simple-object-vector&gt;,
                   #key start :: &lt;fixed-integer&gt; = 0,
		        stop :: &lt;fixed-integer&gt; = foo.size)
  ...</PROGRAMLISTING>
	
	<PARA>If a parameter list that contains a
        <LITERAL>#key</LITERAL> wraps, then you should wrap the
        parameter list before the <LITERAL>#key</LITERAL>
        token.</PARA>
      </SECT2>
      
      <SECT2>
	<TITLE>Wrapping variable and constant definitions</TITLE>
	
	<PARA>When a variable or constant definition wraps, you should
        break the line before the <LITERAL>=</LITERAL> token:</PARA>
	
	<PROGRAMLISTING>
define constant western-culture :: &lt;integer&gt;
  = north-america-mask | south-america-mask | europe-mask;</PROGRAMLISTING>
      </SECT2>
      
      <SECT2>
	<TITLE>Using <LITERAL>end <PARAMETER>mumble</PARAMETER></LITERAL>
        to terminate statements</TITLE>
	
	<PARA>You should use <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL>, rather than just
	<LITERAL>end</LITERAL>, whenever there is sufficient vertical
	space between the beginning and the end of the statement to
	hinder readability.  Some programmers like to use <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL> religiously, but those
	same programmers only use "end" when using <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL> would make a
	single-line statement wrap onto a new line.  Programmers may
	add the <LITERAL><PARAMETER>mumble</PARAMETER></LITERAL> to an
	<LITERAL>end</LITERAL> if they feel the code was hard to
	visually scan, but programmers should not add
	<LITERAL><PARAMETER>mumble</PARAMETER></LITERAL>s to all
	<LITERAL>end</LITERAL>s in someone else's code just because
	they like that style.  This policy is consistent with adding
	additional comments to someone else's code to help
	readability.</PARA>
      </SECT2>

      <SECT2>
	<TITLE>Horizontal space for columnization or other visual
	effects</TITLE>

	<PARA>You should NOT use horizontal spacing to columnize
	aspects of Dylan code, or to present other visual effects
	within the program.  If you do this, you should do it rarely.
	The one exception to this rule is the "Indent keyword
	parameters beyond #key token" recommendation.</PARA>
      </SECT2>

      <SECT2>
	<TITLE>Keyword syntax</TITLE>
	
	<PARA> You should only use keyword notation for symbols in
        function calls and function declarations.  You can also use
        keyword notation in slot descriptions within <LITERAL>define
        class</LITERAL>, where you are supplying a symbol to be the
        key for an initialization argument.  When a symbol is a value,
        such as a default value in a declaration or an argument value
        in a call, you should use symbol notation, not keyword
        notation.  The following are examples of recommended
        style:</PARA>

	<PROGRAMLISTING>
define method reposition (stream :: &lt;stream&gt;, offset :: &lt;integer&gt;,
                          #key from: = #"start")


define method foo ()
  ...
  bar(x, y, color: #"red");
  ...
end method;

// In this example, required-init-keyword: would always be in
// keyword notation, and "foo:" is the item to which this style
// recommendation speaks.
//
define class &lt;frob&gt;
  slot gag, required-init-keyword: foo:;
end;
//
// Or ...
//
define class &lt;frob&gt;
  slot gag, required-init-keyword: #"foo";
end;</PROGRAMLISTING>
      </SECT2>

      <SECT2>
	<TITLE>Blank comment line between introductory comments and
	definitions</TITLE>
	
	<PARA> You should include a blank comment line between the
        introductory comments for a function and the function
        definition.  This applies to any top-level declaration for
        which you supply an introductory comment.  The following is an
        example:</PARA>
	
	<PROGRAMLISTING>
// Blah blah blah GINGER blah blah blah.
//
define ...</PROGRAMLISTING>
      </SECT2>
      
      <SECT2>
	<TITLE>Wrapping <LITERAL>case</LITERAL> statements (applies to
	<LITERAL>select</LITERAL> too)</TITLE>
	
	<PARA>If any single branch of a <LITERAL>case</LITERAL>
        statement wraps, then you should wrap every branch.  In
        practice, there are common exceptions to this
        recommendation.</PARA>

	<PARA> When wrapping a case statement, you should wrap it
        after the <LITERAL>=></LITERAL> token.  There should be no
        exceptions to this recommendation.</PARA>

	<PARA>	The following exhibit the recommended style:</PARA>

	<PROGRAMLISTING>
case
  test1 => expression1;
  test2 => expression2;
end;

case
  test1 =>
    statement1;
    statement2;
  test2 =>
    statement1;
    statement2;
end;</PROGRAMLISTING>
      </SECT2>

      <SECT2>
	<TITLE>Using <LITERAL>#t</LITERAL> for
	<LITERAL>otherwise</LITERAL> in <LITERAL>case</LITERAL>
	statements</TITLE>
	
	<PARA> You should not use <LITERAL>#t</LITERAL> for
	<LITERAL>otherwise</LITERAL> in <LITERAL>case</LITERAL>
	statements.</PARA>
      </SECT2>
      
      <SECT2>
	<TITLE>Wrapping <LITERAL>for</LITERAL> clauses</TITLE>
	
	<PARA>When an <LITERAL>=</LITERAL>/<LITERAL>then</LITERAL>
        clause needs to wrap, you should wrap before the
        <LITERAL>=</LITERAL> and before the 'then'.  Both the '=' and
        the 'then' should be indented one extra indent level:</PARA>

	<PROGRAMLISTING>
// Correct.
//
... nested levels ...
                 for (some-index
			= initialization-expression(x, y, z)
			then stepper(u, v, w))
	           stuff(some-index);
		 end;

// Incorrect.
//
... nested levels ...
                 for (some-index = initialization-expression(x, y, z)
			then stepper(u, v, w))
		   stuff(some-index);
		 end;</PROGRAMLISTING>
      </SECT2>
    </SECT1>
    
    <SECT1 id="gdmaint-style-mandated">
      <TITLE>Mandated</TITLE>
      
      <SECT2>
	<TITLE>Function name and open paren</TITLE>
	
	<PARA> The <LITERAL>define generic</LITERAL> or
        <LITERAL>define method</LITERAL> declarations must have a
        space or newline between the name of the definition and the
        parameter list.  At any function call site, the name and open
        paren must be adjacent, with no intervening characters.</PARA>
      </SECT2>
      
      <SECT2>
	<TITLE>Wrapping <LITERAL>let</LITERAL> statements</TITLE>

	<PARA>If a <LITERAL>let</LITERAL> statement wraps, you must
	put the equal sign on a new line and indent it one extra
	indent level.</PARA>
      </SECT2>
      
      <SECT2>
	<TITLE>Terminate statements with semicolons</TITLE>

	<PARA>Semicolons are terminators and must appear wherever they
	are optional, except as covered by the "Single-line
	statements" mandate.</PARA>
      </SECT2>
      
      <SECT2>
	<TITLE>Single-line statements</TITLE>
	
	<PARA> Single-line statement, such as if-else, must not have
        any internal semicolons.  If a single-line statement requires
        an internal semicolon, then you must break the statement into
        multiple lines.  For example, the following would be illegal
        in Gwydion style:</PARA>
	<PROGRAMLISTING>
let x = if (some-test) foo(); 3; else 5; end;
let x = if (some-test) foo(); 3 else 5 end;
let f = method (a, b) foo(); #f; end;</PROGRAMLISTING>
	
	<PARA>These should be formatted as follows (ignoring the
	<LITERAL>end if</LITERAL> issue):</PARA>

	<PROGRAMLISTING>
let x = if (some-test)
   foo();
   3;
 else
   5;
 end;
let f = method (a, b)
   foo();
   #f;
 end;</PROGRAMLISTING>
	
	<PARA> Most programmers felt this rule, by its nature of
        eliminating multiple statements within a block on a single
        line, made code much more readable.</PARA>
      </SECT2>
      
      <SECT2>
	<TITLE>Wrapping arithmetic/boolean expressions</TITLE>
	
	<PARA> You must wrap long expressions before operators and
        indent the operators with one extra indent level from the
        beginning of the expression.  Note, assignments are considered
        to be "statements", and the "expression" that wraps is the
        code on the right-hand side of the assignment operator.
        Therefore, the first two examples below are considered to be
        approved style, but the third is not:</PARA>
	
	<PROGRAMLISTING>
my-local := big-computation(arg1, arg2)
       + another-hairy-long-calculation(arg3, arg4, arg5)
my-local := (big-computation(arg1, arg2)
        + another-hairy-long-calculation(arg3, arg4, arg5))
my-local := big-computation(arg1, arg2)
  + another-hairy-long-calculation(arg3, arg4, arg5)</PROGRAMLISTING>
      </SECT2>
    </SECT1>
  </APPENDIX>
</BOOK>
