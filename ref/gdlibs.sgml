<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.1//EN" [
 <!ENTITY % entities SYSTEM "entities.sgml">
 %entities;
]>
<BOOK id="gdlibs">
  <title>Gwydion Dylan Library Reference Guide</title>
  <titleabbrev>Library Reference Guide</titleabbrev>

  <bookinfo>
    <COPYRIGHT>
      <YEAR>1996</YEAR>
      <YEAR>1997</YEAR>
      <YEAR>1998</YEAR>
      <YEAR>1999</YEAR>
      <YEAR>2000</YEAR>
      <HOLDER>Carnegie Mellon University</HOLDER>
      <HOLDER>Gwydion Dylan Maintainers</HOLDER>
    </COPYRIGHT>
    &cmu.terms;
    <bookbiblio>
      <date>12 November 2000</date>
      <editor>&person.housel;</editor>
      <editor>&person.bogk;</editor>
      <editor>&person.neel;</editor>
      <editor>&person.auclair;</editor>
    </bookbiblio>
  </bookinfo>

  <CHAPTER ID="libs-introduction">
    <TITLE>Introduction</TITLE>

    <PARA>This manual serves as a guide to the libraries included with
    Gywdion &dylan;.  These libraries include:</PARA>

    <VARIABLELIST>
      <VARLISTENTRY>
	<TERM>Dylan</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Streams</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Standard-IO</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Format</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Format-Out</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Print</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Collection-Extensions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Table-Extensions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>String-Extensions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Regular-Expressions</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Transcendental</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Time</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Random</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>Matrix</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
      <VARLISTENTRY>
	<TERM>TK</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
    </VARIABLELIST>
    
  </CHAPTER>

  <CHAPTER ID="libs-dylan">
    <TITLE>The Dylan Library and Gwydion Dylan Extensions</TITLE>

    <SECT1 id="libs-dylan-introduction">
      <TITLE>Introduction</TITLE>
      
      <PARA>In the process of working with Dylan, the Gwydion Project
      has come up with numerous extensions to the Dylan language. Some
      of them form entire libraries, like the
      <DLIBRARY>Collection-Extensions</DLIBRARY> and
      <DLIBRARY>String-Extensions</DLIBRARY> libraries. Others have
      been added to the <DLIBRARY>Dylan</DLIBRARY> library, in such
      modules as <DMODULE>Extensions</DMODULE> and
      <DMODULE>System</DMODULE>.</PARA>
      
      <PARA>We continue to make no claims about future support for our
      extensions. However, some extensions are more likely than others
      to make it into our future compilers. This file documents those
      extensions which we think will be included in our compiler's
      <DLIBRARY>Dylan</DLIBRARY> library.</PARA>
      
      <PARA>Extensions which go in separate libraries are documented
      in their own files; extensions which are part of the Mindy
      <DLIBRARY>Dylan</DLIBRARY> library but which have a less certain
      future are documented in the Mindy documentation.</PARA>

      <PARA>For the remainder of this chapter, we shall refer to
      "Gwydion compilers" as a shorthand for "Mindy and other
      Dylan compilers that the Gwydion Project may write." It is
      not meant as a guarentee that all future Gwydion releases will
      support these extensions.</PARA>

      <PARA>Specific Gwydion compilers may support extensions not
      listed here; see their documentation for details.</PARA>
    </SECT1>

    <SECT1 id="libs-dylan-modules">
      <TITLE>Modules of the Dylan Library</TITLE>
      
      <PARA>In addition to containing the <DMODULE>Dylan</DMODULE>
      module, the <DLIBRARY>Dylan</DLIBRARY> library contains a
      variety of modules which provide extensions. Gwydion compilers
      export the following modules from the <DLIBRARY>Dylan</DLIBRARY>
      library:</PARA>

      <VARIABLELIST>
	<VARLISTENTRY>
	  <TERM><DMODULE>Extensions</DMODULE></TERM>
	  <LISTITEM>
	    <PARA>This module exports useful extensions to the Dylan
	    language (see <XREF LINKEND="libs-dylan-extensions">).
	    Ultimately, there will be several, more logically separate
	    libraries that extend Dylan or provide an application
	    framework for users. For now, we put any commonly used
	    utilities in the <DMODULE>Extensions</DMODULE>
	    module.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><DMODULE>System</DMODULE></TERM>
	  <LISTITEM>
	    <PARA>This module exports an interface to operating system
            calls and special, low-level functionality (see <XREF
            LINKEND="libs-dylan-system">).</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><dmodule>Introspection</dmodule></TERM>
	  <LISTITEM>
	    <PARA>This module exports reflective operations for
	    examining classes, functions, and so on.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM><dmodule>Cheap-io</dmodule></TERM>
	  <LISTITEM>
	    <PARA>This module exports some basic, unextendable input
	    and output functionality.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>
      </VARIABLELIST>
    </SECT1>

    <SECT1 id="libs-dylan-dylan">
      <TITLE>The Dylan Module</TITLE>

      <PARA>Whenever possible, we have tried to keep the
      <dmodule>Dylan</dmodule> module pristine and unextended,
      prefering to add our extensions to separate modules or
      libraries. However, this is not always possible, particularly
      when it involves extending the behavior of a function or macro
      that is exported from the <dmodule>Dylan</dmodule>
      module. Currently, Gwydion compilers support these extensions to
      the <dmodule>Dylan</dmodule> module as described below:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>Gwydion compilers support <dlit>keyed-by</dlit>
	  clauses in <dlit>for</dlit> statements.  The format of
	  such a clause is</PARA>

	  <SYNOPSIS><PARAMETER>var</PARAMETER> keyed-by <PARAMETER>key</PARAMETER> in <PARAMETER>collection</PARAMETER></SYNOPSIS>

	  <PARA>The <PARAMETER>var</PARAMETER> is bound to each
	  element in <PARAMETER>collection</PARAMETER>, and
	  <PARAMETER>key</PARAMETER> is bound to the element's key
	  value.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Gwydion compilers supports <dlit>using</dlit>
	  clauses in <dlit>for</dlit> statements.  The format of
	  such a clause is</PARA>

	  <SYNOPSIS><PARAMETER>var</PARAMETER> in <PARAMETER>collection</PARAMETER> using <PARAMETER>protocol</PARAMETER></SYNOPSIS>

	  <PARA>The <PARAMETER>protocol</PARAMETER> will be used
	  instead of
	  <dname>forward-iteration-protocol</dname>. The
	  <PARAMETER>protocol</PARAMETER> argument must be a variable
	  name, not an expression. These <dlit>using</dlit>
	  clauses may be used together with
	  <dlit>keyed-by</dlit>:</PARA>
	  
	  <SYNOPSIS><PARAMETER>var</PARAMETER> keyed-by <PARAMETER>key</PARAMETER> in <PARAMETER>collection</PARAMETER> using <PARAMETER>protocol</PARAMETER></SYNOPSIS>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Gwydion compilers have an additional type of top level
	  definition, <dlit>define function</dlit>, which
	  creates a constant binding in the current module and
	  initializes it to a new function. The usage of
	  <dlit>define function</dlit> usage is similar to that
	  of <dlit>define method</dlit>. The following is an
	  example:</PARA>

	  <PROGRAMLISTING>
define function cube (x)
  x * x * x;
end function cube;
</PROGRAMLISTING>

	  <PARA>A similar result might be had by writing</PARA>

	  <PROGRAMLISTING>
define constant cube = method (x)
                         x * x * x;
                       end method;
</PROGRAMLISTING>

	  <PARA>or</PARA>

	  <PROGRAMLISTING>
define method cube (x)
  x * x * x;
end method cube;
</PROGRAMLISTING>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Gwydion compilers supports subclass specializers via
	  the <FUNCTION>limited</FUNCTION> function.  A subclass
	  specializer causes a method to be invoked whenever the
	  generic function was called on a value that is the specified
	  class or any subclass of the specified class.  The method is
	  never invoked on a value that is an instance (direct or
	  indirect) of the specified class, only when the value is a
	  subclass of the specified class.  The following is an
	  example:</PARA>

	  <PROGRAMLISTING>
define method make
    (result-class :: limited(&lt;class&gt;, subclass-of: &lt;my-class&gt;));
  let x = next-method();
  do-special-logging-or-something(x);
  x;
end method;</PROGRAMLISTING>
	</LISTITEM>
      </ITEMIZEDLIST>
    </SECT1>

    <SECT1 ID=libs-dylan-extensions>
      <TITLE>The Extensions Module</TITLE>

      <PARA>Ultimately, there will be several, more logically separate
      libraries that extend Dylan or provide an application framework
      for users.  For now, we put any commonly used utilities in the
      Extensions module.</PARA>

      <SECT2>
	<TITLE>Generally Useful Definitions</TITLE>

	<PARA>The Extensions module exports the following generally
	useful functionality:</PARA>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;byte-vector&gt;</REFNAME>
	    <REFPURPOSE>Class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This class is a subclass of
	    <CLASSNAME>&lt;vector&gt;</CLASSNAME> that can only hold
	    integers between 0 and 255 inclusively.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;byte-character&gt;</REFNAME>
	    <REFPURPOSE>Class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>

	    <PARA><CLASSNAME>&lt;character&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>Characters of this type represent the ASCII
	    character set (or extensions to ASCII such as ISO
	    8859). Note, in Gwydion compilers the
	    <CLASSNAME>&lt;character&gt;</CLASSNAME> class is
	    equivalent to Unicode characters.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>assert</REFNAME>
	    <REFPURPOSE>function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>assert</FUNCTION> <PARAMETER>value</PARAMETER> =></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>value</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;object&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>

	    <PARA>None</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This function signals an error if
	    <PARAMETER>value</PARAMETER> is
	    <dlit>#f</dlit>. Otherwise, it does nothing. In
	    future Gwydion compilers, assert may be changed to a
	    macro, which may or may not evaluate its argument exactly
	    once.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>one-of</REFNAME>
	    <REFPURPOSE>Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>one-of</FUNCTION> #rest <PARAMETER>objects</PARAMETER> => <PARAMETER>type</PARAMETER></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>objects</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>Instances of <CLASSNAME>&lt;object&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>type</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of <CLASSNAME>&lt;type&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This function takes any number of objects, and
	    returns the type that is the type-union of the singletons
	    of those objects. For example, the expression</PARA>

	    <PROGRAMLISTING>
one-of(#"foo", #"bar", #"baz")</PROGRAMLISTING>

	    <PARA>is equivalent to</PARA>

	    <PROGRAMLISTING>
type-union(singleton(#"foo"), singleton(#"bar"), singleton(#"baz"))</PROGRAMLISTING>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>false-or</REFNAME>
	    <REFPURPOSE>Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>false-or</FUNCTION> <PARAMETER>type</PARAMETER> => <PARAMETER>bigger-type</PARAMETER></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>Type</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of <CLASSNAME>&lt;type&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>bigger-type</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of <CLASSNAME>&lt;type&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This function is useful in type expressions. It
	    captures the common idiom of returning an instance of a
	    particular type or the value #f. The expression</PARA>

	    <PROGRAMLISTING>
false-or(&lt;integer&gt;)</PROGRAMLISTING>

	    <PARA>is equivalent to the expression</PARA>

	    <PROGRAMLISTING>
type-union(&lt;integer&gt;, singleton(#f))</PROGRAMLISTING>
	  </REFSECT1>
	</REFENTRY>
      </SECT2>

      <SECT2>
	<TITLE>Debugger Customizations</TITLE>

	<PARA>(A note on terminology: We use the term "debugger" here
	in the loose, Dylan sense of anything that handles an uncaught
	error. In Mindy, this debugger is indeed a full fledged
	debugger, but in other Gwydion compilers it may not be.)</PARA>

	<PARA>The debugger uses the function
	<FUNCTION>report-condition</FUNCTION> to print conditions as error
	messages to users; for example, this is the function that
	implements the <dlit>%S</dlit> format-string directive
	for conditions. The debugger also uses the
	<FUNCTION>format</FUNCTION> function exported from the Cheap-io
	module to process format strings, and it prints directly to
	the Unix stdout. If any library that is used itself uses the
	Debugger-format library, then the debugger uses format from
	the Format library, which is shipped with Gwydion
	compilers. You can extend how the debugger prints conditions,
	change what formatting function it uses, and direct where
	debugger output goes with the following:</PARA>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>report-condition</REFNAME>
	    <REFPURPOSE>Generic Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>report-condition</FUNCTION> <PARAMETER>condition</PARAMETER> <PARAMETER>stream</PARAMETER> =></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>condition</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;condition&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><PARAMETER>stream</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;stream&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>

	    <PARA>None</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This is the function that is used to print condition
	    variables as error messages to users. The internal
	    <FUNCTION>format</FUNCTION> function used by Mindy uses
	    report-condition for condition arguments to the
	    <dlit>%S</dlit> format directive. The Format
	    library's <FUNCTION>print-message</FUNCTION> method for
	    conditions calls
	    <FUNCTION>report-condition</FUNCTION>.</PARA>

	    <PARA>If you are writing a module that does no output but
	    still provides report-condition methods, you should use
	    <FUNCTION>condition-format</FUNCTION> to format
	    output. Using <FUNCTION>condition-format</FUNCTION> makes
	    your module more flexible for users of your module. If you
	    call Cheap-IO's format, you'll be forced to write to only
	    one destination, <dlit>stdout</dlit>, ignoring the
	    <PARAMETER>stream</PARAMETER> argument. If you call the
	    Format library's <FUNCTION>format</FUNCTION> function,
	    then your module will require the Format, Print, and
	    Streams libraries; therefore, users of your module may
	    ultimately load these other libraries needlessly. Of
	    course, if you want to make use of the extended
	    functionality of the Format library's format control
	    strings, then you only have one choice anyway, and there's
	    no reason to use <FUNCTION>condition-format</FUNCTION>.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME></REFNAME>
	    <REFPURPOSE></REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>condition-format</FUNCTION> <PARAMETER>stream</PARAMETER> <PARAMETER>control-string</PARAMETER>#rest <PARAMETER>arguments</PARAMETER> =></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>stream</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;object&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><PARAMETER>control-string</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;string&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><PARAMETER>arguments</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>Instances of
		  <CLASSNAME>&lt;object&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>
	    <PARA>None</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This function serves as a firewall between the
	    condition system and the Streams and Format
	    libraries. Methods on
	    <FUNCTION>report-condition</FUNCTION> should use
	    <FUNCTION>condition-format</FUNCTION> to do their
	    formatting. Users will generally use
	    <dlit>*debug-output*</dlit> or
	    <dlit>*warning-output*</dlit> for the stream
	    argument, but this is not required.</PARA>

	    <PARA>Mindy supplies a method for when stream is
	    <dlit>#"Cheap-IO"</dlit>. The Gwydion Format library
	    supplies a method for when stream is a subclass of
	    <CLASSNAME>&lt;stream&gt;</CLASSNAME>. If you are
	    implementing your own streams or format libraries, you
	    will need to define a method on
	    <FUNCTION>condition-format</FUNCTION> for your type of
	    stream.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>condition-force-output</REFNAME>
	    <REFPURPOSE>Generic Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>condition-force-output</FUNCTION> <PARAMETER>stream</PARAMETER> =></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;object&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>

	    <PARA>None</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA><FUNCTION>Condition-force-output</FUNCTION> forces
	    any pending output from <PARAMETER>stream</PARAMETER>'s
	    buffer to <PARAMETER>stream</PARAMETER>'s
	    destination. This function is invoked by the debugger
	    after a condition has been reported and before it pauses
	    for user input. Unless you are writing a debugger, you do
	    not need to call
	    <FUNCTION>condition-force-output</FUNCTION>
	    yourself.</PARA>

	    <PARA>Mindy supplies a method for when stream is
	    <dlit>#"Cheap-IO"</dlit>. The Gwydion Format library
	    supplies a method for when stream is a subclass of
	    <CLASSNAME>&lt;stream&gt;</CLASSNAME>. If you are
	    implementing your own streams or format libraries, you
	    will need to define a method on
	    <FUNCTION>condition-force-output</FUNCTION> for your type
	    of stream.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>*warning-output*</REFNAME>
	    <REFPURPOSE>Variable</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>Default-handler for
	    <CLASSNAME>&lt;warning&gt;</CLASSNAME> uses
	    <dlit>*warning-output*</dlit> to print warning
	    messages. This variable must be either a
	    <CLASSNAME>&lt;stream&gt;</CLASSNAME> from the Streams
	    library, or <dlit>#"Cheap-IO"</dlit> (the
	    default). When this variable is
	    <dlit>#"Cheap-IO"</dlit>, the output goes to
	    <dlit>stderr</dlit>.</PARA>
	  </REFSECT1>
	</REFENTRY>
      </SECT2>

      <SECT2 ID="libs-dylan-exiting-applications">
	<TITLE>Exiting Applications</TITLE>

	<PARA>The Extensions module exports the following
	functionality for controlling the exiting of
	applications:</PARA>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>exit</REFNAME>
	    <REFPURPOSE>Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>exit</FUNCTION> #key <PARAMETER>exit-code</PARAMETER> =></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Keyword Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><dlit>exit-code:</dlit></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <dlit>&lt;integer&gt;</dlit>.  The default is
		  0.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>Causes the process to exit with return code
	    <PARAMETER>exit-code</PARAMETER>.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>on-exit</REFNAME>
	    <REFPURPOSE>Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>on-exit</FUNCTION> <PARAMETER>function</PARAMETER> => <PARAMETER>meaningless</PARAMETER></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM>function</TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;function&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM>meaningless</TERM>
		<LISTITEM>
		  <PARA>Always equal to <dlit>#f</dlit>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>Arranges for the <FUNCTION>exit</FUNCTION> function
	    to call the argument function.  The argument function must
	    take no required arguments.  Users may call
	    <FUNCTION>on-exit</FUNCTION> multiple times to install
	    more than one function for <FUNCTION>exit</FUNCTION> to
	    call, but the order in which exit invokes the functions is
	    undefined. Calling <FUNCTION>on-exit</FUNCTION> on the
	    same function repeatedly, installs that function multiple
	    times.</PARA>
	  </REFSECT1>
	</REFENTRY>
      </SECT2>
      <SECT2>
	<TITLE>Collections</TITLE>

	<PARA>The Extensions module exports the following
	<CLASSNAME>&lt;collection&gt;</CLASSNAME>
	functionality:</PARA>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>key-exists?</REFNAME>
	    <REFPURPOSE>Generic Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>key-exists?</FUNCTION> <PARAMETER>collection</PARAMETER> <PARAMETER>key</PARAMETER> => <PARAMETER>win?</PARAMETER> <PARAMETER>elt</PARAMETER></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>collection</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;collection&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><PARAMETER>key</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;object&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>win?</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;boolean&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><PARAMETER>elt</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;object&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>Return whether <PARAMETER>key</PARAMETER> is in
	    <PARAMETER>collection</PARAMETER>. If the
	    <PARAMETER>key</PARAMETER> is in the
	    <PARAMETER>collection</PARAMETER>, then the second value
	    is the element associated with <PARAMETER>key</PARAMETER>;
	    otherwise, the second return value is #f.</PARA>
	  </REFSECT1>
	</REFENTRY>
      </SECT2>
      <SECT2>
	<TITLE>Integers</TITLE>

	<PARA>Gwydion compilers have an abstract class
	<CLASSNAME>&lt;general-integer&gt;</CLASSNAME> which has two
	concrete subclasses, <CLASSNAME>&lt;integer&gt;</CLASSNAME>
	and <CLASSNAME>&lt;extended-integer&gt;</CLASSNAME>.
	<CLASSNAME>&lt;integer&gt;</CLASSNAME>s have a limited range
	of values, and <CLASSNAME>&lt;integer&gt;</CLASSNAME>
	arithmetic uses the computer's underlying integer
	facilities. <CLASSNAME>&lt;extended-integer&gt;</CLASSNAME>s
	can take on any value, and are similar to Common Lisp
	"bignums."  Expressions involving
	<CLASSNAME>&lt;extended-integer&gt;</CLASSNAME>s produce
	<CLASSNAME>&lt;extendedinteger&gt;</CLASSNAME> results because
	<CLASSNAME>&lt;extended-integer&gt;</CLASSNAME>s are
	contagious. If an expression involving only
	<CLASSNAME>&lt;integer&gt;</CLASSNAME> values would produce a
	result that does not fit in an
	<CLASSNAME>&lt;integer&gt;</CLASSNAME>, then the Gwydion
	compiler will signal an overflow error. You can use the
	<FUNCTION>as</FUNCTION> function to convert back and forth
	between <CLASSNAME>&lt;integer&gt;</CLASSNAME>s and
	<CLASSNAME>&lt;extended-integer&gt;</CLASSNAME>s. As signals
	an error when converting an
	<CLASSNAME>&lt;extended-integer&gt;</CLASSNAME> to a
	<CLASSNAME>&lt;integer&gt;</CLASSNAME>, and the value does not fit in a
	<CLASSNAME>&lt;integer&gt;</CLASSNAME>.</PARA>

	<PARA>The Extension module exports the following integer
	functionality:</PARA>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;general-integer&gt;</REFNAME>
	    <REFPURPOSE>Abstract Class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Superclass</TITLE>
	    <PARA><CLASSNAME>&lt;rational&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>
	    <PARA>The superclass of
	    <CLASSNAME>&lt;integer&gt;</CLASSNAME> and
	    <CLASSNAME>&lt;extended-integer&gt;</CLASSNAME>.</PARA>
	  </REFSECT1>
	</REFENTRY>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;extended-integer&gt;</REFNAME>
	    <REFPURPOSE>Class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;general-integer&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	</REFENTRY>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>$maximum-integer</REFNAME>
	    <REFPURPOSE>Constant</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Description</TITLE>
	    <PARA>Holds the largest positive
	    <CLASSNAME>&lt;integer&gt</CLASSNAME>.</PARA>
	  </REFSECT1>
	</REFENTRY>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>$minimum-integer</REFNAME>
	    <REFPURPOSE>Constant</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Description</TITLE>
	    <PARA>Holds the smallest negative
	    <CLASSNAME>&lt;integer&gt</CLASSNAME>.</PARA>
	  </REFSECT1>
	</REFENTRY>
      </SECT2>

      <SECT2>
	<TITLE>Ratios</TITLE>

	<PARA>The  Extensions module exports the following:</PARA>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;ratio&gt;</REFNAME>
	    <REFPURPOSE>Class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>

	    <PARA><CLASSNAME>&lt;rational&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>A ratio is normalized so that it has a positive
	    denominator, and the greatest common divisor of the
	    numerator and the denominator is one. Ratios are never
	    automatically converted to integers. For example,
	    <dlit>ratio(4, 2)</dlit> would return
	    <dlit>2/1</dlit>.</PARA>

	    <PARA>A numeric operation involving two ratios produces a
	    normalized ratio result. A numeric operation involving a
	    ratio and an integer produced a normalized ratio result. A
	    numeric operation involving a ratio and a float produces a
	    float result.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>ratio</REFNAME>
	    <REFPURPOSE>Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>ratio</FUNCTION> <PARAMETER>numerator</PARAMETER> <PARAMETER>denominator</PARAMETER> => <PARAMETER>ratio</PARAMETER></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>numerator</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;general-integer&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><PARAMETER>denominator</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;general-integer&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>ratio</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;ratio&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This function makes a ratio from the two integers.</PARA>
	  </REFSECT1>
	</REFENTRY>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>numerator</REFNAME>
	    <REFPURPOSE>Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>numerator</FUNCTION> <PARAMETER>ratio</PARAMETER> => <PARAMETER>the-numerator</PARAMETER></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>ratio</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;ratio&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>the-numerator</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;general-integer&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This function returns the numerator part of a ratio.</PARA>
	  </REFSECT1>
	</REFENTRY>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>denominator</REFNAME>
	    <REFPURPOSE>Function</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Signature</TITLE>

	    <SYNOPSIS><FUNCTION>denominator</FUNCTION> <PARAMETER>ratio</PARAMETER> => <PARAMETER>the-denominator</PARAMETER></SYNOPSIS>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Arguments</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>ratio</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;ratio&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Values</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><PARAMETER>the-denominator</PARAMETER></TERM>
		<LISTITEM>
		  <PARA>An instance of
		  <CLASSNAME>&lt;general-integer&gt;</CLASSNAME>.</PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>This function returns the denominator part of a ratio.</PARA>
	  </REFSECT1>
	</REFENTRY>

      </SECT2>
    </SECT1>

    <SECT1 ID="libs-dylan-system">
      <TITLE>The System Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1 ID="libs-dylan-introspection">
      <TITLE>The Introspection Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1 id="libs-dylan-cheap-io">
      <TITLE>The Cheap-IO Module</TITLE>

      <PARA></PARA>

    </SECT1>
  </CHAPTER>

  <CHAPTER ID="libs-streams">
    <DOCINFO>
      <TITLE>The Streams Library</TITLE>
      <DATE>06 Feb 1997</DATE>
      <EDITOR>
	<FIRSTNAME>Andrew</FIRSTNAME><SURNAME>Shires</SURNAME>
      </EDITOR>
      <AUTHORGROUP>
	<AUTHOR>
	  <FIRSTNAME>Scott</FIRSTNAME><SURNAME>McKay</SURNAME>
	  <AFFILIATION>
	    <ORGNAME>Harlequin, Inc.</ORGNAME>
	  </AFFILIATION>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Bill</FIRSTNAME><SURNAME>Chiles</SURNAME>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Marc</FIRSTNAME><SURNAME>Ferguson</SURNAME>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Eliot</FIRSTNAME><SURNAME>Miranda</SURNAME>
	</AUTHOR>
      </AUTHORGROUP>
    </DOCINFO>
    <TITLE>The Streams Library</TITLE>

    <AUTHORBLURB>
      <FORMALPARA>
	<TITLE>Acknowlegements</TITLE>
	<PARA>We'd like to thank the other people who
	have been instrumental in the production of this proposal:
	Jonathan Bachrach, Dave Berry, John Dunning, Chris Fry, Paul
	Haahr, William Lott, Rob Maclachlan, Tim McNerney, Tony Mann,
	Keith Playford, Robert Stockton, and Tucker Withington.</PARA>
      </FORMALPARA>
    </AUTHORBLURB>

    <SECT1 id="streams-error-conventions">
      <TITLE>Discussing error conditions</TITLE>

      <PARA>This document uses two special terms in discussions of
      error conditions.</PARA>

      <PARA>When we say that something is an error, we mean that the
      result is undefined. In particular, we do not mean that a
      Streams implementation must signal an error condition; that is
      the implementor's choice. So, for instance, the following text,
      from page FIXME, means only that the result of using unread-element
      in the case described is undefined:</PARA>

      <PARA>It is an error to apply
      <FUNCTION>unread-element</FUNCTION> to an element that is not
      the element most recently read from the stream.</PARA>

      <PARA>Only when we specifically mention signaling do we mean
      that a Streams implementation must signal an error
      condition. Note that we may not, in such a case, say exactly
      which error condition must be signaled; if we do not say so, the
      choice is again up to the implementor. In this text from the
      description of stream-position-setter on page FIXME, for instance,
      we state that an implementation must signal an error, but we do
      not say what error must be signaled:</PARA>

      <PARA>When position is a
      <CLASSNAME>&lt;stream-position&gt;</CLASSNAME>, if it is invalid
      for some reason, this function signals an error.</PARA>

      <PARA>By contrast, the following text from the description of
      <FUNCTION>read-element</FUNCTION> on page FIXME says exactly
      which error must be signaled:</PARA>

      <PARA>If the end of the stream is encountered and no value was
      supplied for on-end-of-stream, read-element signals an
      <CLASSNAME>&lt;end-of-stream-error&gt;</CLASSNAME>
      condition. </PARA>
    </SECT1>

    <SECT1 id="streams-goals">
      <TITLE>Goals of the Library</TITLE>

      <PARA>The Dylan Streams library aims to provide:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>A generic, easy-to-use interface for streaming over
	  sequences and files. The same high-level interface for
	  consuming or producing is available irrespective of the type
	  of stream, or the types of the elements being streamed
	  over.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Efficiency, especially for the common case of file
	  I/O.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Access to an underlying buffer management protocol.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An extensible framework. Other areas of functionality
	  that require a stream interface should be easy to integrate
	  with the library.</PARA>
	</LISTITEM>
      </ITEMIZEDLIST>

      <PARA>The proposal presents the design of a Streams library that
      meets these goals using Dylan's built-in sequences and a
      buffered disk file interface. </PARA>

      <PARA>The proposal does not address a number of related issues,
      including:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>A standard object-printing package such as Smalltalk's
	  <dlit>printOn:</dlit> or Lisp's
	  <dlit>print-object</dlit>, or a formatted printing
	  facility such as Lisp's
	  <dlit>format</dlit>. Additional libraries are expected
	  to provide these facilities.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>General object dumping and loading.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>A comprehensive range of I/O facilities for using
	  memory-mapped files, network connections, and so on. Such
	  facilities should be easy to add to the Streams library
	  because of its extensible framework.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An interface for naming files.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An interface to operating system functionality, such
	  as file renaming or deleting operations.  </PARA>
	</LISTITEM>
      </ITEMIZEDLIST>
    </SECT1>

    <SECT1 id="streams-concepts">
      <TITLE>Concepts</TITLE>

      <PARA>A stream provides sequential access to an aggregate of
      data, such as a Dylan sequence or a disk file. Streams grant
      this access according to a metaphor of reading and writing:
      elements can be read from streams or written to them.</PARA>

      <PARA>Streams are represented as Dylan objects, and all are
      general instances of the class
      <CLASSNAME>&lt;stream&gt;</CLASSNAME>, which the Streams library
      defines.</PARA>

      <PARA>We say that a stream is established over the data
      aggregate. Hence, a stream providing access to the string
      <dlit>"hello world"</dlit> is said to be a stream over the
      string <dlit>"hello world"</dlit>.</PARA>

      <PARA>Streams permitting reading operations are called input
      streams. Input streams allow elements from the underlying data
      aggregate to be consumed. Conversely, streams permitting writing
      operations are called output streams. Output streams allow
      elements to be written to the underlying data aggregate. Streams
      permitting both kinds of operations are called input-output
      streams. </PARA>

      <PARA>The library provides a set of functions for reading
      elements from an input stream. These functions hide the details
      of indexing, buffering, and so on. For instance, the function
      read-element reads a single data element from an input
      stream. </PARA>

      <PARA>The following expression binds stream to an input stream
      over the string <dlit>"hello world"</dlit>: </PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, contents: "hello world");</PROGRAMLISTING>

      <PARA>The first invocation of read-element on stream returns the
      character 'h', the next invocation 'e', and so on. Once a stream
      has been used to consume all the elements of the data, the
      stream is said to be at its end. This condition can be tested
      with the function <FUNCTION>stream-at-end?</FUNCTION>. The
      following code fragment applies function to all elements of the
      sequence:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;sequence-stream&gt;, contents: seq);
while (~stream-at-end?(stream)) 
	function(read-element(stream));
end;</PROGRAMLISTING>

      <PARA>When all elements of a stream have been read, further
      calls to <FUNCTION>read-element</FUNCTION> result in the
      <CLASSNAME>&lt;end-of-stream-error&gt;</CLASSNAME> condition
      being signalled. An alternative end-of-stream behavior is to
      have a distinguished end-of-stream value returned. You can
      supply such an end-of-stream value as a keyword argument to the
      various read functions; the value can be any object. Supplying
      an end-of-stream value to a read function is more efficient than
      asking whether a stream is at its end on every iteration of a
      loop. </PARA>

      <PARA>The library also provides a set of functions for writing
      data elements to an output stream. Like the functions that
      operate upon input streams, these functions hide the details of
      indexing, growing an underlying sequence, buffering for a file,
      and so on. For instance, the function
      <FUNCTION>write-element</FUNCTION> writes a single data element
      to an output stream. </PARA>

      <PARA>The following forms bind stream to an output stream over
      an empty string and create the string <dlit>"I
      see!"</dlit>, using the function
      <FUNCTION>stream-contents</FUNCTION> to access all of the
      stream's elements.</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;byte-string-stream&gt;, direction: #"output");
write-element(stream, 'I');
write-element(stream, ' ');
write(stream, "see");
write-element(stream, '!');
stream-contents(stream);</PROGRAMLISTING>

      <PARA>Calling <FUNCTION>write</FUNCTION> on a sequence has the
      same effect as calling <FUNCTION>write-element</FUNCTION> on all
      the elements of the sequence. However, it is not required that
      <FUNCTION>write</FUNCTION> be implemented directly in terms of
      <FUNCTION>write-element</FUNCTION>; it might be implemented more
      efficiently, especially for buffered streams.</PARA>

      <PARA>Some streams are positionable; that is, they permit random
      access to their elements. Postionable streams allow you to set
      the position at which the stream will be accessed by the next
      operation. The following example uses positioning to return the
      character <dlit>'w'</dlit> from a stream over the string
      <dlit>"hello world"</dlit>:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, contents: "hello world");
stream-position(stream) := 6;
read-element(stream);</PROGRAMLISTING>
      
      <PARA>The following example returns a string, but the contents
      of the first ten characters are undefined:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, direction: #"output");
adjust-stream-position(stream, 10); 
write(stream, "whoa!");
stream-contents(stream);</PROGRAMLISTING>
      
      <PARA>You can request a sequence containing all of the elements
      of a positionable stream by calling
      <FUNCTION>stream-contents</FUNCTION> on it. The sequence
      returned never shares structure with any underlying sequence
      that might be used in future by the stream. For instance, the
      string returned by calling <FUNCTION>stream-contents</FUNCTION>
      on an output <CLASSNAME>&lt;string-stream&gt;</CLASSNAME> will
      not be the same string as that being used to represent the
      string stream.</PARA>

      <PARA>When making an input &lt;string-stream&gt;, you can cause
      the stream to produce elements from any subsequence of the
      supplied string. For example:</PARA>

      <PROGRAMLISTING>
read-to-end(make(&lt;string-stream&gt;, 
                 contents: "hello there, world",
                 start: 6, 
                 end: 11));</PROGRAMLISTING>

      <PARA>This example evaluates to "there". The interval (start,
      end) includes the index start but excludes the index end. This
      is consistent with standard Dylan functions over sequences, such
      as copy-sequence. The read-to-end function is one of a number of
      convenient utility functions for operating on streams and
      returns all the elements up to the end of the stream from the
      stream's current position.</PARA>
    </SECT1>

    <SECT1 id="streams-growing-sequences">
      <TITLE>Streams, growing sequences, and object identity</TITLE>

      <PARA>When writing to output streams over sequences, Dylan may
      from time to time need to grow the underlying sequence that it
      is using to represent the stream data. </PARA>

      <PARA>Consider the example of an output stream instantiated over
      an empty string. As soon as a write operation is performed on
      the stream, it is necessary to replace the string object used in
      the representation of the string stream. As well as incurring
      the cost of creating a new string, the replacement operation can
      affect the integrity of other references to the string within
      the program. </PARA>

      <PARA>To guarantee that alias references to a sequence used in
      an output <CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME> will
      have access to any elements written to the sequence via the
      stream, supply a <CLASSNAME>&lt;stretchy-vector&gt;</CLASSNAME>
      to make. A stream over a stretchy vector will use the same
      stretchy vector throughout the stream's existence. </PARA>

      <PARA>For example:</PARA>

      <PROGRAMLISTING>
let sv = make(&lt;stretchy-vector&gt;);
let stream = make(&lt;sequence-stream&gt;, 
                  contents: sv, 
                  direction: #"output");
write(stream, #(1, 2, 3, 4, 5, 6, 7, 8, 9));
write(stream, "ABCDEF");
values(sv, stream-contents(stream));</PROGRAMLISTING>

      <PARA>The example returns two values. Each value is the same
      (<dlit>\==</dlit>) stretchy vector:</PARA>

      <PROGRAMLISTING>
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F']</PROGRAMLISTING>

      <PARA>If a stretchy vector is not supplied, the result is
      different: </PARA>

      <PROGRAMLISTING>
let v = make(&lt;vector&gt;, size: 5);
let stream = make(&lt;sequence-stream&gt;,
                  contents: v, 
                  direction: #"output");
write(stream, #(1, 2, 3, 4, 5, 6, 7, 8, 9));
write(stream, "ABCDEF");
values(v, stream-contents(stream));</PROGRAMLISTING>

      <PARA>This example returns as its first value the original
      vector, whose contents are undefined, but the second value is a
      new vector:</PARA>

      <PROGRAMLISTING>
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F']</PROGRAMLISTING>

      <PARA>This difference arises because the output stream in the
      second example does not use a stretchy vector to hold the stream
      data. A vector of at least 15 elements is necessary to
      accommodate the elements written to the stream, but the vector
      supplied, <dlit>v</dlit>, can hold only 5. Since the
      stream cannot change <dlit>v</dlit>'s size, it must
      allocate a new vector each time it grows. </PARA>
    </SECT1>

    <SECT1 id="streams-stream-classes">
      <TITLE>Stream classes</TITLE>

      <PARA>The exported streams class heterarchy is as follows:</PARA>

      <FIGURE>
	<TITLE>Streams library classes. </TITLE>
	<GRAPHIC></GRAPHIC>
      </FIGURE>

      <PARA>Except for the classes
      <CLASSNAME>&lt;stream&gt;</CLASSNAME>,
      <CLASSNAME>&lt;buffered-stream&gt;</CLASSNAME>, and
      <CLASSNAME>&lt;positionable-stream&gt;</CLASSNAME>, these are
      instantiable classes.</PARA>

      <SECT2>
	<TITLE>Class Reference</TITLE>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The superclass of all stream classes and a direct
	  subclass of <CLASSNAME>&lt;object&gt;</CLASSNAME>. It is not
	  instantiable.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;positionable-stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>A subclass of &lt;stream&gt; supporting the
	    Positionable Stream Protocol. It is not
	    instantiable.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;buffered-stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>A subclass of <CLASSNAME>&lt;stream&gt;</CLASSNAME>
	    supporting the Stream Extension Protocol and the Buffer
	    Access Protocol. It is not instantiable.</PARA>

	    <PARA>Streams of this class support the
	    <dlit>buffer-size:</dlit> init-keyword, which can be
	    used to suggest the size of the stream's buffer. However,
	    the instantiated stream might not use this value: it is
	    taken purely as a suggested value. For example, a stream
	    that uses a specific device's hardware buffer might use a
	    fixed buffer size regardless of the value passed with the
	    <dlit>buffer-size:</dlit> init-keyword. </PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;file-stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over disk files.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>

	    <PARA><CLASSNAME>&lt;positionable-stream&gt;</CLASSNAME>,
	  <CLASSNAME>&lt;buffered-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><dlit>locator:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>direction:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>if-exists:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>if-does-not-exist:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>When you instantiate this class, an
	    implementation-dependent, indirect instance of it is
	    created. The file being streamed over is opened
	    immediately upon creating the stream. </PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;sequence-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over sequences. </PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;positionable-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><dlit>contents:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>direction:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>start:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>end:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>The <CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME>
	    class can be used for streaming over all sequences, but
	    there are also subclasses
	    <CLASSNAME>&lt;string-stream&gt;</CLASSNAME>,
	    <CLASSNAME>&lt;byte-string-stream&gt;</CLASSNAME>, and
	    <CLASSNAME>&lt;unicode-string-stream&gt;</CLASSNAME>,
	    which are specialized for streaming over strings.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;string-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over strings.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><dlit>contents:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>direction:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>start:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>end:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>

	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;byte-string-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over byte strings.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;string-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><dlit>contents:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>direction:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>start:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>end:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>

	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;unicode-string-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over Unicode strings.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;string-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><dlit>contents:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>direction:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>start:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><dlit>end:</dlit></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	</REFENTRY>
      </SECT2>
      
      <SECT2>
	<TITLE>Creating streams</TITLE>

	<PARA>The following functions are used to create streams.</PARA>

	<SECT3>
	  <TITLE>File streams </TITLE>

	  <PARA>File streams are intended only for accessing the
	  contents of files. They are not intended to provide a
	  general file handling facility of renaming, deleting,
	  moving, parsing directory names and so on.</PARA>

	  <REFENTRY>
	    <REFNAMEDIV>
	      <REFNAME>make
	      <REPLACEABLE>file-stream-class</REPLACEABLE></REFNAME>
	      <REFPURPOSE>General function method</REFPURPOSE>
	    </REFNAMEDIV>
	    <REFSECT1>
	      <TITLE>Summary</TITLE>

	      <PARA>Creates and opens a stream over a file.</PARA>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Signature</TITLE>

	      <SYNOPSIS><FUNCTION>make</FUNCTION> file-stream-class <dlit>#key</dlit> <PARAMETER>locator</PARAMETER> <PARAMETER>direction</PARAMETER> <PARAMETER>if-exists</PARAMETER> <PARAMETER>if-does-not-exist</PARAMETER> <PARAMETER>buffer-size</PARAMETER> <PARAMETER>element-type</PARAMETER> <PARAMETER>encoding</PARAMETER> 
=&gt; <PARAMETER>file-stream-instance</PARAMETER> 
</SYNOPSIS>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Description</TITLE>

	      <PARA>Returns a new instance of a concrete subclass of
	      <CLASSNAME>&lt;file-stream&gt;</CLASSNAME> that streams
	      over the contents of the file referenced by locator. To
	      determine the concrete subclass to be instantiated, this
	      method calls the generic function
	      <FUNCTION>type-for-file-stream</FUNCTION> (see FIXME).</PARA>

	      <PARA>The <REPLACEABLE>file-stream-class</REPLACEABLE>
	      argument is the class
	      <CLASSNAME>&lt;file-stream&gt;</CLASSNAME>.</PARA>

	      <PARA>The <dlit>locator:</dlit> init-keyword
	      should be a string naming a file. If the Locators
	      library is in use, locator should be an instance of
	      <CLASSNAME>&lt;locator&gt;</CLASSNAME> or a string that
	      can be coerced to one.</PARA>

	      <PARA>The <dlit>direction:</dlit> init-keyword
	      specifies the direction of the stream.</PARA>

	      <PARA>The <dlit>if-exists:</dlit> and
	      <dlit>if-does-not-exist:</dlit> init-keywords
	      specify actions to take if the file named by locator
	      does or does not already exist when the stream is
	      created. These init-keywords are discussed in more
	      detail in FIXME.</PARA>

	      <PARA>The <dlit>buffer-size:</dlit> init-keyword
	      is explained in &lt;buffered-stream&gt; FIXME.</PARA>

	      <PARA>The <dlit>element-type</dlit> init-keyword
	      specifies the type of the elements in the file named by
	      locator. This allows file elements to be represented
	      abstractly; for instance, contiguous elements could be
	      treated as a single database record. This init-keyword
	      defaults to something useful, potentially based on the
	      properties of the file;
	      <CLASSNAME>&lt;byte-character&gt;</CLASSNAME> and
	      <CLASSNAME>&lt;unicode-character&gt;</CLASSNAME> are
	      likely choices. See FIXME.</PARA>
	    </REFSECT1>
	  </REFENTRY>

	  <REFENTRY>
	    <REFNAMEDIV>
	      <REFNAME>type-for-file-stream</REFNAME>
	      <REFPURPOSE>Open generic function</REFPURPOSE>
	    </REFNAMEDIV>
	    <REFSECT1>
	      <TITLE>Summary</TITLE>

	      <PARA>Returns the kind of file-stream class to
	      instantiate for a given file.</PARA>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Signature</TITLE>

	      <SYNOPSIS><FUNCTION>type-for-file-stream</FUNCTION>
	      <PARAMETER>locator</PARAMETER>
	      <PARAMETER>element-type</PARAMETER>
	      <dlit>#rest</dlit> <PARAMETER>all-keys</PARAMETER>
	      =&gt; <PARAMETER>file-stream-type</PARAMETER></SYNOPSIS>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Description</TITLE>

	      <PARA>The method for make on
	      <CLASSNAME>&lt;file-stream&gt;</CLASSNAME> calls this
	      function to determine the class of which it should
	      create an instance.</PARA>
	    </REFSECT1>
	  </REFENTRY>
	</SECT3>

	<SECT3>
	  <TITLE>Options when creating file streams</TITLE>

	  <PARA>When creating file streams, you can can supply the
	  following init-keywords to <FUNCTION>make</FUNCTION> in
	  addition to the usual direction: </PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><dlit>if-exists:</dlit></TERM>
	      <LISTITEM>
		<PARA>An action to take if the file already exists.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>if-does-not-exist:</dlit></TERM>
	      <LISTITEM>
		<PARA>An action to take if the file does not already
		exist.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>

	    <VARLISTENTRY>
	      <TERM><dlit>element-type:</dlit></TERM>
	      <LISTITEM>
		<PARA>How the elements of the underlying file are
		accessed.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <PARA>The <dlit>if-exists:</dlit> init-keyword allows
	  you to specify an action to take if the file named by
	  <PARAMETER>locator</PARAMETER> already exists. The options
	  are:</PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><dlit>#f</dlit></TERM>
	      <LISTITEM>
		<PARA>No action. This is the default when the stream's
		direction is <dlit>#"input"</dlit> or
		<dlit>#"input-output"</dlit>.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"new-version"</dlit></TERM>
	      <LISTITEM>
		<PARA>If the underlying file system supports file
		versioning, a new version of the file is created. This
		is the default when the stream's direction is
		<dlit>#"output"</dlit>.</PARA>

		<PARA>If the file system does not support file
		versioning, the implementation should substitute one
		of the other <dlit>if-exists:</dlit> behaviors;
		the <dlit>#"replace"</dlit> behavior is a good
		choice. </PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"overwrite"</dlit></TERM>
	      <LISTITEM>
		<PARA>Set the stream's position to the beginning of
		the file, but preserve the current contents of the
		file. This is useful when the direction is
		<dlit>#"input-output"</dlit> and you want to
		overwrite an existing file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"replace"</dlit></TERM>
	      <LISTITEM>
		<PARA>Delete or rename the existing file and create a
		new file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"append"</dlit></TERM>
	      <LISTITEM>
		<PARA>Set the stream's initial position to the end of
		the existing file so that all new output occurs at the
		end of the file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"truncate"</dlit></TERM>
	      <LISTITEM>
		<PARA>If the file exists, it is truncated, setting the
		size of the file to 0. If the file does not exist,
		create a new file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"signal"</dlit></TERM>
	      <LISTITEM>
		<PARA>Signal a
		<CLASSNAME>&lt;file-exists-error&gt;</CLASSNAME>
		condition. </PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <PARA>The <dlit>if-does-not-exist:</dlit> init-keyword
	  allows you to specify an action to take if the file named by
	  <PARAMETER>locator</PARAMETER> does not exist. The options
	  are:</PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><dlit>#f</dlit></TERM>
	      <LISTITEM>
		<PARA>No action.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"signal"</dlit></TERM>
	      <LISTITEM>
		<PARA>Signal a
		<CLASSNAME>&lt;file-does-not-exist-error&gt;</CLASSNAME>
		condition. This is the default when the stream's
		direction is <dlit>#"input"</dlit>.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><dlit>#"create"</dlit></TERM>
	      <LISTITEM>
		<PARA>Create a new zero-length file. This is the
		default when the stream's direction is
		<dlit>#"output"</dlit> or
		<dlit>#"input-output"</dlit>.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <PARA>Because creating a file stream always involves an
	  attempt to open the underlying file, the aforementioned
	  error conditions will occur during file stream instance
	  initialization.</PARA>

	  <PARA>If an implementation checks file permissions when
	  creating and opening file streams, and it detects an attempt
	  to read a file for which the user has no read permission, or
	  to write a file for which the user has no write permission,
	  then an
	  <CLASSNAME>&lt;invalid-file-permissions-error&gt;</CLASSNAME>
	  condition is signalled at the time the file stream is
	  created.</PARA>

	  <PARA>The <dlit>element-type:</dlit> init-keyword
	  controls how the elements of the underlying file are
	  accessed. </PARA>

	  <NOTE>
	    <TITLE>Implementation Note</TITLE>

	    <PARA>Ideally, element-type could be any valid Dylan type
	    such as <dlit>limited(&lt;integer&gt;, min: 0, max:
	    255)</dlit> or
	    <CLASSNAME>&lt;unicode-character&gt;</CLASSNAME>. This
	    approach may make it possible to implement a potentially
	    inefficient but general set of file streams. Unfortunately
	    the current language definition does not include adequate
	    support for this approach, so we specify instead an
	    interim minimum set of three element types. The element
	    types are for the time being exported from the streams
	    module of the Streams library.</PARA>
	  </NOTE>

	  <PARA>The three possible element types are: </PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><CLASSNAME>&lt;byte-character&gt;</CLASSNAME></TERM>
	      <LISTITEM>
		<PARA>The file is accessed as a sequence of 8-bit
		  characters.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><CLASSNAME>&lt;unicode-character&gt;</CLASSNAME></TERM>
	      <LISTITEM>
		<PARA>The file is accessed as a sequence of 16-bit Unicode
		  characters.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><CLASSNAME>&lt;byte&gt;</CLASSNAME></TERM>
	      <LISTITEM>
		<PARA>The file is accessed as a sequence of unsigned 8-bit
		  integers.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <NOTE>
	    <TITLE>Portability Note</TITLE>

	    <PARA>Portable code can count on the existence of these
	    three element types, but implementations are free to
	    provide more. </PARA>
	  </NOTE>
	</SECT3>
	<SECT3>
	  <TITLE>Sequence streams</TITLE>

	  <PARA>There are make methods on
	  <CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME>,
	  <CLASSNAME>&lt;string-stream&gt;</CLASSNAME>,
	  <CLASSNAME>&lt;byte-string-stream&gt;</CLASSNAME> and
	  <CLASSNAME>&lt;unicode-string-stream&gt;</CLASSNAME>. The
	  <FUNCTION>make</FUNCTION> methods on
	  <CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME> and
	  <CLASSNAME>&lt;string-stream&gt;</CLASSNAME> might not
	  create direct instances of those classes, but instead an
	  instance of a subclass determined by
	  <FUNCTION>type-for-sequence-stream</FUNCTION>.</PARA>
	</SECT3>
      </SECT2>
    </SECT1>
  </CHAPTER>

  <chapter id="libs-standard-io">
    <title> The Standard-IO Library </title>
     <sect1 id="libs-standard-io-standard-io">
      <title> The Standard-IO Library </title>
      <para>
        The <dmodule> standard-IO </dmodule> module of the
        <dlibrary> standard-IO </dlibrary> library exports
        three names for the standard input, output, and error
        streams.
      </para>
  
      <dylanconstantdef>
        <defname> *standard-error* </defname>
        <defsummary>
          The <classname>&lt;stream&gt;</classname> instance corresponding
          to the standard error.
        </defsummary>
        <deftype>
          &lt;stream&gt;
        </deftype>
        <defdescription>
          <para>
            The standard error <classname>&lt;stream&gt;</classname>.
            This usually represents the terminal; however most UNIX-like
            operating systems permit the standard error stream to be
            redirected at the command line.
          </para>
        </defdescription>
      </dylanconstantdef>
  
      <dylanconstantdef>
        <defname> *standard-input* </defname>
        <defsummary>
          The <classname>&lt;stream&gt;</classname> instance corresponding
          to the standard input.
        </defsummary>
        <deftype>
          &lt;stream&gt;
        </deftype>
        <defdescription>
          <para>
            The standard input <classname>&lt;stream&gt;</classname>.
            Usually, this stream reads from the terminal for its data;
            however most UNIX-like operating systems permit the standard
            input stream to be redirected at the command line.
          </para>
        </defdescription>
      </dylanconstantdef>
  
      <dylanconstantdef>
        <defname> *standard-output* </defname>
        <defsummary>
          The <classname>&lt;stream&gt;</classname> instance corresponding
          to the standard output.
        </defsummary>
        <deftype>
          &lt;stream&gt;
        </deftype>
        <defdescription>
          <para>
            The standard output <classname>&lt;stream&gt;</classname>.
            This usually represents the terminal (just like <dname>
            *standard-error* </dname>); however most UNIX-like operating
            systems permit the standard output stream to be redirected
            at the command line.
          </para>
        </defdescription>
      </dylanconstantdef>
    </sect1>
  </chapter>

  <chapter id="libs-format">
    <title> The Format Library </title>
    <sect1 id="libs-format-format">
      <title> The Format Module </title>
  
      <dylangenericdef>
        <defname> format </defname>
        <defsummary> Format a string and write it to a stream.  </defsummary>
        <defparameters>
          <param>
            <paramname> stream </paramname>
            <paramtype> &lt;stream&gt; </paramtype>
          </param>
          <param>
            <paramname> control-string </paramname>
            <paramtype> &lt;string&gt; </paramtype>
          </param>
          <restparam>
            <paramname> args </paramname>
            <paramsummary>
              The objects to substitute for the format fields.
            </paramsummary>
          </restparam>
        </defparameters>
        <defreturns>
        </defreturns>
        <defdescription>
          <para>
            The <function>format</function> function takes a control string,
            formats according to the format directives embedded in the string,
            and then writes the result to the <dname>stream</dname> argument.
          </para>
          <para>
            The format codes accepted by <function>format</function> are
            described on page XXX in Chapter 7 of the Dylan Reference
            Manual, in the section "Condition Messages."
          </para>
        </defdescription>
      </dylangenericdef>
      
      <dylanmethoddef>
        <defname> format </defname>
        <defsummary> Format a string and write it to a stream.  </defsummary>
        <defparameters>
          <param>
            <paramname> stream </paramname>
            <paramtype> &lt;stream&gt; </paramtype>
          </param>
          <param>
            <paramname> control-string </paramname>
            <paramtype> &lt;string&gt; </paramtype>
          </param>
          <restparam>
            <paramname> args </paramname>
            <paramsummary>
              The objects to substitute for the format fields.
            </paramsummary>
          </restparam>
        </defparameters>
        <defreturns>
        </defreturns>
        <defdescription>
          <para>
            The default <function>format</function> method, specialized on
            the <classname>&lt;stream&gt;</classname> class.
          </para>
        </defdescription>
      </dylanmethoddef>
      
      <dylanfunctiondef>
        <defname> format-to-string </defname>
        <defsummary>
          Process a format-string and return the result as another string.
        </defsummary>
        <defparameters>
          <param>
            <paramname> control-string </paramname>
            <paramtype> &lt;string&gt; </paramtype>
          </param>
          <restparam>
            <paramname> args </paramname>
            <paramsummary>
              The objects to substitute for the format fields.
            </paramsummary>
          </restparam>
        </defparameters>
        <defreturns>
          <param>
            <paramname> result </paramname>
            <paramtype> &lt;string&gt; </paramtype>
          </param>
        </defreturns>
        <defdescription>
          <para>
            This function effectively calls <function>format</function> and
            returns the <dname>result</dname> as a string.
          </para>
        </defdescription>
      </dylanfunctiondef>      
      
      <dylangenericdef>
        <defname> print-message </defname>
        <defadjectives>
          Open
        </defadjectives>
        <defsummary>
          This method is called to format objects for the <dlit>"%s"</dlit>
          and <dlit>"%c"</dlit> format operators, in a form suitable for
          human readers.
        </defsummary>
        <defparameters>
          <param>
            <paramname> object </paramname>
            <paramtype> &lt;object&gt; </paramtype>
          </param>
          <param>
            <paramname> stream </paramname>
            <paramtype> &lt;stream&gt; </paramtype>
          </param>
        </defparameters>
        <defreturns>
        </defreturns>
        <defdescription>
          <para>
            Prints <dname>object</dname> to <dname>stream</dname>. This
            generic function is intended to define the human-readable
            printing behavior of a Dylan object, as opposed to their
            representation as literal syntax. Calling this function on
	    <classname>&lt;condition&gt;</classname> should result in
	    a error message, rather than the name of the instance and
	    its class, for example. (Contrast this behavior with the 
	    <function> print </function> function in the
	    <dlibrary>Print</dlibrary> library.)
          </para>
          <para>
            Predefined methods exist for the 
            <classname> &lt;string&gt; </classname>, 
            <classname> &lt;character&gt; </classname>, 
            <classname> &lt;condition&gt; </classname>, and 
            <classname> &lt;symbol&gt; </classname>  classes.
          </para>
        </defdescription>
      </dylangenericdef>
    </sect1>
  </chapter>

  <CHAPTER ID="libs-format-out">
    <TITLE>The Format-Out Library</TITLE>

    <PARA>The Format-Out library is designed to provide a simple
    interface to the Format library. It exports the module Format-Out
    and re-exports the Format and Standard-IO modules from the Format
    and Standard-IO libraries respectively. The Format-Out module
    exports one function <FUNCTION>format-out</FUNCTION>.</PARA>
    

    <REFENTRY>
      <REFNAMEDIV>
	<REFNAME>format-out</REFNAME>
	<REFPURPOSE>Function</REFPURPOSE>
      </REFNAMEDIV>
      <REFSECT1>
	<TITLE>Summary</TITLE>
	<PARA>Formats arguments to <dlit>*standard-output*</dlit>.</PARA>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Signature</TITLE>
	<SYNOPSIS><FUNCTION>format-out</FUNCTION> <PARAMETER>control-string</PARAMETER> <dlit>#key</dlit> <PARAMETER>args</PARAMETER> => </SYNOPSIS>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Arguments</TITLE>
	<VARIABLELIST>
	  <VARLISTENTRY>
	    <TERM><PARAMETER>control-string</PARAMETER></TERM>
	    <LISTITEM>
	      <PARA>An instance of
	      <CLASSNAME>&lt;byte-string&gt;</CLASSNAME>.</PARA>
	    </LISTITEM>
	  </VARLISTENTRY>
	  <VARLISTENTRY>
	    <TERM><PARAMETER>args</PARAMETER></TERM>
	    <LISTITEM>
	      <PARA>Instances of <CLASSNAME>&lt;object&gt;</CLASSNAME></PARA>
	    </LISTITEM>
	  </VARLISTENTRY>
	</VARIABLELIST>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Values</TITLE>
	<PARA>None</PARA>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Description</TITLE>
	<PARA>Performs</PARA>
	<PROGRAMLISTING>
apply(format, *standard-output*, control-string, args);</PROGRAMLISTING>
      </REFSECT1>
    </REFENTRY>
  </CHAPTER>

  <CHAPTER ID="libs-print">
    <TITLE>The Print Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER ID="libs-collection-extensions">
    <TITLE>The Collection-Extensions Library</TITLE>

    <PARA></PARA>

  </CHAPTER>

  <chapter id="libs-table-extensions">
    <title> The table-extensions Library </title>
    <sect1 id="libs-table-extensions-table-extensions">
      <title> The table-extensions Module </title>
  
      <para>
  	This library contains a number of useful additional table classes,
  	and a number of functions that could be useful in constructing
  	your own table classes.
      </para>
  
      <dylanclassdef>
  	<defname> &lt;case-insensitive-string-table&gt; </defname>
  	<defadjectives>
  	  sealed
  	  instantiable
  	</defadjectives>
  	<defsummary>
  	  Implements a <classname> &lt;table&gt; </classname> class, keyed by
  	  strings keyed without regard for case.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;value-table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    <classname> &lt;case-insensitive-string-table&gt; </classname>
  	    implements a <classname> &lt;table&gt; </classname> class whose
  	    keys are instances of <classname> &lt;string&gt; </classname>.
  	    However, instead of using <function> \= </function> for the
  	    equivalence relation, strings which are the same modulo case are
  	    considered equivalent.
  	  </para>
  	  <para>
  	    Note that the case-insensitivity is true in general only for 
  	    English strings -- non-English characters have their case 
  	    "normalized" by subtracting the difference in integer code
  	    for the character 'a' and 'A'. This works only for ASCII
  	    and Unicode, and only for English. 
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname> &lt;equal-table&gt; </defname>
  	<defadjectives>
  	  sealed
  	  instantiable
  	</defadjectives>
  	<defsummary>
  	  Implements a class which compares keys using <function> \= </function>.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    <classname> &lt;equal-table&gt; </classname> implements a
  	    <classname> &lt;table&gt; </classname> class whose keys are
  	    compared with <function> \= </function> rather than <function>
  	    \== </function>. So for example, two instances of <classname>
  	    list </classname> that don't have object identity, but did
  	    contain references to the same object, would be considered
  	    equivalent keys by <classname> &lt;equal-table&gt; </classname>.
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname> &lt;hash-state&gt; </defname>
  	<defsummary>
  	  The type of hash states. 
  	</defsummary>
  	<defsupers>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    <classname> &lt;hash-state&gt; </classname> is the type of the
  	    hash state returned as the second value of hash functions.
  	    For example, <dlit>$permanent-hash-state</dlit> is of type
  	    <classname> &lt;hash-state&gt; </classname>.
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname> &lt;string-table&gt; </defname>
  	<defadjectives>
  	  sealed
  	  instantiable
  	</defadjectives>
  	<defsummary>
  	  A <classname> &lt;table&gt; </classname> class keyed by strings.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;value-table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    This class implements a <classname> &lt;table&gt; </classname>
  	    class that is keyed by <function> \= </function> equal 
  	     <classname> &lt;string&gt; </classname> instances.
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylanclassdef>
  	<defname> &lt;value-table&gt; </defname>
  	<defadjectives>
  	  open
  	  abstract
  	</defadjectives>
  	<defsummary>
  	  Intended as the abstract superclass of user-defined tables.
  	</defsummary>
  	<defsupers>
  	  <defsuper>
  	    &lt;table&gt;
  	  </defsuper>
  	</defsupers>
  	<definitkeywords>
  	</definitkeywords>
  	<defdescription>
  	  <para>
  	    This class is intended to be an abstract superclass of
  	    <classname> &lt;table&gt; </classname> classes that have
  	    user-defined key comparison and hash functions. (NB: The hash
  	    functions cannot involve physical addresses.)
  	  </para>
  	</defdescription>
      </dylanclassdef>
      
      <dylangenericdef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Tests whether two objects (usually strings) are the same modulo
  	  case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Tests whether two objects have the same string value modulo case.
  	    Comparisons to non- <classname> &lt;string&gt; </classname> or 
  	    <classname> &lt;character&gt; </classname> instances return
  	    <dlit>#f</dlit>.
  	  </para>
  	</defdescription>
      </dylangenericdef>
      
      <dylanmethoddef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Least-specific method testing whether two objects are the same
  	  modulo case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Since at least one of the arguments is not a <classname>
  	    &lt;character&gt; </classname> or <classname> &lt;string&gt;
  	    </classname>, this method always returns <dlit>#f</dlit>.
  	  </para>
  	</defdescription>
      </dylanmethoddef>
      
      <dylanmethoddef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Method testing whether two characters are the same modulo case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This method returns true if either the two arguments are the
  	    same character, or if they are alphabetic characters that are
  	    the same character modulo case. (This only works for English
  	    characters in general.)
  	  </para>
  	</defdescription>
      </dylanmethoddef>
      
      <dylanmethoddef>
  	<defname> case-insensitive-equal </defname>
  	<defsummary>
  	  Method testing whether two strings are the same modulo case.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> object-1 </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> object-2 </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This method returns true if the two arguments are the same
  	    size, and each component character returns true with a 
  	    <function> case-insensitive-equal </function>. 
  	  </para>
  	</defdescription>
      </dylanmethoddef>
      
      <dylanfunctiondef>
  	<defname> case-insensitive-string-hash </defname>
  	<defsummary>
  	  The default hash function for case-insensitive strings.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> s </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> hash-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This is a convenient hash function for case-insensitive
  	    strings. It is returned as the <function>table-protocol</function>
  	    method's second value for
  	    <classname> &lt;case-insensitive-string-table&gt; </classname>.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      <dylanfunctiondef>
  	<defname> collection-hash </defname>
  	<defsummary>
  	  A function for building hash functions that test collection
  	  equivalence.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> key-hash </paramname>
  	    <paramtype> &lt;function&gt; </paramtype>
  	    <paramsummary>
  	      Computes hash ids for the keys. It takes an object and a
  	      <classname>&lt;hash-state&gt;</classname> as an argument, and
  	      returns a hash id and a hash state.
  	    </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> element-hash </paramname>
  	    <paramtype> &lt;function&gt; </paramtype>
  	    <paramsummary>
  	      Computes hash ids for the elements. It takes an object and a
  	      <classname>&lt;hash-state&gt;</classname> as an argument, and
  	      returns a hash id and a hash state.
  	    </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> col </paramname>
  	    <paramtype> &lt;collection&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	  <keyparam>
  	    <paramname> ordered </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	    <paramsummary>
  	      Whether or not to do an ordered merge of the key/element hash
  	      codes. The default is <dlit>#f</dlit>.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	    <paramsummary> The hash id. </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Two collections will yield the same hash id, if each of their
  	    keys/element pairs hash to the same value. It's safe to set
  	    the <dlit>ordered:</dlit> keyword argument to <dlit>#t</dlit>
  	    only if the collection has a natural iteration order.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  	  
      <dylangenericdef>
  	<defname> equal-hash </defname>
  	<defsummary>
  	  Computes hash ids for objects such that two objects that are
  	  <function> \= </function> equal have the same hash id.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> thing </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Methods on <function> equal-hash </function> should return hash
  	    ids such that the	id for two <function> \= </function> equal 
  	    objects are the same.
  	  </para>
  	  <para>
  	    There is a default method is defined on all instances of 
  	    &lt;object&gt;, and it returns a valid hash id in all cases. 
  	    However, performance *will* suck horribly (algorithmically, even) 
  	    if you don't define better methods for your own objects that will 
  	    live in <classname> &lt;equal-table&gt; </classname> instances.
  	  </para>
  	  <para>
  	    Good methods for <function>equal-hash</function> are defined for
  	    &lt;integer&gt;, &lt;float&gt;, &lt;symbol&gt;, &lt;type&gt;,
  	    &lt;function&gt;, &lt;boolean&gt;, &lt;condition&gt;, and
  	    &lt;collection&gt;. (Note that &lt;collection&gt; is a supertype
  	    of &lt;string&gt;.)
  	  </para>
  	</defdescription>
      </dylangenericdef>
      
      <dylanfunctiondef>
  	<defname> remove-all-keys! </defname>
  	<defsummary>
  	  Remove all keys from a table.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> coll </paramname>
  	    <paramtype> &lt;mutable-explicit-key-collection&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> coll </paramname>
  	    <paramtype> &lt;mutable-explicit-key-collection&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This function iterates through all the keys and calls
  	    <function> remove-key! </function> on each one.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      <dylanfunctiondef>
  	<defname> sequence-hash </defname>
  	<defsummary>
  	  Like <function> collection-hash </function>, only a more
  	  efficient version just for sequences.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> element-hash </paramname>
  	    <paramtype> &lt;function&gt; </paramtype>
  	    <paramsummary>
  	      Computes hash ids for the elements. It takes an object and a
  	      <classname>&lt;hash-state&gt;</classname> as an argument, and
  	      returns a hash id and a hash state.
  	    </paramsummary>
  	  </param>
  	  <param>
  	    <paramname> seq </paramname>
  	    <paramtype> &lt;sequence&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    This is similar to an <function> equal-hash </function>, except
  	    that it hashes things with <dlit> ordered: #t </dlit> and
  	    ignores the sequence keys. USE WITH CAUTION: This isn't a proper
  	    equal-hash because two collections of different types but
  	    identical key/element pairs won't generate the same hash id,
  	    even though the two collections are <function> \= </function>.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      
      <dylanfunctiondef>
  	<defname> string-hash </defname>
  	<defsummary>
  	  A convenient function for hashing strings
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> s </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> initial-state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    A convenient method for hashing strings. Used by
  	    <classname> &lt;string-table&gt; </classname>.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
  	  
      <dylangenericdef>
  	<defname> value-hash </defname>
  	<defsummary>
  	  Computes hash ids for objects such that two objects that are
  	  <function> \= </function> equal have the same hash id.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> thing </paramname>
  	    <paramtype> &lt;object&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> id </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <param>
  	    <paramname> state </paramname>
  	    <paramtype> &lt;hash-state&gt; </paramtype>
	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Methods on <function> equal-hash </function> should return hash
  	    ids such that the	id for two <function> \= </function> equal 
  	    objects are the same.
  	  </para>
  	  <para>
  	    There is a default method is defined on all instances of 
  	    &lt;object&gt;, and it returns a valid hash id in all cases. 
  	    However, performance *will* suck horribly (algorithmically, even) 
  	    if you don't define better methods for your own objects that will 
  	    live in <classname> &lt;equal-table&gt; </classname> instances.
  	  </para>
  	  <para>
  	    Good methods for <function>equal-hash</function> are defined for
  	    &lt;integer&gt;, &lt;float&gt;, &lt;symbol&gt;, &lt;type&gt;,
  	    &lt;function&gt;, &lt;boolean&gt;, &lt;condition&gt;, and
  	    &lt;collection&gt;. (Note that &lt;collection&gt; is a supertype
  	    of &lt;string&gt;.)
  	  </para>
  	</defdescription>
      </dylangenericdef>
  
  <!-- 
       We need to add documentation for value-hash and values-hash, but
       I don't understand it well enough to describe yet. 
   -->
  
    </sect1>
  </chapter>          

  <chapter id="libs-string-extensions">
    <title> The string-extensions Library </title>
   
    <sect1 id="libs-string-extensions-character-type">
      <title>Module character-type</title>
  
      <para>
  	This module contains a set of methods for testing various
  	properties of <classname> &lt;character&gt; </classname> this
  	will work 100% correctly only with ASCII English characters.
  	Fixing this so it handles Unicode better would be a good way
  	of covering yourself with glory, hint hint.
      </para>
  
<!--
      <dylanfunctiondef>
  	<defname> alpha? </defname>
  	<defsummary> Synonym for alphabetic? </defsummary>
	<defdescription> </defdescription>
      </dylanfunctiondef>
  -->
      <dylanfunctiondef>
  	<defname> alphabetic? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if the character is in [a-zA-Z].
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param> 
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if the character is alphabetic,
  	    <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  	  
      <dylanfunctiondef>
  	<defname> digit? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if the character is a numeric digit
  	  [0-9].
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if the character is a digit,
  	    <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> alphanumeric? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if the character is alphabetic or a
  	digit.  </defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if the character is alphanumeric,
  	    <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname>  whitespace? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if the character is whitespace.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if character is whitespace (space,
  	    tab, linefeed,or newline), and #f otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      <dylanfunctiondef>
  	<defname> lowercase? </defname>
  	<defsummary>
  	  returns <dlit>#t</dlit> if the character is in [a-z].
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if character is lowercase (in
  	    [a-z]), <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>

      <dylanfunctiondef>
  	<defname> hex-digit? </defname>
  	<defsummary>
  	  returns <dlit>#t</dlit> if the character is a hexadecimal
  	  digit.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if the character is a hexadecimal
  	    digit; that is, ifit is in [0-9], [a-f] or [A-F]. Return
  	    <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
      
      <dylanfunctiondef>
  	<defname> graphic? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if the character is a graphic
  	  character.
	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if the character is a printing,
  	    non-whitespace character, <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> printable? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if character is printable.
  	</defsummary>       
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if the character is a printing
  	    character, <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> punctuation? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if character is punctuation.
  	</defsummary>       
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if the character is a graphic,
  	    non-alphanumeric character, <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  	  
      <dylanfunctiondef>
  	<defname> control? </defname>
  	<defsummary>
  	   Returns <dlit>#t</dlit> if the character is not printable.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if character is a control
  	    character, <dlit>#f</dlit> otherwise.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> byte-character? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if the character is an ASCII
  	  character. Could be flaky.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <function> byte-character? </function> will return true if
  	    <dlit>as(&lt;integer&gt;, character)</dlit> returns less than
  	    256.  I don't know enough about Unicode and character set
  	    encodings to say what this means.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> uppercase? </defname>
  	<defsummary>
  	  Returns <dlit>#t</dlit> if the character is uppercase.
  	</defsummary>       
  	<defparameters>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> answer </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    Returns <dlit>#t</dlit> if character is in [A-Z], 
  	    <dlit>#f</dlit> otherwise
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
    </sect1>
  
    <sect1 id="libs-string-extensions-string-conversions">
      <title> The string-conversions Module </title>
      <para>
  	This module contains some handy functions to convert numbers
  	to strings and vice-versa, as well some &lt;character&gt; to
  	&lt;string&gt; conversions. [Note: It might be a good idea to
  	try making <function>string-to-integer</function> and
  	<function>integer-to-string</function> methods on
  	<function>as</function>, which is the usual generic for type
  	coercions. Ask about this on the GD mailing list.]
      </para>
  
      <dylanfunctiondef>
  	<defname> as </defname>
  	<defsummary>
  	  Convert a character to a string.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> class </paramname>
  	    <paramtype> singleton(&lt;string&gt;) </paramtype> 
  	  </param>
  	  <param>
  	    <paramname> character </paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> string </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <dlit> as(&lt;string&gt;, character) </dlit> returns a
  	    fresh instance of <classname> &lt;string&gt; </classname>
  	    of size 1, whose only element is the character.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> digit-to-integer </defname>
  	<defsummary>
  	  Convert a character to the integer it denotes.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname>character</paramname>
  	    <paramtype> &lt;character&gt; </paramtype>
  	    <paramsummary>
  	      An error is signalled character it is not alphanumeric.
  	    </paramsummary>
  	  </param>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> integer </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	    <paramsummary> Between 0 and 35, inclusive. </paramsummary>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <function> digit-to-integer </function> converts an
  	    alphanumeric character to an integer. '0' through '9'
  	    convert to 0 to 9, and 'a' through 'z' convert to 10 to
  	    35. An error is signalled if the character is not in this
  	    range.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> integer-to-digit </defname>
  	<defsummary>
  	  Convert an integer to the corresponding digit.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> digit </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <keyparam>
  	    <paramname> base </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	    <paramsummary>
  	      Between 2 and 35, inclusive, representing the radix of
  	      the digit to return. The default base is 10.
  	    </paramsummary>
  	  </keyparam>
  	  <keyparam>
  	    <paramname> uppercase </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	    <paramsummary>
  	      For <dlit>#t</dlit> returns uppercase letters for digits
  	      greater than 10, and lowercase for <dlit>#f</dlit>. The
  	      default is <dlit>#f</dlit>.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
	  <param>
	    <paramname> digit </paramname>
	    <paramtype> &lt;character&gt; </paramtype>
	    <paramsummary>The returned digit is an alphanumeric character.</paramsummary>
	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <function> integer-to-digit </function> converts an
  	    integer to the corresponding digit in the specified
  	    base. If the integer is outside the range a single digit
  	    in the specified base can represent, an error is
  	    signalled. Digits for values of 10 or higher are
  	    represented with the letters 'a' through 'z', with 'a' for
  	    10 and 'z' for 35.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> integer-to-string </defname>
  	<defsummary>
  	  Converts an integer to a string value. 
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> num </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	  <keyparam>
  	    <paramname> base </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	    <paramsummary>
  	      <dlit>base</dlit> should be between 2 and 36, inclusive,
  	      and is the radix of the string representation; it
  	      defaults to 10. An error will be signalled for radixes
  	      not in this range.
  	    </paramsummary>
  	  </keyparam>
  	  <keyparam>
  	    <paramname> uppercase </paramname>
  	    <paramtype> &lt;boolean&gt; </paramtype>
  	    <paramsummary>
  	      If it is <dlit>#t</dlit>, then uppercase letters will be
  	      used to represent digits higher than 9, and lowercase
  	      will be used if <dlit>#f</dlit>.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> number </paramname>
  	    <paramtype> &lt;string&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <function> integer-to-string </function> converts an
  	    integer to a string. String representations for radixes
  	    above 10 use the letters 'a' through 'z' for the digits
  	    from 10 to 35. So hexadecimal numbers would use [0-9] and
  	    [a-f], and base 20 would use [0-9] and [a-j], and base 36
  	    would use all the alphanumeric characters.
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
  
      <dylanfunctiondef>
  	<defname> string-to-integer </defname>
  	<defsummary>
  	  Read a sequence of characters as an integer.
  	</defsummary>
  	<defparameters>
  	  <param>
  	    <paramname> string </paramname>
  	    <paramtype> &lt;sequence&gt; </paramtype>
  	    <paramsummary>
  	      Any <classname> &lt;sequence&gt; </classname> of
  	      <classname> &lt;character&gt; </classname> objects are
  	      acceptable. This is typically but not necessarily a
  	      <classname> &lt;string&gt; </classname>.
  	    </paramsummary>
  	  </param>
  	  <keyparam>
  	    <paramname> base </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	    <paramsummary>
  	      Between 2 and 36, inclusive, denoting the base to read
  	      integers in. An error is signalled if base is not in
  	      this range. The default is 10.
  	    </paramsummary>
  	  </keyparam>
  	</defparameters>
  	<defreturns>
  	  <param>
  	    <paramname> integer </paramname>
  	    <paramtype> &lt;integer&gt; </paramtype>
  	  </param>
  	</defreturns>
  	<defdescription>
  	  <para>
  	    <function>string-to-integer</function> converts a sequence
  	    of <classname>&lt;character&gt;</classname> objects to an
  	    integer. The characters are the digits of the string
  	    representation, and must lie between '0' and 'z', with a
  	    maximum depending on the base. For example, octal (base 8)
  	    digits must be in [0-7], decimal digits must be in [0-9],
  	    and hexadecimal digits must be in [0-9] or [a-f]. An error
  	    is signalled if this constraint is violated. (Start
  	    negative integers with a '-', so "-36" would become -36.)
  	  </para>
  	</defdescription>
      </dylanfunctiondef>
    </sect1>
  
    <sect1 id="libs-string-extensions-string-hacking">
      <title>The string-hacking Module</title>
      <para>
  	This module contains some random, possibly-useful functions
  	to munge strings. 
      </para>
    </sect1>
  
    <sect1 id="libs-string-extensions-substring-search">
      <title>The substring-search Module</title>
      <para>
  	This module contains some functions to do fast Boyer-Moore
  	searching on strings.
      </para>
    </sect1>
  </chapter>
  
  <CHAPTER ID="libs-regular-expressions">
    <TITLE>The Regular-Expressions Library</TITLE>

    <PARA></PARA>

  </CHAPTER>

  <CHAPTER ID="libs-transcendental">

    <!-- This is causing problems with Jade, I believe
    <DOCINFO>
      <TITLE>Transcendental Library</TITLE>
      <DATE>November 11, 2000</DATE>
      <AUTHORGROUP>
	<AUTHOR>&person.dauclair;</AUTHOR>
      </AUTHORGROUP>
    </DOCINFO>
    -->

    <TITLE>The Transcendental Library</TITLE>
    <para>
      The Transcendental library contains functions on numbers.  It
      includes commonly used numbers, such as pi and e, and the
      transcendental functions, including sine, cosine, and tangent,
      and their arc, h, and arc-h counterparts.  Also included are the
      logarithmic family of functions (the various log functions and
      exp), and the square-root and power (^) functions.
    </para>

    <sect1 id="libs-transcendental-sincostan">
    <title>Sine, Cosine, and Tangent</title>
    <para>
      To understand the transcendental functions (particularly, sine,
      cosine, and tangent, and their friends), one must know about the
      relationships for a right triangle.  The discussion will use the
      below reference figure:
    </para>
    <triangle>
    <para>
      Sine, cosine, and tangent are used when you know an angle and a
      length of one of the sides of a right triangle, and you want to
      know the length of another side.  For these functions, the angle
      (theta) is in radians, not degrees.  Using the reference diagram
      above, for sine, you work with the hypotenuse (AC) and the height
      (AB), for cosine, you work with the hypotenuse (AC) and the base
      length (BC), and for tangent, you work with the base and the height.
    </para>

    <dylangenericdef>
      <defname>sin</defname>
      <defsummary>Returns the sine of a real number.</defsummary>
      <defparameters>
        <param>
	  <paramname>x</paramname>
	  <paramtype> &lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
        <param>
	  <paramname>y</paramname>
	  <paramtype> &lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
  	<para>
	  Returns the sine of a real number.  Using the above right
	  triangle, the sine of theta is AB / AC.  For example, say AC
	  is 12 meters and theta is <dlit>$double-pi</dlit> / 6 (30 degrees).  
	  You solve
	  for AB by multiplying AC and sine theta.  AB = 12 * 
	  <function>sin</function>(
	  <dlit>$double-pi</dlit> /
	  6.0) => 6 meters.
  	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>cos</defname>
      <defsummary>Returns the cosine of a real number.</defsummary>
      <defparameters>
        <param>
	  <paramname>x</paramname>
	  <paramtype> &lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
        <param>
	  <paramname>y</paramname>
	  <paramtype> &lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
  	<para>
	  Returns the cosine of a real number.  The cosine of theta is
	  BC / AC.  Problem:  Given theta is <dlit>$double-pi</dlit> / 4 
	  and BC is
	  7 meters, what length is AC?  What is theta in degrees?
	  (see the entry for <dlit>$double-pi</dlit> for help)
  	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>tan</defname>
      <defsummary>Returns the tangent of a real number.</defsummary>
      <defparameters>
        <param>
	  <paramname>x</paramname>
	  <paramtype> &lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
        <param>
	  <paramname>y</paramname>
	  <paramtype> &lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
  	<para>
	  Returns the tangent of a real number.  The tangent of theta
	  is AB / BC.  The canonical exercise for tangent is to compute
          the height of a building.  Let's say you want to know how high
          your chimney is.  You are standing 25 meters from the building,
          and the chimney is 4 hands above the ground (where a hand is
          equivalent to 12 degrees).  How tall is your chimney?
  	</para>
      </defdescription>
    </dylangenericdef>
  </sect1>

  <sect1 id="lib-transcendental-pi">
    <title>The pi Constants</title>
    <para>
      So, perhaps you are used to thinking in degrees, not radians.
      How do you convert between the two when you use the above
      functions?  That's as easy as pi!  If you have the angle in
      degrees and one of side lengths, first multiple that angle by
      pi / 180.0 (either <dlit>$double-pi</dlit> or <dlit>$single-pi</dlit>) 
      to get radians, and
      then use that resulting theta in the appropriate 
      function. 
    </para>
    <para>
      There are several engrossing exercises for computing pi, and
      several novel approaches.  The most widely-known approach is to
      compute the value of the series 4 - 4/3 + 4/5 - 4/7 ... (which
      takes a very large number of terms to get close to Chuck Moore's
      find (see below)).  Another is to use the Fibonacci numbers
      (see <ulink url=
      "http://www.ee.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibpi.html">
      this article on computing pi using arc-tangents</ulink>)
      which become usable in about ten terms.
    </para>

    <dylanconstantdef>
      <defname>$double-pi</defname>
      <defsummary>
        The approximation of pi for double-precision floating-point
        arithmetic.
      </defsummary>
      <deftype>&lt;double-float&gt;</deftype>
      <defdescription>
        <para>
	  The value here is 3.14159265358979323846.  Chuck Moore, the
	  inventor of the programming language Forth, chose instead to
	  use 355 / 113 as pi (which is accurate to 3e-7), as
	  computers at the time processed floating point operations
	  too slowly for use in real-time applications.
	</para>
      </defdescription>
    </dylanconstantdef>

    <dylanconstantdef>
      <defname>$single-pi</defname>
      <defsummary>
        The approximation of pi for single-precision floating-point
        arithmetic.
      </defsummary>
      <deftype>&lt;single-float&gt;</deftype>
      <defdescription>
        <para>
	  This pi is a truncated value of <dlit>$double-pi</dlit>.
	</para>
      </defdescription>
    </dylanconstantdef>
  </sect1>

  <sect1 id="lib-transcendental-arc">
    <title>The Inverse (Arc) Functions</title>

    <para>
      The next question that comes up is if you have two sides of the
      right triangle, and you need to know the angle.  The arc
      functions of sine, cosine and tangent resolve this issue.  Let's
      use the same reference diagram for the following discussion.
    </para>
    <triangle>
    <para>
      The
      arc sine function (<function>asin</function>, also known as the 
      inverse sine) gives
      theta (the angle in radians) from the height (AB) over the
      hypotenuse (AC).  The other arc functions, <function>acos</function>, 
      and <function>atan</function>,
      behave as their more-familiar counterparts.  So, the arc-cosine gives
      theta from the base (BC) and the hypotenuse (AC); the arc-tangent,
      from the height(AB) and the base (BC).  Again, to convert
      from radians to degrees, multiple the result by 180 / pi.
    </para>

    <dylangenericdef>
      <defname>asin</defname>
      <defsummary>Returns the arc-sine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the hypotenuse (AC) and the height (AB), the arc-sine
	  gives theta in the diagram:  the angle in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>acos</defname>
      <defsummary>Returns the arc-cosine of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the hypotenuse (AC) and the base (BC), the arc-cosine
	  gives theta in the diagram:  the angle in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>atan</defname>
      <defsummary>Returns the arc-tangent of a real number</defsummary>
      <defparameters>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the height (AB) over the base (BC), the arc-tangent
	  gives theta in the diagram:  the angle in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    <dylangenericdef>
      <defname>atan2</defname>
      <defsummary>Returns the arc-tangent of a pair of real numbers</defsummary>
      <defparameters>
	<param>
	  <paramname>y</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
	<param>
	  <paramname>x</paramname>
	  <paramtype>&lt;real&gt;</paramtype>
	</param>
      </defparameters>
      <defreturns>
	<param>
	  <paramname>z</paramname>
	  <paramtype>&lt;float&gt;</paramtype>
	</param>
      </defreturns>
      <defdescription>
	<para>
	  Given the height (AB) as y and the base (BC) as x, 
	  the arc-tangent gives theta as z:  the angle in radians.
	</para>
      </defdescription>
    </dylangenericdef>

    </sect1>

    <sect1 id="lib-transcendental-e">
    <title>The e Constants</title>
    <para>
      I will leave aside the temptation to find mathematical similarities
      between pi and e, with the exception of stating that both can use
      the Fibonacci numbers to find close approximations of their values.
      e finds use for logarithmic and exponential calculations.
    </para>
      

    <dylanconstantdef>
      <defname>$double-e</defname>
      <defsummary>
        The approximation of e for double-precision arithmetic.
      </defsummary>
      <deftype>&lt;double-float&gt;</deftype>
      <defdescription>
        <para>
	  The value here is 2.7182818284590452354.  To compute your
	  own approximation, use the Fibonacci numbers (1, 1, 2, 3, 5,
	  8, 13, 21 ...).  e = F(n) / F(n-1); where the larger n is,
	  the more accurate e is.
	</para>
      </defdescription>
    </dylanconstantdef>

    <dylanconstantdef>
      <defname>$single-e</defname>
      <defsummary>
        The approximation of e for single-precision arithmetic.
      </defsummary>
      <deftype>&lt;single-float&gt;</deftype>
      <defdescription>
        <para>
	  This e is a truncated value of <dlit>$double-e</dlit>.
	</para>
      </defdescription>
    </dylanconstantdef>

    </sect1>

  </CHAPTER>

  <CHAPTER ID="libs-time">
    <TITLE>The Time Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER ID="libs-random">
    <TITLE>The Random Library</TITLE>

    <PARA></PARA>
  </CHAPTER>
  
  <CHAPTER ID="libs-matrix">
    <TITLE>The Matrix Library</TITLE>
    
    <PARA></PARA>
  </CHAPTER>

  <chapter ID="libs-parse-arguments">
    <docinfo>
      <author>
	&person.emk;
      </author>
    </docinfo>

    <title>The Parse-Arguments Library</title>
    
    <para>The <dlibrary>Parse-Arguments</dlibrary> library provides a
    simple and flexible way to parse the command-line arguments of a Dylan
    program. It provides support for the most common types of command-line
    options, and can be extended to suit the needs of a particular
    application.</para>

    <sect1 id="libs-parse-arguments-terminology">
      <title>Terminology</title>

      <para>The <dlibrary>Parse-Arguments</dlibrary> library uses a
      standard set of terminology for representing the tokens which might
      appear on a command line.</para>

      <figure id="libs-parse-arguments-cmdline-1">
	<title>Sample command line.</title>
<screen>
<prompt>$</prompt> sample-app -v --repeat -n=10 foo.txt -- bar.txt
</screen>
      </figure>
      
      <glosslist>
	<glossentry>
	  <glossterm>application name</glossterm>
	  <glossdef>
	    <para>The application name appears first on the command
	    line. Under Unix-like systems, the application name is passed
	    to the program exactly as typed. In particular, it may be the
	    name of a symlink or include one or more directory
	    components.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>command-line arguments</glossterm>
	  <glossdef>
	    <para>Everything appearing after the application name is a
	    command-line argument.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>regular argument</glossterm>
	  <glossdef>
	    <para>In <xref linkend="libs-parse-arguments-cmdline-1">,
	    <literal>foo.txt</literal> and <literal>bar.txt</literal> are
	    regular arguments.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>option</glossterm>
	  <glossdef>
	    <para>Options are also known as flags and switches. They
	    control the behavior of the application, and may appear in one
	    of two forms. <glossterm>Short options</glossterm> always
	    appear after a single dash, but several of them may be grouped
	    together (e.g. <literal>-tzvf</literal> in GNU tar). In <xref
	    linkend="libs-parse-arguments-cmdline-1">,
	    <literal>-v</literal> and <literal>-n</literal> are both short
	    options. <glossterm>Long options</glossterm> such as
	    <literal>--repeat</literal> consist of entire words and are
	    always preceded by two dashes.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>parameter</glossterm>
	  <glossdef>
	    <para>Parameters modify the behavior of an option. In
            <xref linkend="libs-parse-arguments-cmdline-1">, the
	    <literal>10</literal> following <literal>-n</literal> is a
	    parameter. Note that the equals sign may be surrounded by
	    white space or omitted entirely where unambiguous.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>option terminator</glossterm>
	  <glossdef>
	    <para>The double dash without an option name is called an
	    option terminator. Any arguments appearing after the terminator
	    are automatically regular arguments, even if they begin with a
	    dash.</para>
	  </glossdef>
	</glossentry>
      </glosslist>
    </sect1>

    <sect1 id="libs-parse-arguments-example">
      <title>A Simple Example</title>

      <para><xref linkend="libs-parse-arguments-example-library"> and <xref
      linkend="libs-parse-arguments-example-with-macro"> demonstrate how to use
      the parse-arguments library in a simple application.</para>

      <figure id="libs-parse-arguments-example-library">
	<title>Library declaration for a sample application using
	parse-arguments.</title>
<programlisting>
Module: dylan-user

define library sample-application
  use dylan;
  use format-out;
  use parse-arguments;
end library;

define module sample-application
  use dylan;
  use extensions;
  use format-out;
  use parse-arguments;
end module;
</programlisting>
      </figure>


      <figure id="libs-parse-arguments-example-with-macro">
	<title>Source code for a sample application using
	parse-arguments, making use of the <dlit>define argument-parser</dlit> macro.</title>
<programlisting>
Module: sample-application

define argument-parser &lt;sample-parser> ()
  option verbose?, long: "verbose", short: "v";
  option logfile, kind: &lt;parameter-option-parser>, long: "logfile", short: "L";
  regular-arguments file-names;
end;

define method main(program-name :: &lt;string>, #rest arguments)
  let parser = make(&lt;sample-parser>);

  unless (parse-arguments(parser, arguments))
    format-out("Usage: %s [-v] [-Llogfile] files...\n", program-name);
    exit(exit-code: 1);
  end;

  // Body of program.
end;
</programlisting>
      </figure>

      <para>In <xref linkend="libs-parse-arguments-example-with-macro">, the
      variable <dlit>parser.verbose?</dlit> will be set to <dlit>#t</dlit> if
      either <literal>--verbose</literal> or <literal>-v</literal> appears
      on the command line. Otherwise, it will be set to
      <dlit>#f</dlit>. Similarly, if <literal>-Lfilename</literal> or
      <literal>--logfile=filename</literal> appears on the command line,
      the variable <dlit>parser.logfile</dlit> will be set the string
      <literal>"filename"</literal>. Otherwise, it too will be set to
      <dlit>#f</dlit>.</para>

      <para>Any other arguments will be collected and placed in the
      variable <dlit>parser.file-names</dlit>.</para>

      <para><xref linkend="libs-parse-arguments-example-source"> shows
      how to use the <dlibrary>Parse-Arguments</dlibrary> library
      without using the <dlit>define argument-parser</dlit>
      macro. Here the various arguments are added manually, and
      accessed using the <dname>option-value-by-long-name</dname>
      method.</para>

      <figure id="libs-parse-arguments-example-source">
	<title>Source code for a sample application using
	parse-arguments.</title>
<programlisting>
Module: sample-application

define method main(program-name :: &lt;string>, #rest arguments)
  let parser = make(&lt;argument-list-parser>);
  add-option-parser-by-type(parser,
                            &lt;simple-option-parser>,
                            long-options: #("verbose"),
                            short-options: #("v"));
  add-option-parser-by-type(parser,
                            &lt;parameter-option-parser>,
                            long-options: #("logfile"),
                            short-options: #("L"));

  unless (parse-arguments(parser, arguments))
    format-out("Usage: sample-application [-v] [-Llogfile] files...\n");
    exit(exit-code: 1);
  end;

  let verbose? = option-value-by-long-name(parser, "verbose");
  let logfile = option-value-by-long-name(parser, "logfile");
  let file-names = parser.regular-arguments;

  // Body of program.
end;
</programlisting>
      </figure>


      <para>Using the <dname>define argument-parser</dname> is the
      preferred way of using the <dlibrary>Parse-Arguments</dlibrary>
      library. It is both more convenient and better readable. The
      manual way is documented both for users of Mindy, which doesn't
      have macro capabilities, and for advanced users who wish to
      extend the functionality of the option parsers.</para>

    </sect1>

    <sect1 id="libs-parsing-arguments">
      <title>Parsing Arguments</title>
      
      <para>To parse a command-line, you create a new
      <dname>&lt;argument-list-parser></dname>, connect a number of
      individual <dname>&lt;option-parser></dname>s, call
      <dname>parse-arguments</dname>, and use the resulting
      information.</para>

      <sect2>
	<title>Argument List Parsers</title>

	<dylanclassdef>
	  <defname>&lt;argument-list-parser></defname>
	  <defadjectives>Sealed</defadjectives>
	  <defsummary>Describes how to parse an argument list, and contains
	  the data found when parsing one.</defsummary>
	  <defsupers>
	    <defsuper>&lt;object></defsuper>
	  </defsupers>
	  <definitkeywords>
	  </definitkeywords>
	  <defdescription>
	    <para>An <dname>&lt;argument-list-parser></dname> represents
	    both a description of the data to be found in an argument list,
	    and the results of parsing a particular argument list for that
	    data.</para>

	    <para>Prior to calling <dname>parse-arguments</dname> for the
	    first time, no useful information can be extracted from an
	    argument list parser. Subsequent calls to
	    <dname>parse-arguments</dname> will update the data contained
	    within the parser.</para>
	  </defdescription>
	</dylanclassdef>

	<dylanfunctiondef>
	  <defname>regular-arguments</defname>
	  <defsummary>Returns the regular arguments found by parsing an
	  argument list.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>arguments</paramname>
	      <paramtype>&lt;sequence></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>After calling <dname>parse-arguments</dname>, this
	    function can be used to find all of the <glossterm>regular
	    arguments</glossterm> that weren't consumed by any option
	    parser.</para>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>

      <sect2>
	<title>Option Parsers</title>

	<dylanclassdef>
	  <defname>&lt;option-parser></defname>
	  <defadjectives>Abstract Open Primary</defadjectives>
	  <defsummary>Parses a single command-line option and any
	  parameters.</defsummary>
	  <defsupers>
	    <defsuper>&lt;object></defsuper>
	  </defsupers>
	  <definitkeywords>
	    <keyparam>
	      <paramname>long-options</paramname>
	      <paramtype>&lt;list></paramtype>
	      <paramdefault>#()</paramdefault>
	      <paramsummary>Specifies the long options handled by this
	      parser, represented as strings.</paramsummary>
	    </keyparam>
	    <keyparam>
	      <paramname>short-options</paramname>
	      <paramtype>&lt;list></paramtype>
	      <paramdefault>#()</paramdefault>
	      <paramsummary>Specifies the short options handled by this
	      parser, represented as strings.</paramsummary>
	    </keyparam>
	  </definitkeywords>
	  <defdescription>
	    <para>Different types of command-line options are parsed
	    according to different rules. An
	    <dname>&lt;option-parser></dname> knows how to handle one type of
	    option. The <dlit>long-options:</dlit> and
	    <dlit>short-options:</dlit> keywords are used to specify which
	    option names should be handled by a given parser.</para>

	    <para>An option parser can be connected to an
	    <dname>&lt;argument-list-parser</dname> for and the values to
	    be found. </para>
	  </defdescription>
	</dylanclassdef>
	
	<dylanfunctiondef>
	  <defname>option-present?</defname>
	  <defsummary>Tests whether an option was present on the
	  command-line.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>present?</paramname>
	      <paramtype>&lt;boolean></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>Returns &true; if and only if
	    <dname>parse-arguments</dname> found at least one corresponding
	    option on the command line. Returns &false; if
	    <dname>parse-arguments</dname> has not been called.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-value</defname>
	  <defsummary>Returns the value found by an option parser after
	  processing the command line.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>value</paramname>
	    </param>	  
	  </defreturns>
	  <defdescription>
	    <para>Returns the value calculated by
            <parameter>parser</parameter> after running
            <dname>parse-arguments</dname>. Returns &false; if
            <dname>parse-arguments</dname> has not been called.</para>

	    <para>The exact type of <parameter>value</parameter> will vary
	    depending on the class of the option parser.</para>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>

      <sect2>
	<title>Parsing an Argument List</title>

	<dylanfunctiondef>
	  <defname>add-option-parser</defname>
	  <defsummary>Attaches an <dname>&lt;option-parser></dname> to an
	  <dname>&lt;argument-list-parser></dname>.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>args-parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>option-parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>Attaches an <dname>&lt;option-parser></dname> to an
	    <dname>&lt;argument-list-parser></dname>. It is an error
	    to attach an <dname>&lt;option-parser></dname> more than once,
	    and no mechanism is provided to detach one.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>add-option-parser-by-type</defname>
	  <defsummary>Create an <dname>&lt;option-parser></dname> and add
	  it to an <dname>&lt;argument-list-parser></dname>.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>args-parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>option-parser-type</paramname>
	      <paramtype>subclass(&lt;option-parser>)</paramtype>
	      <paramsummary>The class for the new option
	      parser.</paramsummary>
	    </param>
	    <restparam>
	      <paramname>init-keys</paramname>
	      <paramsummary>Inititialization keywords for for the new
	      option parser.</paramsummary>
	    </restparam>
	  </defparameters>
	  <defreturns>
	  </defreturns>
	  <defdescription>
	    <para>This function is equivalent to calling:</para>

	    <programlisting>
let opt-parser =
  apply(make, option-parser-type, init-keys);
add-option-parser(args-parser, opt-parser);
</programlisting>

	    <para>Most programs will use this function instead of
	    <dname>add-option-parser</dname>.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>parse-arguments</defname>
	  <defsummary>Parses a list of command-line arguments.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>	      
	    </param>
	    <param>
	      <paramname>argument-list</paramname>
	      <paramtype>&lt;sequence></paramtype>
	      <paramsummary>The strings to be parsed.</paramsummary>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>success?</paramname>
	      <paramtype>&lt;boolean></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>This routine does most of the work in the
	    <dlibrary>Parse-Arguments</dlibrary> library. It performs a
	    number of different steps:</para>

	    <orderedlist>
	      <listitem>
		<formalpara>
		  <title>Split the argument list</title> <para>If the
		  string <dlit>"--"</dlit> appears in the argument list,
		  discard it, and set aside everything to right for later
		  processing.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Chop individual arguments around any equals
		  sign</title> <para>If any argument contains the character
		  <dlit>'='</dlit>, break the argument into three strings:
		  everything before the first occurance of the equals sign,
		  the sign itself, and the remainder of the original
		  string.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Tokenize the argument list</title> <para>Convert
		  the argument list into a series of tokens. For more
		  details on this process, see <xref
		  linkend="libs-parse-arguments-extending">.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Process the argument list from left to right</title>
		  <para>For each option token, invoke the appropriate
		  option parser (which may consume additional
		  tokens). Record all regular argument tokens for later
		  use. If any other kinds of tokens appear in the argument
		  list, they must be consumed by an option parser or the
		  entire process will fail.</para>
		</formalpara>
	      </listitem>
	      <listitem>
		<formalpara>
		  <title>Collect the regular arguments</title>
		  <para>Take the regular arguments found while parsing,
		  and append any arguments set aside in the first step.</para>
		</formalpara>
	      </listitem>
	    </orderedlist>

	    <para>If an error occurs during this process, parsing will stop
	    immediately and <dname>parse-arguments</dname> will return
	    &false;. Otherwise, it will return &true;.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-parser-by-long-name</defname>
          <defsummary>Find an option parser, given a corresponding option
	  name.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>long-name</paramname>
	      <paramtype>&lt;string></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>option-parser</paramname>
	      <paramtype>&lt;option-parser></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>This function can be used to recover an option parser
	    previously attached to an
	    <dname>&lt;argument-list-parser></dname>.</para>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-present?-by-long-name</defname>
          <defsummary>Determine whether an option was present, given a
          corresponding option name.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>long-name</paramname>
	      <paramtype>&lt;string></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>present?</paramname>
	      <paramtype>&lt;boolean></paramtype>
	    </param>
	  </defreturns>
	  <defdescription>
	    <para>This function provides an easy way to determine whether a
	    given option parser found anything in an argument list.</para>

	    <note>
	      <para>If an option has multiple names, any one of
	      them can be used as the argument to this function without
	      changing the result.</para>
	    </note>
	  </defdescription>
	</dylanfunctiondef>

	<dylanfunctiondef>
	  <defname>option-value-by-long-name</defname>
          <defsummary>Find the value of an option, given a corresponding
          option name.</defsummary>
	  <defparameters>
	    <param>
	      <paramname>parser</paramname>
	      <paramtype>&lt;argument-list-parser></paramtype>
	    </param>
	    <param>
	      <paramname>long-name</paramname>
	      <paramtype>&lt;string></paramtype>
	    </param>
	  </defparameters>
	  <defreturns>
	    <param>
	      <paramname>value</paramname>
	    </param>	  
	  </defreturns>
	  <defdescription>
	    <para>This function provides an easy way to find the value of a
	    particular option parser.</para>

	    <note>
	      <para>If an option has multiple names, any one of
	      them can be used as the argument to this function without
	      changing the result.</para>
	    </note>
	  </defdescription>
	</dylanfunctiondef>
      </sect2>
    </sect1>

    <sect1 id="libs-parse-arguments-option-parsers">
      <title>Standard Option Parser Classes</title>

      <para><dlibrary>Parse-Arguments</dlibrary> supports the most popular
      types of <acronym>POSIX</acronym> and <acronym>GNU</acronym>
      command-line options.</para>

      <dylanclassdef>
	<defname>&lt;negative-option-parser></defname>
	<defadjectives>Abstract Open</defadjectives>
	<defsummary>Parses command-line options which may appear in
	positive and negative forms.</defsummary>
	<defsupers>
	  <defsuper>&lt;option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	  <keyparam>
	    <paramname>negative-long-options</paramname>
	    <paramtype>&lt;list></paramtype>
	    <paramdefault>#()</paramdefault>
	    <paramsummary>Specifies the negative long options handled by
	    this parser, represented as strings.</paramsummary>
	  </keyparam>
	  <keyparam>
	    <paramname>negative-short-options</paramname>
	    <paramtype>&lt;list></paramtype>
	    <paramdefault>#()</paramdefault>
	    <paramsummary>Specifies the negative short options handled by
	    this parser, represented as strings.</paramsummary>
	  </keyparam>
	</definitkeywords>
	<defdescription>
	  <para>This class is exported from the module
	  <dmodule>option-parser-protocol</dmodule>. We document it here
	  because it is the superclass of
	  <dname>&lt;simple-option-parser></dname>.</para>

	  <para>Certain command-line options appear in a positive and
	  negative form. For example, many programs accept
	  <literal>--verbose</literal> and <literal>--quiet</literal>
	  options.</para>

	  <para>This class provides internal support for creating parsers
	  to handle such options. It cannot be instantiated.</para>
	</defdescription>
      </dylanclassdef>

      <dylanclassdef>
	<defname>&lt;simple-option-parser></defname>
	<defadjectives>Sealed</defadjectives>
	<defsummary>Parses options without any parameters.</defsummary>
	<defsupers>
	  <defsuper>&lt;negative-option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	  <keyparam>
	    <paramname>default</paramname>
	    <paramtype>&lt;boolean></paramtype>
	    <paramdefault>#f</paramdefault>
	    <paramsummary>Specifies the value returned by this option
	    parser if no applicable options appear on the command
	    line.</paramsummary>
	  </keyparam>
	</definitkeywords>
	<defdescription>
	  <para>Simple options have no parameters, and may appear in both
	  positive and negative forms. When parsing a list of arguments,
	  <dname>option-value</dname> is first set to the default. As the
	  command line is then scanned from left to right, each positive
	  option sets the value to <dlit>#t</dlit> and each negative option
	  sets it to <dlit>#f</dlit>.</para>

	  <para>This behavior is consistent with that of the utility
	  <literal>rm</literal>, which allows the user to set default
	  options with a shell alias of the form <literal>alias rm="rm
	  -i"</literal>. Such defaults can be overriden by explicity
	  passing a flag when calling <literal>rm</literal> because the
	  rightmost value takes precedence.</para>
	</defdescription>
	<defsection>
	  <title>Option Forms</title>
	  
	  <para><literal>-q</literal>, <literal>--quiet</literal>,
	  <literal>-v</literal>, <literal>--verbose</literal></para>
	</defsection>
      </dylanclassdef>

      <dylanclassdef>
	<defname>&lt;parameter-option-parser></defname>
	<defadjectives>Sealed</defadjectives>
	<defsummary>Parses options which have a parameter and which may
        appear only once.</defsummary>
	<defsupers>
	  <defsuper>&lt;option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	</definitkeywords>
	<defdescription>
	  <para>A <dname>&lt;parameter-option-parser></dname> sets
	  <dname>option-value</dname> to either <dlit>#f</dlit> or a
	  <dname>&lt;string></dname>. If the option appears more than
	  once on the command line, the rightmost value is used.</para>
	</defdescription>
	<defsection>
	  <title>Option Forms</title>
	  
	  <para><literal>-fname</literal>, <literal>-f name</literal>,
	  <literal>-f=name</literal>, <literal>-f = name</literal>,
	  <literal>--file name</literal>, <literal>--file=name</literal>,
	  <literal>--file = name</literal></para>
	</defsection>
      </dylanclassdef>

      <dylanclassdef>
	<defname>&lt;repeated-parameter-option-parser></defname>
	<defadjectives>Sealed</defadjectives>
	<defsummary>Parses options which have a parameter and which may
	appear more than once.</defsummary>
	<defsupers>
	  <defsuper>&lt;option-parser></defsuper>
	</defsupers>
	<definitkeywords>
	</definitkeywords>
	<defdescription>
	  <para>A <dname>&lt;repeated-parameter-option-parser></dname> sets
	  <dname>option-value</dname> to a <dname>&lt;sequence></dname> of
	  strings. </para>
	</defdescription>
	<defsection>
	  <title>Option Forms</title>
	  
	  <para><literal>-fname</literal>, <literal>-f name</literal>,
	  <literal>-f=name</literal>, <literal>-f = name</literal>,
	  <literal>--file name</literal>, <literal>--file=name</literal>,
	  <literal>--file = name</literal></para>
	</defsection>
      </dylanclassdef>
    </sect1>

    <sect1 id="libs-parse-arguments-extending">
      <title>Writing New Option Parser Classes</title>

      <para></para>
    </sect1>
  </chapter>

  <CHAPTER ID="libs-dylan-tk">
    <TITLE>The TK Library</TITLE>

    <PARA></PARA>
  </CHAPTER>
</BOOK>
