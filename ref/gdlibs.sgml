<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.0//EN" [
 <!ENTITY % entities SYSTEM "entities.sgml">
 %entities;
]>
<BOOK>
  <TITLE>Gwydion Dylan Library Reference Guide</TITLE>

  <bookinfo>
    <COPYRIGHT>
      <YEAR>1996</YEAR>
      <YEAR>1997</YEAR>
      <YEAR>1998</YEAR>
      <HOLDER>Carnegie Mellon University</HOLDER>
      <HOLDER>Gwydion Dylan Maintainers</HOLDER>
    </COPYRIGHT>
    &cmu.terms;
    <bookbiblio>
      <title>Gwydion Dylan Library Reference Guide</title>
      <titleabbrev>Library Reference Guide</titleabbrev>
      <date>09 September 1998</date>
      <editor>&person.housel;</editor>
    </bookbiblio>
  </bookinfo>

  <CHAPTER>
    <TITLE>Introduction</TITLE>

    <PARA>This manual serves as a guide to the libraries included with
    Gywdion &dylan;.  These libraries include:</PARA>

    <VARIABLELIST>
      <VARLISTENTRY>
	<TERM>Dylan</TERM>
	<LISTITEM>
	  <PARA></PARA>
	</LISTITEM>
      </VARLISTENTRY>
    </VARIABLELIST>
    
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Dylan Library and Gwydion Dylan Extensions</TITLE>

    <SECT1>
      <TITLE>Introduction</TITLE>
      
      <PARA>In the process of working with Dylan, the Gwydion Project
      has come up with numerous extensions to the Dylan language. Some
      of them form entire libraries, like the Collection-Extensions
      and String-Extensions libraries. Others have been added to the
      Dylan library, in such modules as Extensions and System.</PARA>
      
      <PARA>We continue to make no claims about future support for our
      extensions. However, some extensions are more likely than others
      to make it into our future compilers. This file documents those
      extensions which we think will be included in our compiler's
      Dylan library.</PARA>
      
      <PARA>Extensions which go in separate libraries are documented
      in their own files; extensions which are part of the Mindy Dylan
      library but which have a less certain future are documented in
      the Mindy documentation.</PARA>

      <PARA>For the remainder of this chapter, we shall refer to
      "Gwydion compilers" as a shorthand for "Mindy and other
      Dylan compilers that the Gwydion Project may write." It is
      not meant as a guarentee that all future Gwydion releases will
      support these extensions.</PARA>

      <PARA>Specific Gwydion compilers may support extensions not
      listed here; see their documentation for details.</PARA>
    </SECT1>

    <SECT1>
      <TITLE>Modules of the Dylan Library</TITLE>
      
      <PARA>In addition to containing the Dylan module, the Dylan
      library contains a variety of modules which provide
      extensions. Gwydion compilers export the following modules from
      the Dylan library:</PARA>

      <VARIABLELIST>
	<VARLISTENTRY>
	  <TERM>Extensions</TERM>
	  <LISTITEM>
	    <PARA>This module exports useful extensions to the Dylan
            language (see <XREF LINKEND="libs-dylan-extensions">).
            Ultimately, there will be several, more logically separate
            libraries that extend Dylan or provide an application
            framework for users. For now, we put any commonly used
            utilities in the Extensions module.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM>System</TERM>
	  <LISTITEM>
	    <PARA>This module exports an interface to operating system
            calls and special, low-level functionality (see <XREF
            LINKEND="libs-dylan-system">).</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM>Introspection</TERM>
	  <LISTITEM>
	    <PARA>This module exports reflective operations for
	    examining classes, functions, and so on.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>

	<VARLISTENTRY>
	  <TERM>Cheap-io</TERM>
	  <LISTITEM>
	    <PARA>This module exports some basic, unextendable input
	    and output functionality.</PARA>
	  </LISTITEM>
	</VARLISTENTRY>
      </VARIABLELIST>
    </SECT1>

    <SECT1>
      <TITLE>The Dylan Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1 ID=libs-dylan-extensions>
      <TITLE>The Extensions Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1 ID=libs-dylan-system>
      <TITLE>The System Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1>
      <TITLE>The Introspection Module</TITLE>

      <PARA></PARA>
    </SECT1>

    <SECT1>
      <TITLE>The Cheap-IO Module</TITLE>

      <PARA></PARA>
    </SECT1>
  </CHAPTER>

  <CHAPTER>
    <DOCINFO>
      <TITLE>The Streams Library</TITLE>
      <DATE>06 Feb 1997</DATE>
      <EDITOR>
	<FIRSTNAME>Andrew</FIRSTNAME><SURNAME>Shires</SURNAME>
      </EDITOR>
      <AUTHORGROUP>
	<AUTHOR>
	  <FIRSTNAME>Scott</FIRSTNAME><SURNAME>McKay</SURNAME>
	  <AFFILIATION>
	    <ORGNAME>Harlequin, Inc.</ORGNAME>
	  </AFFILIATION>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Bill</FIRSTNAME><SURNAME>Chiles</SURNAME>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Marc</FIRSTNAME><SURNAME>Ferguson</SURNAME>
	</AUTHOR>
	<AUTHOR>
	  <FIRSTNAME>Eliot</FIRSTNAME><SURNAME>Miranda</SURNAME>
	</AUTHOR>
      </AUTHORGROUP>
    </DOCINFO>
    <TITLE>The Streams Library</TITLE>

    <AUTHORBLURB>
      <FORMALPARA>
	<TITLE>Acknowlegements</TITLE>
	<PARA>We'd like to thank the other people who
	have been instrumental in the production of this proposal:
	Jonathan Bachrach, Dave Berry, John Dunning, Chris Fry, Paul
	Haahr, William Lott, Rob Maclachlan, Tim McNerney, Tony Mann,
	Keith Playford, Robert Stockton, and Tucker Withington.</PARA>
      </FORMALPARA>
    </AUTHORBLURB>

    <SECT1>
      <TITLE>Discussing error conditions</TITLE>

      <PARA>This document uses two special terms in discussions of
      error conditions.</PARA>

      <PARA>When we say that something is an error, we mean that the
      result is undefined. In particular, we do not mean that a
      Streams implementation must signal an error condition; that is
      the implementor's choice. So, for instance, the following text,
      from page FIXME, means only that the result of using unread-element
      in the case described is undefined:</PARA>

      <PARA>It is an error to apply
      <FUNCTION>unread-element</FUNCTION> to an element that is not
      the element most recently read from the stream.</PARA>

      <PARA>Only when we specifically mention signaling do we mean
      that a Streams implementation must signal an error
      condition. Note that we may not, in such a case, say exactly
      which error condition must be signaled; if we do not say so, the
      choice is again up to the implementor. In this text from the
      description of stream-position-setter on page FIXME, for instance,
      we state that an implementation must signal an error, but we do
      not say what error must be signaled:</PARA>

      <PARA>When position is a
      <CLASSNAME>&lt;stream-position&gt;</CLASSNAME>, if it is invalid
      for some reason, this function signals an error.</PARA>

      <PARA>By contrast, the following text from the description of
      <FUNCTION>read-element</FUNCTION> on page FIXME says exactly
      which error must be signaled:</PARA>

      <PARA>If the end of the stream is encountered and no value was
      supplied for on-end-of-stream, read-element signals an
      <CLASSNAME>&lt;end-of-stream-error&gt;</CLASSNAME>
      condition. </PARA>
    </SECT1>

    <SECT1>
      <TITLE>Goals of the Library</TITLE>

      <PARA>The Dylan Streams library aims to provide:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>A generic, easy-to-use interface for streaming over
	  sequences and files. The same high-level interface for
	  consuming or producing is available irrespective of the type
	  of stream, or the types of the elements being streamed
	  over.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Efficiency, especially for the common case of file
	  I/O.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>Access to an underlying buffer management protocol.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An extensible framework. Other areas of functionality
	  that require a stream interface should be easy to integrate
	  with the library.</PARA>
	</LISTITEM>
      </ITEMIZEDLIST>

      <PARA>The proposal presents the design of a Streams library that
      meets these goals using Dylan's built-in sequences and a
      buffered disk file interface. </PARA>

      <PARA>The proposal does not address a number of related issues,
      including:</PARA>

      <ITEMIZEDLIST>
	<LISTITEM>
	  <PARA>A standard object-printing package such as Smalltalk's
	  <LITERAL>printOn:</LITERAL> or Lisp's
	  <LITERAL>print-object</LITERAL>, or a formatted printing
	  facility such as Lisp's
	  <LITERAL>format</LITERAL>. Additional libraries are expected
	  to provide these facilities.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>General object dumping and loading.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>A comprehensive range of I/O facilities for using
	  memory-mapped files, network connections, and so on. Such
	  facilities should be easy to add to the Streams library
	  because of its extensible framework.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An interface for naming files.</PARA>
	</LISTITEM>

	<LISTITEM>
	  <PARA>An interface to operating system functionality, such
	  as file renaming or deleting operations.  </PARA>
	</LISTITEM>
      </ITEMIZEDLIST>
    </SECT1>

    <SECT1>
      <TITLE>Concepts</TITLE>

      <PARA>A stream provides sequential access to an aggregate of
      data, such as a Dylan sequence or a disk file. Streams grant
      this access according to a metaphor of reading and writing:
      elements can be read from streams or written to them.</PARA>

      <PARA>Streams are represented as Dylan objects, and all are
      general instances of the class
      <CLASSNAME>&lt;stream&gt;</CLASSNAME>, which the Streams library
      defines.</PARA>

      <PARA>We say that a stream is established over the data
      aggregate. Hence, a stream providing access to the string
      <LITERAL>"hello world"</LITERAL> is said to be a stream over the
      string <LITERAL>"hello world"</LITERAL>.</PARA>

      <PARA>Streams permitting reading operations are called input
      streams. Input streams allow elements from the underlying data
      aggregate to be consumed. Conversely, streams permitting writing
      operations are called output streams. Output streams allow
      elements to be written to the underlying data aggregate. Streams
      permitting both kinds of operations are called input-output
      streams. </PARA>

      <PARA>The library provides a set of functions for reading
      elements from an input stream. These functions hide the details
      of indexing, buffering, and so on. For instance, the function
      read-element reads a single data element from an input
      stream. </PARA>

      <PARA>The following expression binds stream to an input stream
      over the string <LITERAL>"hello world"</LITERAL>: </PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, contents: "hello world");</PROGRAMLISTING>

      <PARA>The first invocation of read-element on stream returns the
      character 'h', the next invocation 'e', and so on. Once a stream
      has been used to consume all the elements of the data, the
      stream is said to be at its end. This condition can be tested
      with the function <FUNCTION>stream-at-end?</FUNCTION>. The
      following code fragment applies function to all elements of the
      sequence:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;sequence-stream&gt;, contents: seq);
while (~stream-at-end?(stream)) 
	function(read-element(stream));
end;</PROGRAMLISTING>

      <PARA>When all elements of a stream have been read, further
      calls to <FUNCTION>read-element</FUNCTION> result in the
      <CLASSNAME>&lt;end-of-stream-error&gt;</CLASSNAME> condition
      being signalled. An alternative end-of-stream behavior is to
      have a distinguished end-of-stream value returned. You can
      supply such an end-of-stream value as a keyword argument to the
      various read functions; the value can be any object. Supplying
      an end-of-stream value to a read function is more efficient than
      asking whether a stream is at its end on every iteration of a
      loop. </PARA>

      <PARA>The library also provides a set of functions for writing
      data elements to an output stream. Like the functions that
      operate upon input streams, these functions hide the details of
      indexing, growing an underlying sequence, buffering for a file,
      and so on. For instance, the function
      <FUNCTION>write-element</FUNCTION> writes a single data element
      to an output stream. </PARA>

      <PARA>The following forms bind stream to an output stream over
      an empty string and create the string <LITERAL>"I
      see!"</LITERAL>, using the function
      <FUNCTION>stream-contents</FUNCTION> to access all of the
      stream's elements.</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;byte-string-stream&gt;, direction: #"output");
write-element(stream, 'I');
write-element(stream, ' ');
write(stream, "see");
write-element(stream, '!');
stream-contents(stream);</PROGRAMLISTING>

      <PARA>Calling <FUNCTION>write</FUNCTION> on a sequence has the
      same effect as calling <FUNCTION>write-element</FUNCTION> on all
      the elements of the sequence. However, it is not required that
      <FUNCTION>write</FUNCTION> be implemented directly in terms of
      <FUNCTION>write-element</FUNCTION>; it might be implemented more
      efficiently, especially for buffered streams.</PARA>

      <PARA>Some streams are positionable; that is, they permit random
      access to their elements. Postionable streams allow you to set
      the position at which the stream will be accessed by the next
      operation. The following example uses positioning to return the
      character <LITERAL>'w'</LITERAL> from a stream over the string
      <LITERAL>"hello world"</LITERAL>:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, contents: "hello world");
stream-position(stream) := 6;
read-element(stream);</PROGRAMLISTING>
      
      <PARA>The following example returns a string, but the contents
      of the first ten characters are undefined:</PARA>

      <PROGRAMLISTING>
let stream = make(&lt;string-stream&gt;, direction: #"output");
adjust-stream-position(stream, 10); 
write(stream, "whoa!");
stream-contents(stream);</PROGRAMLISTING>
      
      <PARA>You can request a sequence containing all of the elements
      of a positionable stream by calling
      <FUNCTION>stream-contents</FUNCTION> on it. The sequence
      returned never shares structure with any underlying sequence
      that might be used in future by the stream. For instance, the
      string returned by calling <FUNCTION>stream-contents</FUNCTION>
      on an output <CLASSNAME>&lt;string-stream&gt;</CLASSNAME> will
      not be the same string as that being used to represent the
      string stream.</PARA>

      <PARA>When making an input &lt;string-stream&gt;, you can cause
      the stream to produce elements from any subsequence of the
      supplied string. For example:</PARA>

      <PROGRAMLISTING>
read-to-end(make(&lt;string-stream&gt;, 
                 contents: "hello there, world",
                 start: 6, 
                 end: 11));</PROGRAMLISTING>

      <PARA>This example evaluates to "there". The interval (start,
      end) includes the index start but excludes the index end. This
      is consistent with standard Dylan functions over sequences, such
      as copy-sequence. The read-to-end function is one of a number of
      convenient utility functions for operating on streams and
      returns all the elements up to the end of the stream from the
      stream's current position.</PARA>
    </SECT1>

    <SECT1>
      <TITLE>Streams, growing sequences, and object identity</TITLE>

      <PARA>When writing to output streams over sequences, Dylan may
      from time to time need to grow the underlying sequence that it
      is using to represent the stream data. </PARA>

      <PARA>Consider the example of an output stream instantiated over
      an empty string. As soon as a write operation is performed on
      the stream, it is necessary to replace the string object used in
      the representation of the string stream. As well as incurring
      the cost of creating a new string, the replacement operation can
      affect the integrity of other references to the string within
      the program. </PARA>

      <PARA>To guarantee that alias references to a sequence used in
      an output <CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME> will
      have access to any elements written to the sequence via the
      stream, supply a <CLASSNAME>&lt;stretchy-vector&gt;</CLASSNAME>
      to make. A stream over a stretchy vector will use the same
      stretchy vector throughout the stream's existence. </PARA>

      <PARA>For example:</PARA>

      <PROGRAMLISTING>
let sv = make(&lt;stretchy-vector&gt;);
let stream = make(&lt;sequence-stream&gt;, 
                  contents: sv, 
                  direction: #"output");
write(stream, #(1, 2, 3, 4, 5, 6, 7, 8, 9));
write(stream, "ABCDEF");
values(sv, stream-contents(stream));</PROGRAMLISTING>

      <PARA>The example returns two values. Each value is the same
      (<LITERAL>\==</LITERAL>) stretchy vector:</PARA>

      <PROGRAMLISTING>
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F']</PROGRAMLISTING>

      <PARA>If a stretchy vector is not supplied, the result is
      different: </PARA>

      <PROGRAMLISTING>
let v = make(&lt;vector&gt;, size: 5);
let stream = make(&lt;sequence-stream&gt;,
                  contents: v, 
                  direction: #"output");
write(stream, #(1, 2, 3, 4, 5, 6, 7, 8, 9));
write(stream, "ABCDEF");
values(v, stream-contents(stream));</PROGRAMLISTING>

      <PARA>This example returns as its first value the original
      vector, whose contents are undefined, but the second value is a
      new vector:</PARA>

      <PROGRAMLISTING>
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F']</PROGRAMLISTING>

      <PARA>This difference arises because the output stream in the
      second example does not use a stretchy vector to hold the stream
      data. A vector of at least 15 elements is necessary to
      accommodate the elements written to the stream, but the vector
      supplied, <LITERAL>v</LITERAL>, can hold only 5. Since the
      stream cannot change <LITERAL>v</LITERAL>'s size, it must
      allocate a new vector each time it grows. </PARA>
    </SECT1>

    <SECT1>
      <TITLE>Stream classes</TITLE>

      <PARA>The exported streams class heterarchy is as follows:</PARA>

      <FIGURE>
	<TITLE>Streams library classes. </TITLE>
	<GRAPHIC></GRAPHIC>
      </FIGURE>

      <PARA>Except for the classes
      <CLASSNAME>&lt;stream&gt;</CLASSNAME>,
      <CLASSNAME>&lt;buffered-stream&gt;</CLASSNAME>, and
      <CLASSNAME>&lt;positionable-stream&gt;</CLASSNAME>, these are
      instantiable classes.</PARA>

      <SECT2>
	<TITLE>Class Reference</TITLE>
	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The superclass of all stream classes and a direct
	  subclass of <CLASSNAME>&lt;object&gt;</CLASSNAME>. It is not
	  instantiable.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;positionable-stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>A subclass of &lt;stream&gt; supporting the
	    Positionable Stream Protocol. It is not
	    instantiable.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;buffered-stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>A subclass of <CLASSNAME>&lt;stream&gt;</CLASSNAME>
	    supporting the Stream Extension Protocol and the Buffer
	    Access Protocol. It is not instantiable.</PARA>

	    <PARA>Streams of this class support the
	    <LITERAL>buffer-size:</LITERAL> init-keyword, which can be
	    used to suggest the size of the stream's buffer. However,
	    the instantiated stream might not use this value: it is
	    taken purely as a suggested value. For example, a stream
	    that uses a specific device's hardware buffer might use a
	    fixed buffer size regardless of the value passed with the
	    <LITERAL>buffer-size:</LITERAL> init-keyword. </PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;file-stream&gt;</REFNAME>
	    <REFPURPOSE>Open abstract class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over disk files.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>

	    <PARA><CLASSNAME>&lt;positionable-stream&gt;</CLASSNAME>,
	  <CLASSNAME>&lt;buffered-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>

	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><LITERAL>locator:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>direction:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>if-exists:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>if-does-not-exist:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>When you instantiate this class, an
	    implementation-dependent, indirect instance of it is
	    created. The file being streamed over is opened
	    immediately upon creating the stream. </PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;sequence-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over sequences. </PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;positionable-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><LITERAL>contents:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>direction:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>start:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>end:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Description</TITLE>

	    <PARA>The <CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME>
	    class can be used for streaming over all sequences, but
	    there are also subclasses
	    <CLASSNAME>&lt;string-stream&gt;</CLASSNAME>,
	    <CLASSNAME>&lt;byte-string-stream&gt;</CLASSNAME>, and
	    <CLASSNAME>&lt;unicode-string-stream&gt;</CLASSNAME>,
	    which are specialized for streaming over strings.</PARA>
	  </REFSECT1>
	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;string-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over strings.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;sequence-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><LITERAL>contents:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>direction:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>start:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>end:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>

	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;byte-string-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over byte strings.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;string-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><LITERAL>contents:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>direction:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>start:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>end:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>

	</REFENTRY>

	<REFENTRY>
	  <REFNAMEDIV>
	    <REFNAME>&lt;unicode-string-stream&gt;</REFNAME>
	    <REFPURPOSE>Open instantiable class</REFPURPOSE>
	  </REFNAMEDIV>
	  <REFSECT1>
	    <TITLE>Summary</TITLE>

	    <PARA>The class of streams over Unicode strings.</PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Superclasses</TITLE>
	    <PARA><CLASSNAME>&lt;string-stream&gt;</CLASSNAME></PARA>
	  </REFSECT1>
	  <REFSECT1>
	    <TITLE>Init-keywords</TITLE>
	    <VARIABLELIST>
	      <VARLISTENTRY>
		<TERM><LITERAL>contents:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>direction:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>start:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	      <VARLISTENTRY>
		<TERM><LITERAL>end:</LITERAL></TERM>
		<LISTITEM>
		  <PARA></PARA>
		</LISTITEM>
	      </VARLISTENTRY>
	    </VARIABLELIST>
	  </REFSECT1>
	</REFENTRY>
      </SECT2>
      
      <SECT2>
	<TITLE>Creating streams</TITLE>

	<PARA>The following functions are used to create streams.</PARA>

	<SECT3>
	  <TITLE>File streams </TITLE>

	  <PARA>File streams are intended only for accessing the
	  contents of files. They are not intended to provide a
	  general file handling facility of renaming, deleting,
	  moving, parsing directory names and so on.</PARA>

	  <REFENTRY>
	    <REFNAMEDIV>
	      <REFNAME>make
	      <REPLACEABLE>file-stream-class</REPLACEABLE></REFNAME>
	      <REFPURPOSE>General function method</REFPURPOSE>
	    </REFNAMEDIV>
	    <REFSECT1>
	      <TITLE>Summary</TITLE>

	      <PARA>Creates and opens a stream over a file.</PARA>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Signature</TITLE>

	      <SYNOPSIS><FUNCTION>make</FUNCTION> file-stream-class <LITERAL>#key</LITERAL> <PARAMETER>locator</PARAMETER> <PARAMETER>direction</PARAMETER> <PARAMETER>if-exists</PARAMETER> <PARAMETER>if-does-not-exist</PARAMETER> <PARAMETER>buffer-size</PARAMETER> <PARAMETER>element-type</PARAMETER> <PARAMETER>encoding</PARAMETER> 
=&gt; <PARAMETER>file-stream-instance</PARAMETER> 
</SYNOPSIS>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Description</TITLE>

	      <PARA>Returns a new instance of a concrete subclass of
	      <CLASSNAME>&lt;file-stream&gt;</CLASSNAME> that streams
	      over the contents of the file referenced by locator. To
	      determine the concrete subclass to be instantiated, this
	      method calls the generic function
	      <FUNCTION>type-for-file-stream</FUNCTION> (see FIXME).</PARA>

	      <PARA>The <REPLACEABLE>file-stream-class</REPLACEABLE>
	      argument is the class
	      <CLASSNAME>&lt;file-stream&gt;</CLASSNAME>.</PARA>

	      <PARA>The <LITERAL>locator:</LITERAL> init-keyword
	      should be a string naming a file. If the Locators
	      library is in use, locator should be an instance of
	      <CLASSNAME>&lt;locator&gt;</CLASSNAME> or a string that
	      can be coerced to one.</PARA>

	      <PARA>The <LITERAL>direction:</LITERAL> init-keyword
	      specifies the direction of the stream.</PARA>

	      <PARA>The <LITERAL>if-exists:</LITERAL> and
	      <LITERAL>if-does-not-exist:</LITERAL> init-keywords
	      specify actions to take if the file named by locator
	      does or does not already exist when the stream is
	      created. These init-keywords are discussed in more
	      detail in FIXME.</PARA>

	      <PARA>The <LITERAL>buffer-size:</LITERAL> init-keyword
	      is explained in &lt;buffered-stream&gt; FIXME.</PARA>

	      <PARA>The <LITERAL>element-type</LITERAL> init-keyword
	      specifies the type of the elements in the file named by
	      locator. This allows file elements to be represented
	      abstractly; for instance, contiguous elements could be
	      treated as a single database record. This init-keyword
	      defaults to something useful, potentially based on the
	      properties of the file;
	      <CLASSNAME>&lt;byte-character&gt;</CLASSNAME> and
	      <CLASSNAME>&lt;unicode-character&gt;</CLASSNAME> are
	      likely choices. See FIXME.</PARA>
	    </REFSECT1>
	  </REFENTRY>

	  <REFENTRY>
	    <REFNAMEDIV>
	      <REFNAME>type-for-file-stream</REFNAME>
	      <REFPURPOSE>Open generic function</REFPURPOSE>
	    </REFNAMEDIV>
	    <REFSECT1>
	      <TITLE>Summary</TITLE>

	      <PARA>Returns the kind of file-stream class to
	      instantiate for a given file.</PARA>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Signature</TITLE>

	      <SYNOPSIS><FUNCTION>type-for-file-stream</FUNCTION>
	      <PARAMETER>locator</PARAMETER>
	      <PARAMETER>element-type</PARAMETER>
	      <LITERAL>#rest</LITERAL> <PARAMETER>all-keys</PARAMETER>
	      =&gt; <PARAMETER>file-stream-type</PARAMETER></SYNOPSIS>
	    </REFSECT1>
	    <REFSECT1>
	      <TITLE>Description</TITLE>

	      <PARA>The method for make on
	      <CLASSNAME>&lt;file-stream&gt;</CLASSNAME> calls this
	      function to determine the class of which it should
	      create an instance.</PARA>
	    </REFSECT1>
	  </REFENTRY>
	</SECT3>

	<SECT3>
	  <TITLE>Options when creating file streams</TITLE>

	  <PARA>When creating file streams, you can can supply the
	  following init-keywords to <FUNCTION>make</FUNCTION> in
	  addition to the usual direction: </PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><LITERAL>if-exists:</LITERAL></TERM>
	      <LISTITEM>
		<PARA>An action to take if the file already exists.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>if-does-not-exist:</LITERAL></TERM>
	      <LISTITEM>
		<PARA>An action to take if the file does not already
		exist.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>

	    <VARLISTENTRY>
	      <TERM><LITERAL>element-type:</LITERAL></TERM>
	      <LISTITEM>
		<PARA>How the elements of the underlying file are
		accessed.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <PARA>The <LITERAL>if-exists:</LITERAL> init-keyword allows
	  you to specify an action to take if the file named by
	  <PARAMETER>locator</PARAMETER> already exists. The options
	  are:</PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#f</LITERAL></TERM>
	      <LISTITEM>
		<PARA>No action. This is the default when the stream's
		direction is <LITERAL>#"input"</LITERAL> or
		<LITERAL>#"input-output"</LITERAL>.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"new-version"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>If the underlying file system supports file
		versioning, a new version of the file is created. This
		is the default when the stream's direction is
		<LITERAL>#"output"</LITERAL>.</PARA>

		<PARA>If the file system does not support file
		versioning, the implementation should substitute one
		of the other <LITERAL>if-exists:</LITERAL> behaviors;
		the <LITERAL>#"replace"</LITERAL> behavior is a good
		choice. </PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"overwrite"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>Set the stream's position to the beginning of
		the file, but preserve the current contents of the
		file. This is useful when the direction is
		<LITERAL>#"input-output"</LITERAL> and you want to
		overwrite an existing file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"replace"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>Delete or rename the existing file and create a
		new file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"append"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>Set the stream's initial position to the end of
		the existing file so that all new output occurs at the
		end of the file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"truncate"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>If the file exists, it is truncated, setting the
		size of the file to 0. If the file does not exist,
		create a new file.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"signal"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>Signal a
		<CLASSNAME>&lt;file-exists-error&gt;</CLASSNAME>
		condition. </PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <PARA>The <LITERAL>if-does-not-exist:</LITERAL> init-keyword
	  allows you to specify an action to take if the file named by
	  <PARAMETER>locator</PARAMETER> does not exist. The options
	  are:</PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#f</LITERAL></TERM>
	      <LISTITEM>
		<PARA>No action.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"signal"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>Signal a
		<CLASSNAME>&lt;file-does-not-exist-error&gt;</CLASSNAME>
		condition. This is the default when the stream's
		direction is <LITERAL>#"input"</LITERAL>.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><LITERAL>#"create"</LITERAL></TERM>
	      <LISTITEM>
		<PARA>Create a new zero-length file. This is the
		default when the stream's direction is
		<LITERAL>#"output"</LITERAL> or
		<LITERAL>#"input-output"</LITERAL>.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <PARA>Because creating a file stream always involves an
	  attempt to open the underlying file, the aforementioned
	  error conditions will occur during file stream instance
	  initialization.</PARA>

	  <PARA>If an implementation checks file permissions when
	  creating and opening file streams, and it detects an attempt
	  to read a file for which the user has no read permission, or
	  to write a file for which the user has no write permission,
	  then an
	  <CLASSNAME>&lt;invalid-file-permissions-error&gt;</CLASSNAME>
	  condition is signalled at the time the file stream is
	  created.</PARA>

	  <PARA>The <LITERAL>element-type:</LITERAL> init-keyword
	  controls how the elements of the underlying file are
	  accessed. </PARA>

	  <NOTE>
	    <TITLE>Implementation Note</TITLE>

	    <PARA>Ideally, element-type could be any valid Dylan type
	    such as <LITERAL>limited(&lt;integer&gt;, min: 0, max:
	    255)</LITERAL> or
	    <CLASSNAME>&lt;unicode-character&gt;</CLASSNAME>. This
	    approach may make it possible to implement a potentially
	    inefficient but general set of file streams. Unfortunately
	    the current language definition does not include adequate
	    support for this approach, so we specify instead an
	    interim minimum set of three element types. The element
	    types are for the time being exported from the streams
	    module of the Streams library.</PARA>
	  </NOTE>

	  <PARA>The three possible element types are: </PARA>

	  <VARIABLELIST>
	    <VARLISTENTRY>
	      <TERM><CLASSNAME>&lt;byte-character&gt;</CLASSNAME></TERM>
	      <LISTITEM>
		<PARA>The file is accessed as a sequence of 8-bit
		  characters.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><CLASSNAME>&lt;unicode-character&gt;</CLASSNAME></TERM>
	      <LISTITEM>
		<PARA>The file is accessed as a sequence of 16-bit Unicode
		  characters.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	    <VARLISTENTRY>
	      <TERM><CLASSNAME>&lt;byte&gt;</CLASSNAME></TERM>
	      <LISTITEM>
		<PARA>The file is accessed as a sequence of unsigned 8-bit
		  integers.</PARA>
	      </LISTITEM>
	    </VARLISTENTRY>
	  </VARIABLELIST>

	  <NOTE>
	    <TITLE>Portability Note</TITLE>

	    <PARA>Portable code can count on the existence of these
	    three element types, but implementations are free to
	    provide more. </PARA>
	  </NOTE>
	</SECT3>
      </SECT2>
    </SECT1>


  </CHAPTER>

  <CHAPTER>
    <TITLE>The Standard-IO Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Format Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Format-Out Library</TITLE>

    <PARA>The Format-Out library is designed to provide a simple
    interface to the Format library. It exports the module Format-Out
    and re-exports the Format and Standard-IO modules from the Format
    and Standard-IO libraries respectively. The Format-Out module
    exports one function <FUNCTION>format-out</FUNCTION>.</PARA>
    

    <REFENTRY>
      <REFNAMEDIV>
	<REFNAME>format-out</REFNAME>
	<REFPURPOSE>Function</REFPURPOSE>
      </REFNAMEDIV>
      <REFSECT1>
	<TITLE>Summary</TITLE>
	<PARA>Formats arguments to <LITERAL>*standard-output*</LITERAL>.</PARA>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Signature</TITLE>
	<SYNOPSIS><FUNCTION>format-out</FUNCTION> <PARAMETER>control-string</PARAMETER> <LITERAL>#key</LITERAL> <PARAMETER>args</PARAMETER> => </SYNOPSIS>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Arguments</TITLE>
	<VARIABLELIST>
	  <VARLISTENTRY>
	    <TERM><PARAMETER>control-string</PARAMETER></TERM>
	    <LISTITEM>
	      <PARA>An instance of
	      <CLASSNAME>&lt;byte-string&gt;</CLASSNAME>.</PARA>
	    </LISTITEM>
	  </VARLISTENTRY>
	  <VARLISTENTRY>
	    <TERM><PARAMETER>args</PARAMETER></TERM>
	    <LISTITEM>
	      <PARA>Instances of <CLASSNAME>&lt;object&gt;</CLASSNAME></PARA>
	    </LISTITEM>
	  </VARLISTENTRY>
	</VARIABLELIST>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Values</TITLE>
	<PARA>None</PARA>
      </REFSECT1>
      <REFSECT1>
	<TITLE>Description</TITLE>
	<PARA>Performs</PARA>
	<PROGRAMLISTING>
apply(format, *standard-output*, control-string, args);</PROGRAMLISTING>
      </REFSECT1>
    </REFENTRY>

    

<!--
    The Format-Out Library

	[Function]
Arguments


Values
none
Description
This function calls format(*standard-output*, control-string, args);

-->
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Print Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Collection-Extensions Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Table-Extensions Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The String-Extensions Library</TITLE>

    <PARA></PARA>
  </CHAPTER>
  
  <CHAPTER>
    <TITLE>The Regular-Expressions Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Transcendental Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Time Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The Random Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

   <CHAPTER>
    <TITLE>The Matrix Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

  <CHAPTER>
    <TITLE>The TK Library</TITLE>

    <PARA></PARA>
  </CHAPTER>

 
  
</BOOK>
