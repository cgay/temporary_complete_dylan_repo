#!/usr/local/bin/perl

$#ARGV >= 1 && die "Usage: $0 [directory]\n";
$#ARGV >= 0 && (chdir($ARGV[0]) || die "Can't cd to $ARGV[0]: $!\n");

# Find the current directory.
chop($cwd = `pwd`);

# Set the default defaults.

$D2CDIR = '/afs/cs/project/gwydion/compiler';
$D2C = '$(D2CDIR)/bin/d2c';
$D2CFLAGS = '-L$(D2CDIR)/lib';
$CFLAGS = '-g';
$CPPFLAGS = '-I$(D2CDIR)/include';
$MELANGE = 'melange';
$PARSERGEN = 'parsergen';

# Find the defaults
$subdir = '';
$buildroot = $cwd;

# Change //d/path into d:/path on NT.  Only a problem on drives other
# than C:.  (We can't conditionalize this on $win32, because that
# variable is set by the Defaults file, which we're trying to locate)
$buildroot =~ s|^//(\w)/|\1:/|;

until (-e ($defaults = $buildroot . '/Defaults')) {
    ($buildroot =~ /^(.*)\/([^\/]+)$/)
      || die("Can't find Defaults and hence can't tell where the root is.\n");

    $subdir = $2 . '/' . $subdir;
    $buildroot = $1;
}

# Save the buildroot.
$orig_buildroot = $buildroot;

# Slurp in the defaults.
# This is also where the user will define $win32, if applicable, so
# make sure no win32-specific stuff comes before this line.  
# Ditto for $nmake. 
do $defaults;
die("Problem loading $defaults:\n  $@\n") if $@;

if ($nmake) {
    $makefile = "Makefile";
} else {
    $makefile = "GNUmakefile"; 
    # I'm not sure that Unix can't also use "Makefile", but at the
    # very least this would cause confusion with people who have
    # GNUmakefile's lying around.  So sticking with "GNUmakefile" is
    # the safer option.
}

if ($win32) {
    $obj = "obj";  # filename extension for object files
} else {
    $obj = "o";
}

# Check to see if buildroot changed to something else.
unless ($buildroot eq $orig_buildroot) {
    $root_inode = (stat($buildroot))[1];
    $orig_inode = (stat($orig_buildroot))[1];
    unless ($root_inode == $orig_inode) {
	die("Defaults changed \$buildroot to:\n  $buildroot\nbut that is a different directory than:\n  $orig_buildroot\n");
    }
    ($buildroot =~ /^\//)
	|| die("\$buildroot is not absolute:\n  $buildroot\n");
    $defaults = $buildroot . '/Defaults';
}

# Make sure they set srcroot.  And set it to an absolute pathname.
$srcroot || die('$srcroot not set in Defaults.\n');
($srcroot =~ /^(\w:)?\//) || die("\$srcroot is not absolute:\n  $srcroot\n");

# Tack the subdir onto srcroot.  Note: subdir is empty or ends with a /, hence
# the chop.
chop($srcdir = $srcroot.'/'.$subdir);

# Likewise for builddir
chop($builddir = $buildroot.'/'.$subdir);

# Find the Makegen file.
$makegen = $srcdir . '/Makegen';
(-e $makegen) || die("No $makegen\n");

# Start the makefile.
open(MAKEFILE, ">,$makefile") || die("Can't open ,$makefile: $!\n");
select(MAKEFILE);

print "### This makefile is machine generated.  Don't expect any edits to survive.\n\n";
if ($nmake) {
    $srcroot =~ tr|/|\\|;  # translate / to \ for MS-Windows
    $srcdir =~ tr|/|\\|;
    $buildroot =~ tr|/|\\|;
    $builddir =~ tr|/|\\|;
}
print "SRCROOT=$srcroot\n";
print "SRCDIR=$srcdir\n";
print 'VPATH=$(SRCDIR)' . "\n";
print "BUILDROOT=$buildroot\n";
print "BUILDDIR=$builddir\n";
$destdir && print "DESTDIR=$destdir\n";
if (! $nmake) {
    print "\n.PHONY: default compile install clean\n\n";
    # Microsoft nmake doesn't do .phony targets
}
print "default: compile\n\n";

# Slurp in the generator.
do $makegen;
die("Problem loading $makegen:\n  $@\n") if $@;

if (@files_to_clean) {
    push(@clean_commands, "-rm -f @files_to_clean");
}

push(@GNUmakefile_dependencies, $0, $defaults, $makegen);
push(@GNUmakefile_commands, $0);

do emit_rule ('compile');
$destdir && do emit_rule ('install');
do emit_rule ('clean');
if (! $nmake) {
    do emit_rule($makefile);
    # Microsoft nmake doesn't like Makefile as a target...
}

close(MAKEFILE);
rename(",$makefile", $makefile);

sub emit_rule {
    local($rule) = @_;

    print $rule, ': ', join(' ', eval('@'.$rule.'_dependencies')), "\n";
    foreach $rule (eval('@'.$rule.'_commands')) {
	if ($newlines_are_crlf) {
	    $rule =~ s|cat\s+(.*)>(.*)|dbclink \2 \1|;
	    # This kluge replaces the "cat *.dbc > lib.dbc" idiom with
	    # dbclink.
	}
	print "\t", $rule, "\n";
    }
    print "\n";
}


sub compile_subdirs {
    local($dir);
    foreach $dir (@_) {
	do compile_subdir($dir);
    }
}

sub compile_subdir {
    local($subdir) = @_;

    # Recursive makes with Microsoft nmake are rather painful.  (If
    # GNU make for NT is used, this is actually wrong, but gmake/NT
    # has other problems and shouldn't be used)
    if ($nmake) {
	push(@compile_commands, 
	     'cmd /c "cd ' . $subdir . ' && $(MAKE) /nologo"');
	push(@install_commands,
	     'cmd /c "cd ' . $subdir . ' && $(MAKE) /nologo install"');
	push(@clean_commands,
	     'cmd /c "cd ' . $subdir . ' && $(MAKE) /nologo clean"');
    } else {
	push(@compile_commands, '$(MAKE) -C ' . $subdir);
	push(@install_commands, '$(MAKE) -C ' . $subdir . ' install');
	push(@clean_commands, '$(MAKE) -C ' . $subdir . ' clean');
    }
}

sub maybe_emit_d2c_defines {
    unless ($d2c_defines) {
	if ($CC) {
	    print("CC=$CC\n");
	}
	print <<EOF;
D2CDIR=$D2CDIR
D2C=$D2C
D2CFLAGS=$D2CFLAGS
CFLAGS=$CFLAGS
CPPFLAGS=$CPPFLAGS
MELANGE=$MELANGE
PARSERGEN=$PARSERGEN

EOF
        if (! $nmake) {
	    # This has no real equivalent in nmake (and maybe in win32), 
	    # so don't expect to be able to change the CCFLAGS.
	    print "export CCFLAGS = \$(CFLAGS) \$(CPPFLAGS)\n\n";
	}
	$d2c_defines = 1;
    }
}

sub emit_library_rule {
    local($lidfile, $extradeps, $extraflags, @keywords) = @_;
    local($library, $unit_prefix, $executable);

    do maybe_emit_d2c_defines();

    open(LIDFILE, $srcdir.'/'.$lidfile.'.lid')
      || die("Can't open $lidfile.lid: $!\n");

    while (<LIDFILE>) {
	if (/^library:[ \t]*(.*)$/i) {
	    $library = $1;
	}
	elsif (/^unit-prefix:[ \t]*(.*)$/i) {
	    $unit_prefix = $1;
	}
	elsif (/^executable:[ \t]*(.*)$/i) {
	    if ($win32) {
		$executable = $1 . ".exe";
	    } else {
		$executable = $1;
	    }
	}
	elsif (/^$/) {
	    last;
	}
    }
    $library || die("No library: header in $lidfile.lid.\n");
    $unit_prefix || ($unit_prefix = "\L$library\E");

    while (<LIDFILE>) {
	/\n$/ && chop;
	s/[ \t]*#.*$//;
	unless (/^$/) {
	    s/\.dylan$//;
	    push(@files_to_clean, $_.'.c', $_ . ".$obj");
	}
    }

    push(@files_to_clean, "$unit_prefix-init.c", "$unit_prefix-init.$obj");
    push(@files_to_clean, "$unit_prefix-heap.s", "$unit_prefix-heap.$obj");

    if ($executable) {
	push(@files_to_clean, $executable, 'heap.s', 'inits.c');

	grep(/^compile$/, @keywords)
	    && push(@compile_dependencies, $executable);

	grep(/^install$/, @keywords)
	    && do install('bin', $executable);

	print $executable;
    }
    else {
	local($foo_lib_du, $libfoo_a);

	$foo_lib_du = "\L$library\E.lib.du";
	$libfoo_a = &make_into_library_name($unit_prefix);

	push(@files_to_clean, $foo_lib_du, $libfoo_a);

	grep(/^compile$/, @keywords)
	    && ($win32
		? push(@compile_dependencies, $foo_lib_du)
		: push(@compile_dependencies, $foo_lib_du, $libfoo_a));

	# Under win32, we don't name libname.lib as a dependency
	# because nmake can't figure out how to build it (after all,
	# there's nothing that explicitly says that it is produced at
	# the same time as libname.lib.du)

	grep(/^install$/, @keywords)
	    && do install('lib', $foo_lib_du, $libfoo_a);

	print $foo_lib_du;
    }
    print ": $srcdir/$lidfile.lid $extradeps\n";
    print "\t\$(D2C) -M \$(D2CFLAGS) $extraflags $srcdir/$lidfile.lid\n";
    if ($delayed_binaries) {
	local ($make_name) = $nmake ? '$(MAKE) /nologo' : '$(MAKE)';
	print "\t$make_name -f cc-", $unit_prefix, "-files.mak\n";
    }
    print "\ninclude $unit_prefix.dep\n\n";

    unless (-e "$unit_prefix.dep") {
	open(DEP, ">$unit_prefix.dep")
	    || die("Can't create $unit_prefix.dep: $!\n");
	close(DEP);
    }
}

sub emit_c_file_rule {
    local ($basefile, @headers) = @_;
    local ($obj) = ($win32) ? ".obj" : ".o";
    local ($objfile) = $basefile . $obj;

    do maybe_emit_d2c_defines();

    print "$objfile: \$(SRCDIR)/$basefile.c";
    foreach $header (@headers) {
	print " \$(SRCDIR)/$header";
    }
    print "\n\t\$(CC) \$(CFLAGS) \$(CPPFLAGS) -I\$(SRCDIR) ";
    print "-c \$(SRCDIR)/$basefile.c -o $objfile\n\n";
    push(@compile_dependencies, $objfile);
    push(@files_to_clean, $objfile);
}

# Just like emit_c_file_rule, except uses .cc as an extension instead of .c
#
sub emit_cc_file_rule {
    local ($basefile, @headers) = @_;
    local ($obj) = ($win32) ? ".obj" : ".o";
    local ($objfile) = $basefile . $obj;

    do maybe_emit_d2c_defines();

    print "$objfile: \$(SRCDIR)/$basefile.cc";
    foreach $header (@headers) {
	print " \$(SRCDIR)/$header";
    }
    print "\n\t\$(CC) \$(CFLAGS) -I\$(SRCDIR) ";
    print "-c \$(SRCDIR)/$basefile.cc -o $objfile\n\n";
    push(@compile_dependencies, $objfile);
    push(@files_to_clean, $objfile);
}

sub emit_melange_rule {
    local ($basefile, @headers) = @_;
    do maybe_emit_d2c_defines();

    print "$basefile.dylan: \$(SRCDIR)/$basefile.intr";
    foreach $header (@headers) {
	print " \$(SRCDIR)/$header";
    }
    print "\n\t\$(MELANGE) -I\$(SRCDIR) ";
    print "\$(SRCDIR)/$basefile.intr $basefile.dylan\n\n";
    push(@compile_dependencies, "$basefile.dylan");
    push(@files_to_clean, "$basefile.dylan");
}

sub emit_parsergen_rule {
    local ($basefile) = @_;
    do maybe_emit_d2c_defines();

    print "$basefile.dylan: \$(SRCDIR)/$basefile.input";
    print "\n\t\$(PARSERGEN) ";
    print "\$(SRCDIR)/$basefile.input $basefile.dylan\n\n";
    push(@compile_dependencies, "$basefile.dylan");
    push(@files_to_clean, "$basefile.dylan");
}

sub install {
    local ($subdir, @files) = @_;
    local ($file, $dst);

    # Don't generate any install rules unless destdir is set.
    $destdir || return;

    foreach $file (@files) {
	$dst = "\$(DESTDIR)/$subdir/$file";

	print "$dst: $file\n";
	if ($win32) {
	    local ($rule) = "\tcopy $file $dst\n\n";
	    $rule =~ tr|/|\\|;  # translate / to \ for MS-Windows
	    print $rule;
	} else {
	    print "\t", '@-mv $@ $@.old', "\n";
	    print "\t", 'cp -p $< $@', "\n";
	    print "\t", '@rm -f $@.old', "\n";
	    print "\n";
	}

	push(@install_dependencies, $dst);
    }
}

sub install_from_src {
    local ($subdir, @files) = @_;
    local ($file, $dst);

    # Don't generate any install rules unless destdir is set.
    $destdir || return;

    foreach $file (@files) {
	$dst = "\$(DESTDIR)/$subdir/$file";

	print "$dst: $srcdir/$file\n";
	if ($win32) {
	    local ($rule) = "\tcopy $srcdir/$file $dst\n\n";
	    $rule =~ tr|/|\\|;  # translate / to \ for MS-Windows
	    print $rule;
	} else {
	    print "\t", '@-mv $@ $@.old', "\n";
	    print "\t", 'cp -p $< $@', "\n";
	    print "\t", '@rm -f $@.old', "\n";
	    print "\n";
	}

	push(@install_dependencies, $dst);
    }
}

# Like install_from_src, except makes sure the file has executable 
# permissions for everyone (this is not relevant on win32)
sub install_executable_from_src {
    local ($subdir, @files) = @_;
    local ($file, $dst);

    # Don't generate any install rules unless destdir is set.
    $destdir || return;

    foreach $file (@files) {
	$dst = "\$(DESTDIR)/$subdir/$file";

	print "$dst: $srcdir/$file\n";
	if ($win32) {
	    local ($rule) = "\tcopy $srcdir/$file $dst\n\n";
	    $rule =~ tr|/|\\|;  # translate / to \ for MS-Windows
	    print $rule;
	} else {
	    print "\t", '@-mv $@ $@.old', "\n";
	    print "\t", 'cp -p $< $@', "\n";
	    print "\t", '@rm -f $@.old', "\n";
	    print "\t", 'chmod a+x $@', "\n";
	    print "\n";
	}

	push(@install_dependencies, $dst);
    }
}


# Your normal compiler Makegen file should simply set $D2CFLAGS and
# $CPPFLAGS, then call this subroutine, and finally a emit_library_rule
sub d2c_library {
    local ($dylan_lib_name, $unit_prefix, $source_files) = @_;
    local ($ar_name) = &make_into_library_name($unit_prefix);
    local ($du_name);
    if ($dylan_lib_name eq "compiler-main") {  # hack...
	$du_name = "";
    } else {
	$du_name = "compiler-" . $unit_prefix . ".lib.du";
    }
    if ($stage2) {
	push(@compile_dependencies, "$du_name $ar_name");
    } else {
	push(@compile_dependencies, $unit_prefix . 'lib.dbc');
	push(@files_to_clean, '*.dbc');
	$D2C = 'mindy -f $(BUILDROOT)/compiler/main/d2c.dbc';
	if (! $nmake) {
	    print "\n.PHONY: d2c-compile\n\n";
	}
	print "d2c-compile: $du_name $ar_name\n\n";

	print "MC = mindycomp\n";
        print 'MINDYFLAGS = -l' . $dylan_lib_name . "\n";
	print "MINDY = mindy\n\n";

        do spew_dbc_rules($source_files);
	print "\n";

	print "OBJS = \\\n";   # That's OBJS = \
        print "\t", join(".dbc \\\n\t", split(/\s/, $source_files)), ".dbc\n";
	local($dbc_libname) = $unit_prefix . 'lib.dbc';
        print "\n$dbc_libname: \$(OBJS)\n";
        print "\t", &dbc_link_rule($dbc_libname, '$(OBJS)'), "\n";
    }
}

# Use global $srcdir for where to get sources
sub spew_dbc_rules {
    local($sources) = @_;
    local($source);
    foreach $source (split(/\s/, $sources)) {
	print "$source.dbc: $srcdir/$source.dylan\n";
	print "\t\$(MC) \$(MINDYFLAGS) ";
	print "-o $source.dbc $srcdir/$source.dylan\n\n";
    }
}

sub dbc_link_rule {
    local($libname, $objects) = @_;
    if ($newlines_are_crlf) {
	return "dbclink $libname $objects";
    } else {
	return "cat $objects > $libname";
    }
}

sub make_into_library_name {
    local($basename) = @_;
    if ($win32) {
	return "$basename.lib";
    } else {
	return "lib$basename.a";
    }
}

# makegen_include is include, except it correctly handles the case
# where the srcdir is not the same as the destdir (ie, it looks for the
# include file in the srcdir)
#
# There's a certain danger of variable capture with include_file, so
# don't use that variable in your included files.
sub makegen_include {
    local($include_file) =  @_;
    $include_file = $srcdir . '/' . $include_file;
    (-e $include_file) || die("No $include_file\n");
    push(@GNUmakefile_dependencies, $0, $include_file);
    # Convert \ back to /, because that's how "do" likes its filenames
    $include_file =~ tr|\\|/|;
    do $include_file;
}
