#
# Configuration variables
#

CC	?= cl /nologo ;
LINK	?= link /nologo ;

MKF	?= dylanmakefile.mkf ;

SUFOBJ	?= .obj ;		# object files suffix
SUFDLL	?= .dll ;		# shared library suffix
SUFLIB	?= .lib ;		# import library suffix
SUFEXE	?= .exe ;		# executable suffix

# SYSTEM_ROOT is set by the build-system
SYSTEM_LIBDIR ?= $(SYSTEM_ROOT)/lib ;
SYSTEM_BINDIR ?= $(SYSTEM_ROOT)/bin ;

# PERSONAL_ROOT is set by the build-system
PERSONAL_LIBDIR ?= $(PERSONAL_ROOT)/lib ;
PERSONAL_BINDIR ?= $(PERSONAL_ROOT)/bin ;

LINKFLAGS ?= /NODEFAULTLIB 
	     /INCREMENTAL:NO /DEBUG:FULL /DEBUGTYPE:CV /PDB:NONE ;

#
# Runtime
#

rtlibs	?= mincrt.lib pentium-run-time.lib mmdw.lib mpsplinth.lib ;

libcmt	?= msvcrt.lib ;

guilflags ?= /RELEASE /subsystem:windows,4.0 ;

guilibsmt ?= wsock32.lib advapi32.lib user32.lib gdi32.lib comdlg32.lib 
             winspool.lib ;

olelibsmt ?= ole32.lib uuid.lib oleaut32.lib $(guilibsmt) ;

comctl32 ?= comctl32.lib ;

ole32	?= ole32.lib ;

#
# Jambase
#
include $(SYSTEM_LIBDIR)/mini-jambase.jam ;

#
# Pseudo-targets
#

NotFile all lib dll exe unify-dll unify-exe release dirs clean clean-all ;
Always clean clean-all ;

#
# Rules called from jam-build
#

# In each of the following rules, $(image[1]) contains the name from
# the Library: header, and $(image[2]) contains the name from
# the Executable: header (if present).

rule DylanLibrary image : version {
  # DylanLibrary image : version ;
  #Echo DylanLibrary $(image) ":" $(version) ;

  # Link a Dylan library as a shared library or executable image.

  local _dll = [ FDLLName $(image) ] ;
  local _lib = [ FLIBName $(image) ] ;
  local _exe = [ FEXEName $(image) ] ;

  # Here we save the name of the DLL and import lib for this library.
  
  _dll_$(image[1]) = $(_dll) ;
  _lib_$(image[1]) = $(_lib) ;

  # Shared libraries and executable images

  MakeLocate $(_dll) : $(PERSONAL_BINDIR) ;
  MakeLocate $(_lib) : $(PERSONAL_LIBDIR) ;
  MakeLocate $(_exe) : $(PERSONAL_BINDIR) ;

  # We'll use the library name as the grist to identify referenced
  # source and object files.
  
  SOURCE_GRIST = $(image[1]) ;

  # The executable depends only on _main.o and the DLL.

  local _obj = [ FGristFiles _main$(SUFOBJ) ] ;
  SEARCH on $(_obj) = $(SEARCH_SOURCE) ;

  Depends $(_exe) : $(_dll) ;
  LINKLIBS on $(_exe) += -l$(image[1]) ;
  LinkEXE $(_exe) : $(_obj) ;

  # If this is the top-level project, make the dll, exe, and clean
  # targets depend on its build products.
  
  if ! $(PARENT) {
    Depends dll : $(_dll) ;
    Depends lib : $(_lib) ;
    Depends exe : $(_exe) ;

    Clean clean : $(_dll) $(_lib) $(_exe) $(_obj) ;
  }
  Clean clean-all : $(_dll) $(_lib) $(_exe) $(_obj) ;

  # Mark the library version

  VERSION on $(_dll) ?= $(version:J=.) ;
  VERSION on $(_exe) ?= $(version:J=.) ;

  # Determine the entry points
  local _mangled = [ DFMCMangle $(image[1]) ] ;
  ENTRY on $(_dll) ?= $(_mangled)Dll@12 ;
  ENTRY on $(_exe) ?= $(_mangled)Exe ;
}

rule DylanLibraryFiles image : files {
  # DylanLibraryFiles image : files ;
  #Echo DylanLibraryFiles $(image) ":" $(files) ;

  # Link Dylan-derived object files into the resulting shared library.
  
  local _dll = [ FDLLName $(image) ] ;

  local _obj = [ FGristFiles _glue$(SUFOBJ) $(files:S=$(SUFOBJ)) ] ;
  local _el  = [ FGristFiles $(files:S=.el) ] ;
  SEARCH on $(_obj) $(_el) = $(SEARCH_SOURCE) ;

  if ! $(PARENT) {
    Clean clean : $(_obj) $(_el) ;
  }
  Clean clean-all : $(_obj) $(_el) ;

  LinkDLL $(_dll) : $(_obj) ;
}

rule DylanLibraryLinkerOptions image : options {
  # DylanLibraryLinkerOptions image : options ;
  #Echo DylanLibraryLinkerOptions $(image) ":" $(options) ;

  # Add the given options to the link command line of the shared library
  # and executable images.

  local _dll = [ FDLLName $(image) ] ;
  local _exe = [ FEXEName $(image) ] ;

  LINKLIBS on $(_dll) += $(options) ;
  LINKLIBS on $(_exe) += $(options) ;
}

rule DylanLibraryBaseAddress image : address {
  # DylanLibraryBaseAddress image : address ;
  #Echo DylanLibraryBaseAddress $(image) ":" $(address) ;

  # Set the base address of the shared library.
  
  local _dll = [ FDLLName $(image) ] ;
  BASE on $(_dll) ?= $(address) ;
}

rule DylanLibraryCLibraries image : libraries {
  # DylanLibraryCLibraries image : libraries ;
  #Echo DylanLibraryCLibraries $(image) ":" $(libraries) ;

  # Link C (or other externally-derived) libraries into the shared library.
  
  local _dll = [ FDLLName $(image) ] ;

  for lib in $(libraries) {
    switch $(lib) {
      case -L* : LINKLIBS on $(_dll) += $(lib) ;
      case -l* : LINKLIBS on $(_dll) += $(lib) ;
      case *.a : lib = [ FGristFiles $(lib) ] ;
		 SEARCH on $(lib) = $(SEARCH_SOURCE) ;
		 Depends $(_dll) : $(lib) ;
		 NEEDLIBS on $(_dll) += $(lib) ;
      case * :   Exit Unknown C library $(lib) ;
    }
  }
}

rule DylanLibraryCObjects image : objects {
  # DylanLibraryCObjects image : objects ;
  #Echo DylanLibraryCObjects $(image) ":" $(objects) ;

  # Link C (or other externally-derived) object files into the shared library.
  
  local _dll = [ FDLLName $(image) ] ;
  SEARCH on $(objects) = $(SEARCH_SOURCE) ;
  LinkDLL $(_dll) : $(objects) ;
}

rule DylanLibraryCSources image : sources {
  # DylanLibraryCSources image : sources ;
  #Echo DylanLibraryCSources $(image) ":" $(sources) ;

  # Link C source files into the shared library.

  Exit DylanLibraryCSources $(image) is not yet implemented ;
}

rule DylanLibraryCHeaders image : headers {
  # DylanLibraryCHeaders image : headers ;
  #Echo DylanLibraryCHeaders $(image) ":" $(headers) ;

  # Mark the shared library as depending on the given header files.
  # TODO: The original build-system didn't do anything with this either.

  Echo Ignoring DylanLibraryCHeaders $(image) ":" $(headers) ;
}

rule DylanLibraryRCFiles image : rcfiles {
  # DylanLibraryRCFiles image : rcfiles ;
  #Echo DylanLibraryRCFiles $(image) ":" $(rcfiles) ;
  
  # Link Win32 resource files into the shared library and executable.
  
  Echo Ignoring RC file(s) $(rcfiles) ;
}

rule DylanLibraryJamIncludes image : includes {
  # DylanLibraryJamIncludes image : includes ;
  
  Echo Ignoring Jam include file(s) $(includes) ;
}

rule DylanLibraryUses image : library : dir {
  # DylanLibraryUses image : library : dir ;
  #Echo DylanLibraryUses $(image) ":" $(library) ":" $(dir) ;

  # Link other Dylan libraries into the shared library.
  
  local _dll = [ FDLLName $(image) ] ;

  LINKLIBS on $(_dll) += -l$(library) ;

  if $(_dll_$(library)) {
    # We already know the DLL name; add the dependency.
    
    Depends $(_dll) : $(_dll_$(library)) ;
  } else if $(dir) = system {
    # This is a system library; guess at the DLL name.
    # TODO: read $(SYSTEM_LIBDIR)/$(library).mkf
    
    local _system_dll = [ FDLLName $(library) ] ;
    MakeLocate $(_system_dll) : $(SYSTEM_LIBDIR) ;
    Depends $(_dll) : $(_system_dll) ;
  } else {
    # Another personal library; read its mkf.
    
    local PARENT = $(image[1]) ;

    local SEARCH_SOURCE LOCATE_SOURCE LOCATE_TARGET = $(dir) ;
    local SOURCE_GRIST ;

    local _mkf = $(MKF:G=$(library)) ;
    SEARCH on $(_mkf) ?= $(SEARCH_SOURCE) ;
    IncludeMKF $(_mkf) ;

    # Now that we know the DLL name of $(library), add the dependency.

    Depends $(_dll) : $(_dll_$(library)) ;
  }
}

#
# Build rules and actions
#

rule LinkDLL {
  Depends $(<) : $(>) ;
}

actions together LinkDLL bind NEEDLIBS {
  $(LINK) /DLL /OUT:"$(<[1])" /IMPLIB:"$(<[2])" $(LINKFLAGS) /BASE:$(BASE) /VERSION:$(VERSION) /ENTRY:$(ENTRY) "$(>)" $(NEEDLIBS) $(LINKLIBS)
}

rule LinkEXE {
  Depends $(<) : $(>) ;
}

actions LinkEXE bind NEEDLIBS {
  $(LINK) /RELEASE /OUT:"$(<[1])" /SUBSYSTEM:CONSOLE,4.0 $(LINKFLAGS) /VERSION:$(VERSION) /ENTRY:$(ENTRY) "$(>)" $(NEEDLIBS) $(LINKLIBS)
}

#
# Utility rules
#

rule FDLLName {
  if $(<[2]) {
    return $(<[2]:S=$(SUFDLL)) ;
  } else
    return $(<[1]:S=$(SUFDLL)) ;
  }
}

rule FLIBName {
  if $(<[2]) {
    return $(<[2]:S=$(SUFLIB)) ;
  } else
    return $(<[1]:S=$(SUFLIB)) ;
  }
}

rule FEXEName {
  if $(<[2]) {
    return $(<[2]:S=$(SUFEXE)) ;
  } else
    return $(<[1]:S=$(SUFEXE)) ;
  }
}
