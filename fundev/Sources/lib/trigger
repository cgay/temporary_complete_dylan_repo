#!/usr/local/bin/perl
#
# Id      : $Id: trigger,v 1.1 2004/03/12 00:08:39 cgay Exp $
# HopeName: $HopeName: D-lib/!trigger(unknown)$
#
# This trigger breaks out the arguments which HOPE passes it, and sends
# mail to a set of people to announce changes (add, remove, checkin, etc.);
# it is a very stripped-down version of the EP/SW trigger.
#
# In lieu of the EP/SW "lurktabs" mechanism, people are encouraged to edit
# the subroutine '&mailRecipients' to filter messages which they don't
# want. See the comments near that subroutine for details.
########################################################################

$startTime = time;
$; = "\0";                   # for assoc. array trees

$user = shift(@ARGV);        # pluck out the rigid trigger arguments
$dir = shift(@ARGV);
$clientDir = shift(@ARGV);
$phase = shift(@ARGV);
$cmd = shift(@ARGV);

# first, let's bail out fast if this is something we know we don't care about
exit 0 if ($phase eq 'pre');
exit 0 if ($cmd ne 'checkin' && $cmd ne 'add' && $cmd ne 'remove' &&
	   $cmd ne 'branch' && $cmd ne 'checkpoint' && $cmd ne 'set' &&
           $cmd ne 'move');

# and now let's figure out what we have to do:
%args = &decodeArgs($cmd, @ARGV);
@comps = ();
while (($key, $val) = each(%args)) {
   push (@comps, $val) if ($key =~ /compound/);
}

# Uncomment the following to restart mail shots
# $mailAction = join ('', '<MAIL ', &mailRecipients($cmd, @compounds), '>');
# &execLurkAct($user, $cmd, 'hope-hackers', $mailAction, 
#              &inputString($user,$cmd,*args));

#dbg print LOG "exiting okay, I think\n";
#dbg print LOG "times: " . join (', ', time - $startTime, times) . "\n";
# we did it, we're done, everything's fine: exit successfully
&exitOk;


#########################################################################
#                  Subroutines are below this point                     #
#########################################################################

###################################
# mailRecipients exists to decide whom we want to send mail to for a given
#   event.  It should return a well-formatted mail destination, and
#   probably should use usernames rather than lists: "freeland, johnk"
#   instead of "hope-hackers".  That way people who don't want the mail can
#   easily negate themselves from the list.
#
#   Input to mailRecipients consists of the name of the HOPE command being
#   run (i.e. 'checkin', 'add', etc.) and the list of all compounds
#   directly affected (note: people just have to Zen the indirect
#   effects!).  The basic logic assumes that hope-hackers wants all mail;
#   people should add special-case code to remove the mail they don't want.
sub mailRecipients {
   local ($hopeCmd, @compounds) = @_;
   local (@mailTo);

   @mailTo = grep (($_) = /^(.*)@/, 
                  split("\n", `/usr/lib/sendmail -bv 'eliot'`));

   ###########
   # @mailTo now has all members of hope-hackers
   # insert filters to trim that down here:
   #   eg.   if ($cmd eq 'set' && !grep(/^HOPE$/, @compounds)) {
   #            # freeland doesn't care about set, except on the HOPE comp.
   #            @mailTo = grep ($_ ne 'freeland', @mailTo);
   #         }
   @mailTo = grep ($_ ne 'dmr' && $_ ne 'paulh', @mailTo);
       # I assume (perhaps rashly) that neither dmr nor paulh want to track
       # individual code changes

   # end of filtering; @mailTo now has all intended recipients
   ###########
   return join(', ', @mailTo);
}

###################################
# decodeArgs is used to break apart the arguments from the shell-style list
#   into a better (IMHO) object-separated representation.  It builds an
#   associative array structured as a tree:
#     objectN        is set to 1, and exists mostly as a match target
#     objectN,"name" (something like "comp!unit(ver)")
#     objectN,"compound"
#     objectN,"unit" (may not be defined)
#     objectN,"branch"
#       and so on...
#   for some commands (add, remove, etc.), there are arguments not in the
#   objectN pattern:
#     "parent","compound"
#     "parent","branch"
#     "label"
#     "isLocal"
#   also, compound parentage is built into the same array, because this is
#   where we know what compounds are needed, with entries of the form:
#     "parentRelation",parent,pBranch,child,chBranch   set to 1
#
#   The routine uses the command name to grab "global" arguments, then
#   repeatedly uses decodeOneObj to eat the rest of the args.  That also
#   makes a list of the compound-branches we use, and we generate parentage
#   based on that.  The object list is as described above; the compound
#   list is also an assoc. array, with keys compound,branch=1.  We don't use
#   compound=branch because some commands (diff,merge,perverse usages)
#   might need multiple branches of one compound.
####
sub decodeArgs {
   local($cmd, @list) = @_;
   local(%objects, $objNum, %comps);

#dbg   print LOG "decoding args...\n";
   if ($cmd eq 'add') {
      $objects{'parent','compound'} = shift(@list);
      $objects{'parent','branch'} = shift(@list);
      $comps{$objects{'parent','compound'},$object{'parent','branch'}} = 1;
   } elsif ($cmd eq 'branch') {
      $objects{'label'} = shift(@list);
      $objects{'isRecursive'} = shift(@list);
      $objects{'isReused'} = shift(@list);
   } elsif ($cmd eq 'checkout') {
      $objects{'isLocal'} = shift(@list);
      $objects{'isDuplicate'} = shift(@list);
   } elsif ($cmd eq 'checkpoint') {
      $objects{'label'} = shift(@list);
      $objects{'isAdding'} = shift(@list);
      $objects{'isForced'} = shift(@list);
   } elsif ($cmd eq 'claim') {
      $objects{'isRecursive'} = shift(@list);
   } elsif ($cmd eq 'diff') {
      $objects{'object1','compound'} = shift(@list);
      $objects{'object1','unit'} = shift(@list);
      $objects{'object1','filename'} = shift(@list);
      $objects{'isLocal'} = shift(@list);
   } elsif ($cmd eq 'get') {
      $objects{'object1','compound'} = shift(@list);
      $objects{'isLocal'} = shift(@list);
      $objects{'object1','branch'} = shift(@list);
      $objects{'object1','date'} = shift(@list);
      $objects{'object1','state'} = shift(@list);
      $objects{'object1','login'} = shift(@list);
      $comps{$objects{'object1','compound'},$object{'object1','branch'}} = 1;
   } elsif ($cmd eq 'remove') {
      $objects{'parent','compound'} = shift(@list);
      $objects{'parent','branch'} = shift(@list);
      $comps{$objects{'parent','compound'},$object{'parent','branch'}} = 1;
   } elsif ($cmd eq 'report') {
      $objects{'isLocal'} = shift(@list);
   } elsif ($cmd eq 'set') {
      $objects{'object1','compound'} = shift(@list);
      $objects{'object1','branch'} = shift(@list);
      $objects{'object1','unit'} = shift(@list);
      $comps{$objects{'object1','compound'},$object{'object1','branch'}} = 1;
   } elsif ($cmd eq 'status') {
      $objects{'isLocal'} = shift(@list);
   }

#dbg   print LOG "  prelude of $cmd: $key=$val\n"
#dbg       while (($key, $val) = each(%objects));

   $objNum = 0;
   while ($#list >= 0) {
      &decodeOneObj($cmd, ++$objNum, *list, *objects, *comps);
   }
#dbg   print LOG "decoded.\n";
   return %objects;
}


###################################
# decodeOneObj is used to break the arguments from a single object, based
#    on the command type (and knowing what args come with each command).
#    It shifts arguments out of the list (the third arg), adds keys to the
#    object tree (the fourth), and adds compounds to the last argument.    
####
sub decodeOneObj {
   local ($cmd, $num, *list, *object, *comps) = @_;
   local ($comp, $unit, $ver, $stuff);
   $num = join('','object',$num);

#dbg   print LOG "decodeOneObj for $cmd ($num)\n";
   if ($cmd eq 'abandon') {
      # compound, unit, branch, date, state, login, isRecursive, isForced
      $comp = shift(@list);
      $object{$num,'compound'} = $comp;
      $unit = shift(@list);
      $object{$num,'unit'} = $unit if length($unit);
      $ver = shift(@list);
      $object{$num,'branch'} = $ver;
      $comps{$comp,$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','branch',$ver) unless ($ver =~ /^\d/);
      } else {
         $ver = 'trunk';
      }
      $object{$num,'date'} = shift(@list);
      $object{$num,'state'} = shift(@list);
      $object{$num,'login'} = shift(@list);
      $object{$num,'isRecursive'} = shift(@list);
      $object{$num,'isForced'} = shift(@list);
      $object{$num,'name'} = "$ver of $unit in $comp";
      $object{$num} = 1;
   } elsif ($cmd eq 'add') {
      # compound, unit, branch, isBinary, filename
      $comp = shift(@list);
      $object{$num,'compound'} = $comp if length($comp);
      $unit = shift(@list);
      $object{$num,'unit'} = $unit if length($unit);
      $ver = shift(@list);
      if (length($comp)) {
         $object{$num,'branch'} = $ver;
         $comps{$comp,$ver} = 1;
         if (length($ver)) {
            $ver = join(' ','branch',$ver);
         } else {
            $ver = 'trunk';
         }
         $object{$num,'name'} = "$ver of compound $comp";
      } else {
         $object{$num,'name'} = "unit $unit";
      }
      $object{$num,'isBinary'} = shift(@list);
      $object{$num,'filename'} = shift(@list);
      $object{$num} = 1;
   } elsif ($cmd eq 'branch' || $cmd eq 'checkpoint') {
      # compound, branch, date
      $comp = shift(@list);
      $object{$num,'compound'} = $comp;
      $ver = shift(@list);
      $object{$num,'branch'} = $ver;
      $comps{$comp,$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','branch',$ver);
      } else {
         $ver = 'trunk';
      }
      $object{$num,'date'} = shift(@list);
      $object{$num,'name'} = "$ver of $comp";
      $object{$num} = 1;
   } elsif ($cmd eq 'checkin') {
      # compound, unit, branch, isRecursive, isForced, useFileDate,
      # ciReason, bugNumber
      $comp = shift(@list);
      $object{$num,'compound'} = $comp;
      $unit = shift(@list);
      $object{$num,'unit'} = $unit;
      $ver = shift(@list);
      $object{$num,'branch'} = $ver;
      $comps{$comp,$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','branch',$ver);
      } else {
         $ver = 'trunk';
      }
      $object{$num,'isRecursive'} = shift(@list);
      $object{$num,'isForced'} = shift(@list);
      $object{$num,'useFileDate'} = shift(@list);
      $object{$num,'ciReason'} = shift(@list);
      $object{$num,'bugNumber'} = shift(@list);
      $object{$num,'name'} = "$ver of $unit in $comp";
      $object{$num} = 1;
   } elsif ($cmd eq 'checkout' || $cmd eq 'claim') {
      # compound, unit, branch, date, state, login, end-version, end-date,
      # recursive, claim-type, bugNumber, reason
      $comp = shift(@list);
      $object{$num,'compound'} = $comp;
      $unit = shift(@list);
      $object{$num,'unit'} = $unit if length($unit);
      $ver = shift(@list);
      $object{$num,'branch'} = $ver;
      $comps{$comp,$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','branch',$ver);
      } else {
         $ver = 'trunk';
      }
      $object{$num,'date'} = shift(@list);
      $object{$num,'state'} = shift(@list);
      $object{$num,'login'} = shift(@list);
      $object{$num,'endVersion'} = shift(@list);
      $object{$num,'endDate'} = shift(@list);
      $object{$num,'isRecursive'} = shift(@list);
      $object{$num,'claimType'} = shift(@list);
      $object{$num,'bugNumber'} = shift(@list);
      $object{$num,'coReason'} = shift(@list);
      if (length($unit)) {
         $object{$num,'name'} = "$ver of $unit in $comp";
      } else {
         $object{$num,'name'} = "$ver of $comp";
      }
      $object{$num} = 1;
   } elsif ($cmd eq 'diff') {
      # version, date, state, login
      $ver = shift(@list);
      $comps{$object{'object1','compound'},$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','branch',$ver) unless ($ver =~ /^\d/);
      } else {
         $ver = 'trunk';
      }
      $object{$num,'date'} = shift(@list);
      $object{$num,'state'} = shift(@list);
      $object{$num,'login'} = shift(@list);
      $object{$num,'compound'} = $object{'object1','compound'};
      $object{$num,'unit'} = $object{'object1','unit'};
      $object{$num,'name'} = 
         "$ver of $object{'object1','unit'} in $object{'object1','compound'}";
      $object{$num} = 1;
   } elsif ($cmd eq 'get') {
      # attribute
      $object{$num,'attribute'} = shift(@list);
      $object{$num,'name'} = "attribute $object{$num,'attribute'}";
      $object{$num,'compound'} = $object{'object1','compound'};
      $object{$num,'branch'} = $object{'object1','branch'};
      $object{$num,'date'} = $object{'object1','date'};
      $object{$num,'state'} = $object{'object1','state'};
      $object{$num,'login'} = $object{'object1','login'};
      $object{$num} = 1;
   } elsif ($cmd eq 'merge') {
      # compound, unit, filename, base, top, claim-type
      $comp = shift(@list);
      $object{$num,'compound'} = $comp;
      $unit = shift(@list);
      $object{$num,'unit'} = $unit;
      shift(@list);       # we never care about the filename, so lose it
      $ver = shift(@list);
      $object{$num,'base'} = $ver;
      $comps{$comp,$ver} = 1;
      if (!length($ver)) {
         $ver = 'trunk?!';
      }
      $object{$num,'name'} = $ver;
      $ver = shift(@list);
      $object{$num,'top'} = $ver;
      $comps{$comp,$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','tip of branch',$ver);
      } else {
         $ver = 'tip of trunk';
      }
      $object{$num,'name'} .= " to $ver of $unit in $comp";
      $object{$num,'claimType'} = shift(@list);
      $object{$num} = 1;
   } elsif ($cmd eq 'remove') {
      # object-type, object, version
      $comp = shift(@list);
      $object{$num,'objectType'} = $comp;
      $unit = shift(@list);
      $ver = shift(@list);
      $object{$num,'version'} = $ver;
      $stuff = $object{'parent','branch'};
      if (length($stuff)) {
         $stuff = "branch $stuff";
      } else {
         $stuff = "trunk";
      }
      $stuff .= " of $object{'parent','compound'}";
      if ($comp eq 'subcomp') {
         $object{$num,'compound'} = $unit;
         $object{$num,'name'} = "subcompound $unit from $stuff";
      } elsif ($comp eq 'unit') {
         $object{$num,'unit'} = $unit;
         $object{$num,'name'} = "unit $unit from $stuff";
      } elsif ($comp eq 'version') {
         $object{$num,'unit'} = $unit;
         $object{$num,'name'} = "version $ver of unit $unit in $stuff";
      } else {
         print "Uh-oh, unrecognized removal type '$comp' from HOPE\n";
         &exitErr;
      }
      $object{$num} = 1;
   } elsif ($cmd eq 'report') { 
      # compound, unit, branch, date, state, login
      $comp = shift(@list);
      $object{$num,'compound'} = $comp;
      $unit = shift(@list);
      $object{$num,'unit'} = $unit if length($unit);
      $ver = shift(@list);
      $object{$num,'branch'} = $ver;
      $comps{$comp,$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','branch',$ver);
      } else {
         $ver = 'trunk';
      }
      $object{$num,'date'} = shift(@list);
      $object{$num,'state'} = shift(@list);
      $object{$num,'login'} = shift(@list);
      if (length($unit)) {
         $object{$num,'name'} = "$ver of $unit in $comp";
      } else {
         $object{$num,'name'} = "$ver of $comp";
      }
      $object{$num} = 1;
   } elsif ($cmd eq 'status') { 
      # compound, unit, branch, date, state, login, isRecursive
      $comp = shift(@list);
      $object{$num,'compound'} = $comp;
      $unit = shift(@list);
      $object{$num,'unit'} = $unit if length($unit);
      $ver = shift(@list);
      $object{$num,'branch'} = $ver;
      $comps{$comp,$ver} = 1;
      if (length($ver)) {
         $ver = join(' ','branch',$ver);
      } else {
         $ver = 'trunk';
      }
      $object{$num,'date'} = shift(@list);
      $object{$num,'state'} = shift(@list);
      $object{$num,'login'} = shift(@list);
      $object{$num,'isRecursive'} = shift(@list);
      if (length($unit)) {
         $object{$num,'name'} = "$ver of $unit in $comp";
      } else {
         $object{$num,'name'} = "$ver of $comp";
      }
      $object{$num} = 1;
   } elsif ($cmd eq 'set') {
      # attribute, value
      $object{$num,'attribute'} = shift(@list);
      $object{$num,'newValue'} = shift(@list);
      $object{$num,'name'} = 
          "$object{$num,'attribute'} to $object{$num,'newValue'}";
      $object{$num} = 1;
   } else {
      print "Uh-oh: unrecognized command name '$cmd' from HOPE\n";
      &exitErr;
   }
#dbg   while (($key, $val) = each(%objects)) {
#dbg      print LOG "  $key=$val\n" if $key =~ /^$num/;
#dbg   }
}

###################################
# execLurkAct spawns the actual process which will handle a lurker's
#    action.  It is told who the user is, what the comand is, whose lurktab
#    has this entry, what action to run, and what text should be given as
#    input to the process. 
####
sub execLurkAct {
   local($user, $cmd, $lurker, $act, $text) = @_;
   local($dest) = $lurker;
   local($subject, @objectNames);

#dbg   print LOG "\$user=$user, \$cmd=$cmd, \$lurker=$lurker, \$act=$act\n";
   if ($act =~ /^<MAIL(\s+\S.*)?>$/) {    # <MAIL> special action
      $dest = $1 if (length($1));
      $subject = "HOPE $cmd by $user";
      if ($cmd eq 'set') {
         local($objBit) = ($text =~ / for (.*):/);
	 $subject .= " for $objBit";
      }
      @objectNames = grep(s/^o //, split("\n", $text));
      if ($#objectNames > -1) {
         $subject .= " of $objectNames[0]";
         $subject .= ", etc." if ($#objectNames > 0);
      }
      $act = join(' | ', 'fmt -s',
                  "(echo \"To: $dest\nSubject: $subject\n\n\"; cat; echo \"\n--HOPE, for $lurker\")",
                  '/usr/lib/sendmail -t');
   }
#dbg   print LOG "Firing for $lurker: $act\n";
   open(TRIGPROC, "| ($act)");
   print TRIGPROC "$text\n";
   close(TRIGPROC);
}


###################################
# inputString generates a string to describe the action given.  This string
#    is echoed into lurker processes as input, and would most typically be
#    used as the text of a mail message---it's intended to be
#    human-readable, though a mechanical parser is quite imaginable.
####
sub inputString {
   local($user, $cmd, *objects) = @_;
   local($key, $val, $string);

   $string = "$user executed $cmd";
   if (length($objects{'parent','compound'})) {
      $string .= join(' ', ' to',
                      (length($objects{'parent','branch'})?
                         "branch $objects{'parent','branch'}":'trunk'),
                      'of', $objects{'parent','compound'});
   }
   if (length($objects{'label'})) {
      $string .= "with label $objects{'label'}";
   }
   $string .= ' for';
   if ($cmd eq 'get' || $cmd eq 'set') {
      $string .= join(' ', 
                      (length($objects{'object1','branch'})?
                         " branch $objects{'object1','branch'}":' trunk'),
                      'of');
      if (length($objects{'object1','unit'})) {
         $string .= join(' ', ' unit', $objects{'object1','unit'}, 'in');
      }
      $string .= " compound $objects{'object1','compound'}";
   }
   $string .= ":\n\n";
   while (($key, $val) = each(%objects)) {
      next unless (($key) = ($key =~ /^(object\d+)$;name$/));
      $string .= "o $val";
      if (length($objects{$key,'date'})) {
         $string .= ", dated $objects{$key,'date'}";
      }
      if (length($objects{$key,'login'})) {
         $string .= ", by $objects{$key,'login'}";
      }
      if (length($objects{$key,'state'})) {
         $string .= ", with state $objects{$key,'state'}";
      }
      if (length($objects{$key,'ciReason'})) {
         foreach (split("\\n", $objects{$key,'ciReason'})) {
	    $string .= "\n    $_";
	 } 
         $string .= " \n";
      }
      $string .= " \n";
   }
#dbg print LOG "string: $string\n";
   return $string;
}


###################################
# exitErr is responsible for shutting down our hope client before exiting
#   with an error code.  It doesn't print any message, though---that's the
#   caller's job, because the caller knows what happened.
####
sub exitErr {
   local (@callData) = (caller);
#dbg   print LOG "error found at @callData\n";

#dbg   close(LOG);
   exit 1;
}


###################################
# exitOk is responsible for shutting down our hope client before exiting
#   with an success code.
####
sub exitOk {
#dbg   print LOG "successful termination.\n";

#dbg   close(LOG);
   exit 0;
}


###########################################################################
#                      Th-th-th-That's All, Folks!                        #
###########################################################################
# $Log: trigger,v $
# Revision 1.1  2004/03/12 00:08:39  cgay
# Initial revision
#
# Revision 1.3  1995/03/09 17:07:51  keith
# Suspend mail shots
#
# Revision 1.2  1995/03/07  14:43:18  mikes
# Removing eliot from mail notification of changes
#
# Revision 1.1  1994/12/09  18:26:54  keith
# new file
#
# Revision 1.4  1994/11/11  16:39:00  johnk
# Removing myself from the email list this trigger sends to
#
#
