loc[n] = nth local of the method
conpool[n] = nth constant from the constant pool in the method's class
operand stack accessed via pop(),pop2(),push(x),push2(x)
program counter is pc
bytecode operands are bytes, when concatenated use big-endian order.

hex dec  instr             my name       action

    NOP:
00   0:  nop

    PUSHING CONSTANTS:
01   1:  aconst_null	    nop		push (null)
02   2:  iconst_m1	    push_int    push (-1)
03   3:  iconst_0	    push_int    push (0)
04   4:  iconst_1	    push_int    push (1)
05   5:  iconst_2	    push_int    push (2)
06   6:  iconst_3           push_int    push (3)
07   7:  iconst_4           push_int    push (4)
08   8:  iconst_5	    push_int    push (5)
09   9:  lconst_0	    push_long	push2 (0)
0A  10:  lconst_1	    push_long	push2 (1)
0B  11:  fconst_0	    push_float  push (0.0)
0C  12:  fconst_1	    push_float  push (1.0)
0D  13:  fconst_2	    push_float	push (2.0)
0E  14:  dconst_0	    push_double push2 (0.0)
0F  15:  dconst_1	    push_double	push2 (1.0)
10  16:  bipush L	    push_int	push ((L << 24) >> 24)
11  17:  sipush H L	    push_int	push ((HL << 16) >> 16)
12  18:  ldc1 L		    push_con	push (conpool [L])
13  19:  ldc2 H L	    push_con	push (conpool [HL])
14  20:  ldc2w H L	    push_con	push2 (conpool [HL..HL+1]) , long/float

    PUSHING LOCALS:
15  21:  iload L	    push_int	push (loc[L]), should be int
    wide iload H L          push_int    push (loc[HL]), should be int
16  22:  lload L	    push_long	push2 (loc[L..L+1]), should be long
    wide lload H L          push_long   push (loc[HL..HL+1]), should be long
17  23:  fload L	    push_float	push (loc[L]), should be float
    wide fload H L          push_float  push (loc[HL]), should be float
18  24:  dload L	    push_double push2 (loc[L..L+1]), should be double
    wide dload H L          push_double push (loc[HL..HL+1]), should be double
19  25:  aload L	    push	push (loc[L]), should be obj
    wide aload H L          push        push (loc[HL]), should be obj
1A  26:  iload_0	    push_int	push (loc[0]), should be int
1B  27:  iload_1	    push_int	push (loc[1]), should be int
1C  28:  iload_2	    push_int	push (loc[2]), should be int
1D  29:  iload_3	    push_int	push (loc[3]), should be int
1E  30:  lload_0	    push_long	push2 (loc[0..1]), should be long
1F  31:  lload_1            push_long	push2 (loc[1..2]), should be long
20  32:  lload_2            push_long  	push2 (loc[2..3]), should be long
21  33:  lload_3            push_long	push2 (loc[3..4]), should be long
22  34:  fload_0            push_float 	push (loc[0]), should be float
23  35:  fload_1            push_float	push (loc[1]), should be float
24  36:  fload_2            push_float	push (loc[2]), should be float
25  37:  fload_3            push_float	push (loc[3]), should be float
26  38:  dload_0            push_double	push2 (loc[0..1]), should be double
27  39:  dload_1            push_double	push2 (loc[1..2]), should be double
28  40:  dload_2            push_double	push2 (loc[2..3]), should be double
29  41:  dload_3            push_double	push2 (loc[3..4]), should be double
2A  42:  aload_0            push	push (loc[0]), should be obj
2B  43:  aload_1            push	push (loc[1]), should be obj
2C  44:  aload_2            push	push (loc[2]), should be obj
2D  45:  aload_3            push	push (loc[3]), should be obj

    ARRAY LOADS:
2E  46:  iaload	            load_int	ind=pop(), arr=pop(), push (arr[ind]), should be int
2F  47:  laload		    load_long	ind=pop(), arr=pop(), push2 (arr[ind]), should be long
30  48:  faload		    load_float	ind=pop(), arr=pop(), push (arr[ind]), should be float
31  49:  daload		    load_double	ind=pop(), arr=pop(), push2 (arr[ind]), should be double
32  50:  aaload		    load	ind=pop(), arr=pop(), push (arr[ind]), should be obj
33  51:  baload		    load_byte	ind=pop(), arr=pop(), push (arr[ind]), should be byte
34  52:  caload		    load_char	ind=pop(), arr=pop(), push (arr[ind]), should be char
35  53:  saload		    load_short	ind=pop(), arr=pop(), push (arr[ind]), should be short

    POPPING LOCALS:
36  54:  istore L	    pop_int	loc[L] = pop(), should be int
    wide istore H L         pop_int     loc[HL] = pop(), should be int
37  55:  lstore L	    pop_long	loc[L..L+1] = pop2(), should be long
    wide lstore H L         pop_long    loc[HL..HL+1] = pop(), should be long
38  56:  fstore L	    pop_float	loc[L] = pop(), should be float
    wide fstore H L         pop_float   loc[HL] = pop(), should be float
39  57:  dstore L	    pop_double	loc[L..L+1] = pop2(), should be double
    wide dstore H L         pop_double  loc[HL..HL+1] = pop(), should be double
3A  58:  astore L	    pop 	loc[L] = pop(), should be obj
    wide astore H L         pop         loc[HL] = pop(), should be obj
3B  59:  istore_0	    pop_int	loc[0] = pop(), should be int
3C  60:  istore_1	    pop_int	loc[1] = pop(), should be int
3D  61:  istore_2           pop_int     loc[2] = pop(), should be int
3E  62:  istore_3	    pop_int	loc[3] = pop(), should be int
3F  63:  lstore_0	    pop_long	loc[0..1] = pop2(), should be long
40  64:  lstore_1	    pop_long	loc[1..2] = pop2(), should be long
41  65:  lstore_2	    pop_long	loc[2..3] = pop2(), should be long
42  66:  lstore_3	    pop_long	loc[3..4] = pop2(), should be long
43  67:  fstore_0	    pop_float	loc[0] = pop(), should be float
44  68:  fstore_1	    pop_float	loc[1] = pop(), should be float
45  69:  fstore_2	    pop_float	loc[2] = pop(), should be float
46  70:  fstore_3	    pop_float	loc[3] = pop(), should be float
47  71:  dstore_0	    pop_double	loc[0..1] = pop2(), should be double
48  72:  dstore_1	    pop_double	loc[1..2] = pop2(), should be double
49  73:  dstore_2	    pop_double	loc[2..3] = pop2(), should be double
4A  74:  dstore_3	    pop_double	loc[3..4] = pop2(), should be double
4B  75:  astore_0	    pop		loc[0] = pop(), should be obj
4C  76:  astore_1	    pop		loc[1] = pop(), should be obj
4D  77:  astore_2	    pop		loc[2] = pop(), should be obj
4E  78:  astore_3	    pop		loc[3] = pop(), should be obj

    ARRAY STORES:
4F  79:  iastore	    store_int	ind = pop(), arr = pop(), val = pop(), arr[ind] = val, should be int
50  80:  lastore	    store_long	ind = pop(), arr = pop(), val = pop2(), arr[ind] = val, should be long
51  81:  fastore	    store_float	ind = pop(), arr = pop(), val = pop(), arr[ind] = val, should be float
52  82:  dastore	    store_doubleind = pop(), arr = pop(), val = pop2(), arr[ind] = val, should be double
53  83:  aastore	    store	ind = pop(), arr = pop(), val = pop(), arr[ind] = val, should be obj
54  84:  bastore	    store_byte	ind = pop(), arr = pop(), val = pop(), arr[ind] = val, should be byte
55  85:  castore	    store_char	ind = pop(), arr = pop(), val = pop(), arr[ind] = val, should be char
56  86:  sastore	    store_short	ind = pop(), arr = pop(), val = pop(), arr[ind] = val, should be short

    STACK OPS:
57  87:  pop		    pop		pop()
58  88:  pop2		    pop2	pop2()
59  89:  dup		    dup		a=pop(), push(a), push(a)
5A  90:  dup_x1		    dup_x1	a=pop(), b=pop(), push(a), push(b), push(a)
5B  91:  dup_x2		    dup_x2	a=pop(), b=pop(), c=pop(), push(a), push(c), push(b), push(a)
5C  92:  dup2		    dup2	a=pop2(), push2(a), push2(a)
5D  93:  dup2_x1	    dup2_x1	a=pop2(), b=pop(), push2(a), push(b), push2(a)
5E  94:  dup2_x2	    dup2_x2	a=pop2(), b=pop(), c=pop(), push2(a), push(c), push(b), push2(a)
5F  95:  swap		    swap	a=pop(), b=pop(), push(a), push(b)

    ARITHMETIC OPS:
60  96:  iadd		    add_int	b=pop(), a=pop(), push(a+b)
61  97:  ladd		    add_long	b=pop2(), a=pop2(), push2(a+b)
62  98:  fadd		    add_float	b=pop(), a=pop(), push(a+b), IEEE single float
63  99:  dadd		    add_double	b=pop2(), a=pop2(), push2(a+b), IEEE double float
64 100:  isub               sub_int     b=pop(), a=pop(), push(a-b)
65 101:  lsub               sub_long    b=pop2(), a=pop2(), push2(a-b)
66 102:  fsub               sub_float   b=pop(), a=pop(), push(a-b), IEEE single float   
67 103:  dsub               sub_double  b=pop2(), a=pop2(), push2(a-b), IEEE double float
68 104:  imul               mul_int     b=pop(), a=pop(), push(a*b)                      
69 105:  lmul               mul_long    b=pop2(), a=pop2(), push2(a*b)                   
6A 106:  fmul               mul_float   b=pop(), a=pop(), push(a*b), IEEE single float   
6B 107:  dmul               mul_double  b=pop2(), a=pop2(), push2(a*b), IEEE double float
6C 108:  idiv               div_int     b=pop(), a=pop(), push(a/b)                      
6D 109:  ldiv               div_long    b=pop2(), a=pop2(), push2(a/b)                   
6E 110:  fdiv               div_float   b=pop(), a=pop(), push(a/b), IEEE single float   
6F 111:  ddiv               div_double  b=pop2(), a=pop2(), push2(a/b), IEEE double float
70 112:  imod               mod_int     b=pop(), a=pop(), push(a%b)                      
71 113:  lmod               mod_long    b=pop2(), a=pop2(), push2(a%b)                   
72 114:  fmod               mod_float   b=pop(), a=pop(), push(a%b), IEEE single float   
73 115:  dmod               mod_double  b=pop2(), a=pop2(), push2(a%b), IEEE double float
74 116:  ineg		    neg_int	push(- pop())
75 117:  lneg	            neg_long	push2(- pop2())
76 118:  fneg		    neg_float	push(- pop()), IEEE single float
77 119:  dneg		    neg_double	push2(- pop2()), IEEE single float
78 120:  ishl		    shl_int	sh=pop(), val=pop(), push (val << (sh & 0x1f))
79 121:  lshl		    shl_long	sh=pop(), val=pop2(), push2 (val << (sh & 0x3f))
7A 122:  ishr		    shr_int	sh=pop(), val=pop(), push (val >> (sh & 0x1f)), signed
7B 123:  lshr		    shr_long	sh=pop(), val=pop2(), push2 (val >> (sh & 0x3f)), signed
7C 124:  iushr		    ushr_int	sh=pop(), val=pop(), push (val >> (sh & 0x1f)), unsigned
7D 125:  lushr		    ushr_long	sh=pop(), val=pop2(), push2 (val >> (sh & 0x3f)), unsigned
7E 126:  iand		    and_int	b=pop(), a=pop(), push(a&b)   
7F 127:  land		    and_long	b=pop2(), a=pop2(), push2(a&b)
80 128:  ior		    or_int	b=pop(), a=pop(), push(a|b)   
81 129:  lor		    or_long	b=pop2(), a=pop2(), push2(a|b)
82 130:  ixor		    xor_int	b=pop(), a=pop(), push(a^b)   
83 131:  lxor		    xor_long	b=pop2(), a=pop2(), push2(a^b)
84 132:  iinc L B	    inc_int	loc[L] = loc[L]+B,    B 8-bit signed
    wide iinc H L B C			loc[HL] = loc[HL]+BC,    BC 16-bit signed

    DATA CONVERSIONS:  [between int/long/float/double]
85 133:  i2l		    int2long	push2 ((long) (pop())), signed 32 bit -> 64 bit
86 134:  i2f		    int2float	push ((float) (pop()))
87 135:  i2d		    int2double	push2 ((double) (pop()))
88 136:  l2i		    long2int	push ((int) (pop2()))
89 137:  l2f		    long2float	push ((float) (pop2()))
8A 138:  l2d		    long2double	push2 ((double) (pop2()))
8B 139:  f2i		    float2int	push ((int) (pop()))
8C 140:  f2l                float2long	push2 ((long) (pop()))
8D 141:  f2d		    float2double push2 ((double) (pop()))
8E 142:  d2i		    double2int	push ((int) (pop2()))
8F 143:  d2l		    double2long	push2 ((long) (pop2()))
90 144:  d2f		    double2float push ((float) (pop2()))

    INT NARROWING:
91 145:  i2b		    int2byte	push ((pop() << 24) >> 24)
92 146:  i2c		    int2char	push ((pop() << 16) >>> 16)
93 147:  i2s		    int2short	push ((pop() << 16) >> 16)

    LONG/FLOAT/DOUBLE COMPARISONS:
94 148:  lcmp		    cmp_long	b=pop2(), a=pop2(), push (sign (a-b)) ;
95 149:  fcmpl		    cmpl_float	b=pop(), a=pop(), if NaNs, push (-1), else push (sign (a-b)), IEEE
96 150:  fcmpg		    cmpg_float	b=pop(), a=pop(), if NaNs, push (+1), else push (sign (a-b)), IEEE
97 151:  dcmpl		    cmpl_double	b=pop2(), a=pop2(), if NaNs, push (-1), else push (sign (a-b)), IEEE
98 152:  dcmpg		    cmpg_double	b=pop2(), a=pop2(), if NaNs, push (+1), else push (sign (a-b)), IEEE

    INTEGER COMPARE/BRANCH:
99 153:  ifeq H L	    ifeq_int	if (pop() == 0) goto (pc+HL)	; int/short/byte/char/bool only!
9A 154:  ifne H L	    ifne_int	if (pop() != 0) goto (pc+HL)
9B 155:  iflt H L	    iflt_int	if (pop() < 0) goto (pc+HL)
9C 156:  ifge H L	    ifge_int	if (pop() >= 0) goto (pc+HL)
9D 157:  ifgt H L	    ifgt_int	if (pop() > 0) goto (pc+HL)
9E 158:  ifle H L	    ifle_int	if (pop() <= 0) goto (pc+HL)
9F 159:  if_icmpeq H L	    if_cmpeq_int b=pop(), a=pop(), if (a == b) goto (pc+HL), ints
A0 160:  if_icmpne H L	    if_cmpne_int b=pop(), a=pop(), if (a != b) goto (pc+HL)
A1 161:  if_icmplt H L	    if_cmplt_int b=pop(), a=pop(), if (a < b) goto (pc+HL)
A2 162:  if_icmpge H L	    if_cmpge_int b=pop(), a=pop(), if (a >= b) goto (pc+HL)
A3 163:  if_icmpgt H L	    if_cmpgt_int b=pop(), a=pop(), if (a > b) goto (pc+HL)
A4 164:  if_icmple H L	    if_cmple_int b=pop(), a=pop(), if (a <= b) goto (pc+HL)
A5 165:  if_acmpeq H L	    if_cmpeq	b=pop(), a=pop(), if (a == b) goto (pc+HL), objs
A6 166:  if_acmpne H L	    if_cmpne	b=pop(), a=pop(), if (a != b) goto (pc+HL), objs

    GOTO etc:
A7 167:  goto H L	    goto	goto (pc+HL)
A8 168:  jsr H L	    jsr		push (pc+3), goto (pc+HL)
A9 169:  ret L		    ret		goto (loc[L])
    wide ret H L                        goto (loc[HL])
AA 170:  tableswitch <pad> <doff> <low> <high> (<off>)*
					pad is 0..3 bytes to word-align
					doff is (bigend) word default offset,
					low is (bigend) int value
					high is (bigend) int value
					off are (bigend) int values.  form a vector offs

					index = pop ().
					off = ((index < low | index > high) ? doff : else offs [index-low])
					goto (pc+off)
AB 171:  lookupswitch <pad> <doff> <count> (<val> <off>)*
					pad is 0..3 bytes to word-align
					doff is (bigend) word default offset,
					count is (bigend) word, count of pairs to follow
					val, off are (bigend) int values

					index = pop ().
					off = assoc (pairs, index, default=doff
					goto (pc+off)

    RETURNS:
AC 172:  ireturn	    return_int	val = pop(), empty_stack (), popframe (), push (val), return_control
AD 173:  lreturn	    return_long	val = pop2(), empty_stack (), popframe (), push2 (val), return_control
AE 174:  freturn	    return_float val = pop(), empty_stack (), popframe (), push (val), return_control
AF 175:  dreturn	    return_double val = pop2(), empty_stack (), popframe (), push2 (val), return_control
B0 176:  areturn	    return      val = pop(), empty_stack (), popframe (), push (val), return_control
B1 177:  return		    return_void	empty_stack (), popframe (), return_control

    SLOT ACCESSORS:
B2 178:  getstatic H L	    getstatic	field = resolve_field_sig (conpool [HL]), 
					push/push2(getfield (STAT, this, field))
						can give StaticRefOfDynamicFieldException
B3 179:  putstatic H L	    putstatic	field = resolve_field_sig (conpool [HL]), 
					val = pop/pop2(), setfield (STAT, this, field, val)
						can give StaticRefOfDynamicFieldException
B4 180:  getfield H L	    getfield    field = resolve_field_sig (conpool [HL]),
					hand=pop(), push/push2(getfield (DYN, hand, field))
						can give NullPointerException, DynamicRefOfStaticFieldException
B5 181:  putfield H L       putfield	field = resolve_field_sig (conpool [HL]),
					val=pop/pop2(), hand=pop(), setfield (DYN, hand, field, val)
						can give NullPointerException, DynamicRefOfStaticFieldException

    METHOD CALLING:
B6 182:  invokevirtual H L  call		methsig = resolve_meth_sig (conpool[HL]),
					argn = pop/pop2() ... arg1 = pop/pop2()   [using methsig info]
					hand = pop()
					methtab = hand->methtab ...
					call...
B7 183:  invokespecial H L  call_spec	methsig = resolve_meth_sig (conpool[HL]),
					argn = pop/pop2() ... arg1 = pop/pop2()   [using methsig info]
					hand = pop()
					methtab = meth_descriptor (methsig)->methtab ...
					call....
B8 184:  invokestatic H L   call_static	methsig = resolve_meth_sig (conpool[HL]),
					argn = pop/pop2() ... arg1 = pop/pop2()   [using methsig info]
					methtab = static_meth_desc (methsig)
					call...
B9 185:  invokeinterface H L nargs dum 
			    call_intfce
 					methsig = resolve_meth_sig (conpool[HL]),  n = nargs
					argn = pop/pop2() ... arg1 = pop/pop2()   [using methsig info]
					hand = pop()
					methtab = lookup_interface_method (hand->class, methsig)
					call...

    ALLOCATION:
BB 187:  new H L	    new		push (new_instance (resolve_class_name (conpool [HL])))
BC 188:  newarray T	    new_prim_array	size=pop(), push (array_allocate (primitive_type[T], size))
BD 189:  anewarray H L	    new_array		size=pop(), push (array_allocate (resolve_class_name (conpool[HL]), size))

    SUNDRY:
BE 190:  arraylength			push (pop()->array_len)
BF 191:  athrow		    throw	hand = pop()
					throw (hand ? hand : NullPointerException)
C0 192:  checkcast H L			top=pop(), push(top),
					if (!(castable (top, resolve_class_name (conpool [HL]))))
						throw ClassCastException;
C1 193:  instanceof H L			push (is_instance_of (pop(), resolve_class_name (conpool [HL])))
C2 194:  monitorenter	    claim_lock  monitor_claim (pop())
C3 195:  monitorexit	    release_lock monitor_release (pop())
C4 196:  wide		    wide	Wide extension - see individual opcodes for details:
						iload/fload etc
						istore/fstore etc
						ret
						iinc

C5 197:  multianewarray H L d   	allocate array of dim d,  class conpool[HL], popping d sizes off stack

C6 198:  ifnull H L			if (pop() == null) goto (pc+HL)
C7 199:  ifnonnull H L                  if (pop() != null) goto (pc+HL)

C8 200:  goto_w A B C D			goto (pc+ABCD) 
C9 201:  jsr_w A B C D			push (pc), goto(pc+ABCD)



;;; internal & quick ones, values match 1.0.2 source dist., but internal anyway

CA 202:  breakpoint
CB 203:  ldc_quick l
CC 204:  ldc_w_quick H L
CD 205:  ldc2_w_quick H L
CE 206:  getfield_quick offs pad	push (%field-access (pop (), offs))            ; may NullPointerException
CF 207:  putfield_quick offs pad	pop val, %field-access (pop (), offs)  =  val  ; may NullPointerException
D0 208:  getfield2_quick offs pad	push2 (%field-access2 (pop (), offs))          ; may NullPointerException
D1 209:  putfield2_quick offs pad	pop2 val, %field-access2 (pop (), offs)  = val  ; may NullPointerException
D2 210:  getstatic_quick offs pad	push (%field-access (pop (), offs))
D3 211:  putstatic_quick offs pad	pop val, %field-access (pop (), offs)  =  val
D4 212:  getstatic2_quick offs pad	push2 (%field-access2 (pop (), offs))
D5 213:  putstatic2_quick offs pad	pop2 val, %field-access2 (pop (), offs)  = val
D6 214:  invokevirtual_quick offs n
D7 215:  invokenonvirtual_quick H L
D8 216:  invokesuper_quick H L
D9 217:  invokestatic_quick H L
DA 218:  invokeinterface_quick H L n guess
DB 219:  invokevirtualobject_quick offs n
DC 220:  invokeignored_quick x x
DD 221:  new_quick H L
DE 222:  anewarray_quick H L
DF 223:  multianewarray_quick H L d
E0 224:  checkcast_quick H L
E1 225:  instanceof_quick H L
E2 226:  invokevirtual_quick_w     ;; these 3 are automatically added in the build
E3 227:  getfield_quick_w          ;;
E4 228:  putfield_quick_w          ;;
E5 229:  
E6 230:  
E7 231:  
E8 232:  
E9 233:  
EA 234:  
EB 235:  
EC 236:  
ED 237:  
EE 238:  
EF 239:  
F0 240:  tail_nonvirtual_quick H L    ;; my additions for tail-jump optimization!
F1 241:  tail_super_quick H L
F2 242:  tail_static_quick H L
F3 243:  tail_interface_quick H L n guess  ;; these last two have to decide whether to tail or not (synchronized)
F4 244:  tail_virtualobject_quick offs nargs
F5 245:  tail_virtual_quick offs nargs
F6 246:  tail_virtual_quick_w H L
F7 247:  
F8 248:  
F9 249:  
FA 250:  
FB 251:  
FC 252:  
FD 253:  
FE 254:  opc_software       ;; these are added in the build
FF 255:  opc_hardware       ;; maybe traps/syscalls/microcode-escapes??




Ones from Paul Bedworth's extensions

CA 202:  mkfun  H L	  specifies a method, turns into standalone function object, which is pushed
CB 203:  mkclosure        pops function, replaces by closure object (pops as many args as it wants?)
CC 204:  invokefun        pop function, call it (popping as many args?)
CD 205:  emptyclosure     pushes an empty closure?  or a singleton cell?
CE 206:  acload H L HH LL HHLL is index, H L is "up", just pushes
CF 207:  acstore H L hH Ll  - pops the value
D0 208:  restarg          not sure, seems to have no args or affect on stack
D1 209:  initinteger       - not used -
D2 210:  printstack H L   debugging, H L form the depth
D3 211:  i2id             pop int, replace by tagged imm Integer
D4 212:  id2i             pop tagged imm Integer, replace by int
D5 213:  breakpoint       moved from old place

[These added to dejava]
