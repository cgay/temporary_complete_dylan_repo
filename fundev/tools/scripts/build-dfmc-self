#!/usr/local/bin/bash

###
### Author: Steve Rowley <sgr@Harlequin.COM>
###
### Synopsis: Script for self-compilation of the DFMC.
### 
### Usage: build-dfmc-self -p PersonalDylanRoot -e EmulatorRegistry -l Logfile -m Username(s) -ck
###
### * -p: personal Dylan root; defaults to ~/dylan (NB: no trailing slash!)
### * -e: Emulator registry; defaults to $personal_dylan_root/emulator-registry/.
### * -l: LogFile; defaults to $personal_dylan_root/build-dfmc-self-log.text.
### * -m: Username(s); By specifying this option, the tail of the logfile is
###       mailed to Username(s) upon completion of the entire script.  Arg is 
###       string of comma-separated mail addresses, e.g., -m "sgr, cassels, gz".
### * -c: Hope checkout of DFMC sources & registries.
### * -k: Keep old compilation products.
###

## Remember how long this flying circus takes.
starttime=`date`

## Parse the options & flags on the command line
while getopts p:e:l:m:c option
do case $option in
     p) personal_dylan_root=$OPTARG;;
     e) emulator_registry=$OPTARG;;
     l) log_file=$OPTARG;;
     m) send_mail_to=$OPTARG;;
     c) checkout=1;;
     k) keep_products=1;;
    \?) echo "Usage: build-dfmc-self -p PersonalDylanRoot -e EmulatorRegistry -l LogFile -m Username(s) -c"
        exit 2;;
   esac
done
shift `expr $OPTIND - 1`

## Assign defaults to options & flags
personal_dylan_root=${personal_dylan_root:-~/dylan}
emulator_registry=${emulator_registry:-$personal_dylan_root/emulator-registry/}
log_file=${log_file:-$personal_dylan_root/build-dfmc-self-log.text}
send_mail_to=${send_mail_to:-"No"}
checkout=${checkout:-0}
keep_products=${keep_products:-0}

## Words for printing out in the preamble.
case $checkout in
  0) checkoutword=No;;
  1) checkoutword=Yes;;
esac

case $keep_products in
  0) keep_productsword=No;;
  1) keep_productsword=Yes;;
esac

## Figure out platform, for selecting default image to run
hostname=`hostname`
machine=`/u/dylan/tools/scripts/dylan-platform`
#image=/u/dylan/releases/webster/install/$machine/bin/lw+dylan+webster # Use Webster worlds
image=/u/dylan/local/lw+dylan-$machine # Use devo DFMC worlds.

if [ ! -f $image ]; then
  ## Be slightly paranoid about going further if we know we're doomed.
  echo "Can't find image -  $image"
  exit 3
fi

## Libraries under DFMC (or close relatives), for registry & build-hacking purposes:
DFMC_LIBRARIES='dfmc-c-ffi dfmc-back-end dfmc-browser-support dfmc-c-back-end dfmc-c-compiler dfmc-c-file-compiler dfmc-c-linker dfmc-c-run-time dfmc-common dfmc-conditions dfmc-conversion dfmc-core dfmc-debug-back-end dfmc-definitions dfmc-dylan dfmc-execution dfmc-flow-graph dfmc-harp-cg dfmc-harp-cg-linker dfmc-linker dfmc-macro-expander dfmc-management dfmc-modeling dfmc-namespace dfmc-optimization dfmc-pentium-harp-cg dfmc-reader dfmc-testing dfmc-typist dfmc-webster projects registry-projects source-records file-source-records walker collectors set locators streams print format standard-io-streams format-out operating-system file-system harlequin-extensions byte-vector transcendentals equal-table memory-manager harlequin-dylan'

## Libraries part of DFMC or used by DFMC, which live in lib directory.
DFMC_LIB_SOURCES='projects registry-projects source-records walker collectors set locators streams print format standard-io-streams format-out operating-system file-system harlequin-extensions byte-vector transcendentals equal-table memory-manager harlequin-dylan'

## Libraries which are platform-dependent, so get platform registry files.
DFMC_PLATFORM_LIBS='operating-system streams standard-io-streams'

## Call webster-env.sh script to get shell variables set properly.  Must source, not directly
## call it, to get variables set in _this_ shell!  Do it early, so we get variables set
## and can figure out where binaries, libs, & apps went.
source /u/dylan/releases/webster/admin/webster-env.sh -pr $personal_dylan_root -r $personal_dylan_root

## Set up PATH so we can find commands.  This isn't strictly necessary for interactive use,
## but it is necessary for running from a cron job, where your personal $PATH isn't available!
## See crontab documentation for PATH given to a cron job.
PATH=.:/usr/etc:/usr/local/bin:/usr/local/new/bin:/usr/ucb:/usr/bsd:/usr/bin/bsd:/bin:/usr/bin:/usr/ccs/bin:/usr/share/all/scripts:/etc:/usr/etc:/usr/lib:/usr/new:/u/dylan/tools/gnuemacs:/u/dylan/tools/scripts:/u/dylan/tools/admin

function send-mail() {
  ## if -m mail-addr(s) was given, mail them the last 100 lines of the log file.

  ## Platform-dependent mailing commands.  Should add sparc-solaris.
  case $machine in
    sparc-sunos4 | sparc-solaris2) mailer="mail";;
    alpha-osf3)                    mailer="mailx";; # OSF has to be different, of course!
    *)                             echo "No mailer specified for $machine platforms."; exit 2;;
  esac

  ## Echo summary info into a mail pipe
  if test -f $log_file; then
    echo "Last 100 lines of build-dfmc-self log file $log_file:"
    echo ""
    tail -100 $log_file
  else
    echo "Log file $log_file for build-dfmc-self not found.  Go find out why!"
  fi | $mailer -s "build-dfmc-self report on $hostname ($machine platform)" $send_mail_to
}

function checkout-registry-generic(){
  ## checkout-registry lib-name
  ## Check out registry file, in DFMC registry/generic/.
  echo ""
  echo "Checking out DFMC generic registry for unit $1 to $WEBSTER_PERSONAL_ROOT/registry/generic/$1..."
  pushd $WEBSTER_PERSONAL_ROOT/registry/generic/
  hope co -comp D-registry-generic -unit $1 -writ skip -extra delete -miss create -filename $WEBSTER_PERSONAL_ROOT/registry/generic/$1
  popd
}

function checkout-registry-platform(){
  ## checkout-registry-platform lib-name
  ## Check out the rgistry file, in DFMC registry/$machine/.
  echo ""
  echo "Checking out DFMC $machine registry entry for unit $1 to $WEBSTER_PERSONAL_ROOT/registry/$machine/$1..." 
  pushd $WEBSTER_PERSONAL_ROOT/registry/$machine/
  hope co -comp D-registry-$machine -unit $1 -writ skip -extra delete -miss create -filename $WEBSTER_PERSONAL_ROOT/registry/$machine/$1
  popd
}

function checkout-sources(){
  ## checkout-sources compound directory-under-personal-root
  ## Checks out HOPE compound to a directory under personal root, recursively.
  echo ""
  echo "Checking out $1 sources to $WEBSTER_PERSONAL_ROOT/$2..."
  pushd $WEBSTER_PERSONAL_ROOT/
  hope co -comp $1 -rec -writ skip -extra delete -miss create -filename $WEBSTER_PERSONAL_ROOT/$2
  popd
}

function rip-out-compilation-products(){
  ## rip-out-compilation-products lib-name
  ## Removes .c files, .o files, library files (.a/.so), and application (if any).
  echo ""
  echo "Ripping out old builds in $WEBSTER_PERSONAL_BUILD/$1/*..."
  rm -fr $WEBSTER_PERSONAL_BUILD/$1

  echo "Ripping out old lib $WEBSTER_PERSONAL_LIB/lib_$1.$WEBSTER_LIB_SUFFIX..."
  rm -f $WEBSTER_PERSONAL_LIB/lib_$1.$WEBSTER_LIB_SUFFIX

  echo "Ripping out old application $WEBSTER_PERSONAL_BIN/$1..."
  rm -f $WEBSTER_PERSONAL_BIN/$1
}

## Everything (stdout & stderr) from here on out is teed to the logfile.
{
echo "*****************************"
echo "* DFMC Self-Compilation Log *"
echo "*****************************"
echo ""
echo "********************************************"
echo "Start time:            $starttime"
echo "Started by:            `whoami`"
echo "Compilation machine:   $hostname@`site-name` (`uname` `uname -r` `uname -v` `uname -m`)"
echo "Lisp image:            $image"
echo "Emulator Registry:     $emulator_registry"
echo "Dylan System Root:     $WEBSTER_SYSTEM_ROOT"
echo "Dylan Personal Root:   $WEBSTER_PERSONAL_ROOT"
echo "Build Directory:       $WEBSTER_PERSONAL_BUILD"
echo "Log file:              $log_file"
echo "Send mail:             $send_mail_to"
echo "Checkout sources:      $checkoutword"
echo "Keep old .c &c files:  $keep_productsword"
echo "********************************************"

## Do checkouts first, to get sources & registries synch'd up
if test $checkout -ne 0; then
  echo ""
  echo "********************"
  echo "* Source checkouts *"
  echo "********************"

  ## Core DFMC library sources
  checkout-sources D-dfmc dfmc/

  ## DFMC sources living abroad in the lib dir, and used libraries
  for libname in $DFMC_LIB_SOURCES; do
    checkout-sources D-lib-$libname lib/$libname
  done

  ## DFMC registry/generic files (abstract locators).
  for lib in $DFMC_LIBRARIES; do
    checkout-registry-generic $lib
  done

  ## Platform-specific registry files (e.g., standard-io-streams, operating-system, streams)
  for reg in $DFMC_PLATFORM_LIBS; do
    checkout-registry-platform $lib
  done
fi

## Rip out compilation products, so libraries get a clean DFM recompile.
if test $keep_products -ne 1; then
  echo ""
  echo "*********************************"
  echo "* Compilation product deletions *"
  echo "*********************************"
  for lib in $DFMC_LIBRARIES; do
    rip-out-compilation-products $lib
  done
fi

## Launch Webster and fire away
echo ""
echo "******************************"
echo "* Turning DFMC loose on DFMC *"
echo "******************************"

$image -init - <<SCRIPTORIUM
(in-package "DYLAN")
(load-all-patches)
(setq *sg-default-size* (* 4 *sg-default-size*))
(push "$emulator_registry" dylan::*library-registries*)
(defun funcall-with-backtrace (fn)
  ;; fn is a body function to be called.  If it errors, a backtrace will
  ;; be printed and the image exited.  Stolen from AndrewA.
  (declare (dynamic-extent fn))
  (flet ((handle-condition (condition)
           ;; Any condition that gets this far and isn't handled does a 
           ;; backtrace and exits abnormally.
           (format t "~&*** Bailing out after unhandled signal: ~A" condition)
           (dbg:with-debugger-stack ()
             (dbg:bug-backtrace nil))
           (bye 1)))
    (handler-bind ((error #'handle-condition))
      ;; Call body with rubber gloves and kludge goggles on.
      (let ((start-time (get-internal-run-time)))
        (unwind-protect (funcall fn)
          (let ((elapsed-secs (round (- (get-internal-run-time) start-time) 
                                     internal-time-units-per-second)))
            (multiple-value-bind (hours remdr) (floor elapsed-secs 3600)
              (multiple-value-bind (mins secs) (floor remdr 60)
                (format t "~&// Elapsed time: ~D hr ~D min ~D sec.~&" hours mins secs)))))))))
(compile 'funcall-with-backtrace)
(dylan:tty-infix-dylan-listen)
// For debugging:
// define library foo
//   use harlequin-dylan;
//   use format;
//   use format-out;
//   export foo;
// end;
// define module foo
//   use harlequin-dylan;
//   use format;
//   use format-out;
// end;
// in: foo;
require: dfmc-c-file-compiler;
in: dfmc-testing;
import-cl-functions(dylan(funcall-with-backtrace)(as: funcall-with-backtrace));
funcall-with-backtrace(method () 
                         update-libraries(#"dfmc-c-file-compiler", force-compile?: #t)
                       end);
bye:;
(bye 0)
SCRIPTORIUM

dstatus=$? # Dylan compilation exit status

## Forget trying to compile the entrails of the resulting dudes for now!

## Postludi
echo ""
echo "********************************************"
echo "DFMC self-compilation completed."
echo "Start time:                      $starttime."
echo "Completion time:                 `date`."
echo "Build Directory:                 $WEBSTER_PERSONAL_BUILD"
echo "Log file:                        $log_file"
if test -z $dstatus; then
  echo "Dylan compilation exit status:   (not attempted, for obscure reasons)"
else
  echo "Dylan compilation exit status:   $dstatus"
fi
echo "********************************************"

## This flying circus arranges for stderr to be piped to stdout, and then teed to the logfile.
} 2>&1 | tee $log_file

## Log file writing is now complete.  Send mail if the -m option was specified.
case $send_mail_to in
   No) ;;
   *) send-mail;;
esac
