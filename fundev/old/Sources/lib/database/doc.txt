BASIC ARCHITECTURE

it is a simple-minded single-user oodb.  it caches persistent objects
into memory and writes back changes to them on demand.  it does all
this with virtual and private slot and that famous swizzle value.

built in values:

  #T, #F

built in types:

  tagged by-value:   <integer> and <byte-character>.  
  pseudo persistent: <byte-string>, <reference>, and <symbol>.
  by-reference:      <class>

persistent types:

  <persistent-list>, <persistent-pair>, <persistent-empty-list>
  <persistent-variable>

booted persistent values:

  persistent-empty-list

everything in the oodb has a type or is tagged.  

three persistent association lists are maintained in the oodb and
mirrored with hash tables in memory.  

  class id table (class -> class-id), 
  symbol table (symbol -> symbol-id), and
  root table (symbol -> variable-id)

the class id table maintains a record of the defined persistent
classes, the symbol table permits the oodb to reuse already present
symbols, and the root table makes available named roots in the
oodb. 


GETTING STARTED

Creation

? define variable c = db-create(as(<pathname>, "d")); 
? db-close(c); 

Running Test-Suite

? all-tst(c);
? dump(c);     // prints out the oodb in a semi intelligent fashion

Opening

? c := db-open(as(<pathname>, "d"));

Adding Roots

? root(c, #"todo") := persistent-copy(c, #(#"shop", #"drop"));
? ephemeral-copy(root(c, #"todo"));

New Persistent Classes

? define persistent-class <persistent-point> (<persistent-object>) 
    slot px; 
    slot py; 
  end;
? define variable pp = persistent-make(c, <persistent-point>);
? pp.px := 1;
? pp.py := 2;
? pp.px;
? root(c, #"p") := pp;
? db-close();
? c := db-open(as(<pathname>, "d"));
? root(c, #"p").px;
? root(c, #"p").py;


ACKNOWLEDGEMENTS

DOSS gave me some clues, thanks eliot
JRD had the same ``just do it'' attitude


META COMMENTS

Keith's thinking that this section is overkill
Mike's gulping that i actually took out 3 days to ``just do it''
