documented: #t
module: int-parse
author:  Robert Stockton (rgs@cs.cmu.edu)
copyright: Copyright (C) 1994, Carnegie Mellon University
	   All rights reserved.
	   This code was produced by the Gwydion Project at Carnegie Mellon
	   University.  If you are interested in using this code, contact
	   "Scott.Fahlman@cs.cmu.edu" (Internet).
rcs-header: $Header: 

//======================================================================
//
// Copyright (c) 1994  Carnegie Mellon University
// All rights reserved.
//
//======================================================================

//======================================================================
// Module int-parse handles parsing of define interface forms in interace
// files.  It makes no attempt to handle any other part of the Dylan language
// at this time, since it will eventually be merged into the native parser for
// the Gwydion compiler.
//
// The actual "source" for this parser is contained in "int-parse.input",
// which is an input file for a lisp-based Dylan parser generator.  (This is a
// logical route to follow for bootstrapping purposes.  It would clearly be
// useful to re-implement the generator in Dylan at some future date.)
// "Int-parse.dylan" is the pure Dylan output of this generator, and should
// *not* be considered human readable code.
//
// The "parse-tree" is a very ad-hoc structure, because it is intended to be
// quite ephemeral.  The final goal is to add annotations to the "parse-state"
// which describe the C header file to be processed and the transformations to
// apply to that header file's declarations.
//
// The external interface to the parser is the function "parse", which has the
// following interface:
//   parse(parse-state, #key defines, undefines) => ()
//     This function processes a single "define interface" form, using the
//     tokenizer in "parse-state", and annotates the parse state with the
//     information acquired.
// <parse-state> is defined below, and contains both global modifiers such as
// "include file" or "object file" and "clauses" which describe the processing
// of a single object.
//
// Note that this parser is atypical in that it does not try to consume all of
// the input.  It simply goes until it reaches the end of the "define
// interface" form, and the stops.  Since this is foreign to the parser
// generator's internal model, <eof-token> has been redefined to encompass all
// possible tokens.  Although this works, it is probably inherently unstable.
// Some extra code has been added to the generic "make-action-table" to insure
// that the omnipresence of <eof-token> doesn't screw up the tables.
//======================================================================

//----------------------------------------------------------------------
// Simple parser support 
//----------------------------------------------------------------------

// Designates an "optional" string.
//
define constant <string?> = type-union(<string>, <false>);

// Undefined values are useful for values that may need to be defaulted.  This
// is superious do simply filling in the default value at the start, since it
// allows us to merge several <container-option>s before doing the defaulting.
//
define class <undefined> (<object>) end class;
define constant undefined = make(<undefined>);

// Container options can either describe global modifications to be applied to
// all objects or can describe a set of modifications for some single object.
// Each of the fields corresponds pretty closely to a single "container
// option" in the Creole/Melange specs.
//
define class <container-options> (<object>)
  slot name-mapper :: type-union(<symbol>, <undefined>), init-value: undefined;
  // each element of imports is either #"all" or an import list
  slot global-import-mode
    :: one-of(#"all", #"all-recursive", #"none", #"undecided") = #"undecided";
  slot global-imports :: <sequence> = make(<stretchy-vector>);
  slot file-import-modes = make(<string-table>) /* of #"all", #"none" */;
  slot file-imports = make(<string-table>) /* of <sequence> */;
  slot prefix :: type-union(<string>, <undefined>), init-value: undefined;
  constant slot exclude = make(<deque>);
  constant slot excluded-files = make(<deque>);
  slot rename :: <sequence>, init-value: #();
  slot mappings :: <sequence>, init-value: #();
  slot equates :: <sequence>, init-value: #();
  slot read-only :: type-union(<boolean>, <undefined>), init-value: undefined;
  slot seal-string :: type-union(<string>, <undefined>), init-value: undefined;
end class <container-options>;

// This structure contains the tokenizer which defines the input to the
// parser, and also contains slot which will be filled in based upon the
// results of the parse.  It includes slots for various options which are
// unique to "#include" clauses, a <container-options> slot which corresponds
// to container options that have been globally applied in the "#include"
// clause, and a sequence of "<clause>"s (defined below) in no particular
// order. 
//
define class <parse-state> (<object>)
  slot tokenizer :: <tokenizer>, required-init-keyword: #"tokenizer";
  slot include-files :: false-or(<sequence>) = #f;
  slot object-files :: <deque>, init-function: curry(make, <deque>);
  slot mindy-include-file :: <string?>, init-value: #f;
  slot macro-defines :: <deque>, init-function: curry(make, <deque>);
  slot macro-undefines :: <deque>, init-function: curry(make, <deque>);
  slot container-options :: <container-options>;
  slot clauses :: <sequence>, init-value: #();
end class <parse-state>;

// This function fills in slots of a <container-option> based upon the raw
// "parse-tree" returned by some production.  This stuff is very ad-hoc, since
// there is little use in carefully defining the structure of an object that
// will last for milliseconds or less.
//
define method process-container-options 
    (parsed-clauses :: <list>)
 => (result :: <container-options>, rest :: <list>);
  let result = make(<container-options>);
  let left = #();
  for (item in parsed-clauses)
    select (item.first)
      #"name-mapper" =>
        if (result.name-mapper ~= undefined)
          error("Multiple name mappers in one #include clause");
        else
          result.name-mapper := item.second;
        end if;
      #"import" =>
	let value = item.second;
        if (instance?(value, <sequence>))
          for (import in value)
            add!(result.global-imports, import);
          end for;
	  if (result.global-import-mode == #"undecided")
            result.global-import-mode := #"none";
          end if;
        else
          result.global-import-mode := value;
        end if;
      #"import-file" =>
        let (file, stream) = open-in-include-path(item.second.value);
        if (stream)
          close(stream);
        else
          parse-error(item.second, "File does not exist in path.");
        end if;
	let value = item.third;
        if (instance?(value, <sequence>))
	  let imports = (element(result.file-imports, file, default: #f)
                          | (result.file-imports[file]
			       := make(<stretchy-vector>)));
	  for (import in value)
	    add!(imports, import);
          end for;
	  unless (element(result.file-import-modes, file, default: #f))
            result.file-import-modes[file] := #"none";
          end unless;
        else
          result.file-import-modes[file] := value;
        end if;
      #"prefix" =>
        if (result.prefix ~= undefined)
          error("Multiple prefixes in one #include clause");
        else
          result.prefix := item.second;
        end if;
      #"exclude" =>
        // exclude lists contain tokens
 	for (elem in item.second) add!(result.exclude, elem.value) end for;
      #"exclude-file" =>
        // exclude lists contain tokens
	for (elem in item.second) 
          let (file, stream) = open-in-include-path(elem.value);
          if (stream)
	    add!(result.excluded-files, file);
            close(stream);
          else
            parse-error(elem, "File does not exist in path.");
          end if;
        end for;
      #"rename" =>
        result.rename := reduce(method(a,b) pair(b,a) end method,
                                result.rename, item.second);
      #"mapping" =>
        result.mappings := reduce(method(a,b) pair(b,a) end method,
                                  result.mappings, item.second);
      #"equate" =>
        result.equates := reduce(method(a,b) pair(b,a) end method,
                      	         result.equates, item.second);
      #"read-only" =>
        result.read-only := item.second;
      #"seal" =>
        result.seal-string := item.second;
      otherwise =>
        left := pair(item, left);
    end select;
  end for;
  values(result, reverse!(left));
end method process-container-options;

// This corresponds to any "clause" in the interface definition which is not a
// "#include".  Most of them are simply typed "boxes" for sequences of
// "options".  At present the options consist of a sequence labelled by an
// initial symbol.  At some later time they may be fleshed out in more detail.
// Some clauses also contain a <container-options> structure which breaks down
// some of the options in a more convenient format.
//
define class <clause> (<object>) 
  slot name :: <string>, required-init-keyword: #"name";
  slot options :: <sequence>, required-init-keyword: #"options";
end class;

define class <function-clause> (<clause>) end class;
define class <variable-clause> (<clause>) end class;
define class <constant-clause> (<clause>) end class;
define class <pointer-clause> (<clause>) end class;

define class <container-clause> (<clause>)
  slot container-options :: <container-options>;
end class <container-clause>;

define class <struct-clause> (<container-clause>) end class;
define class <union-clause> (<container-clause>) end class;

//----------------------------------------------------------------------
// Generic parser boilerplate.
//----------------------------------------------------------------------

define class <action> (<object>)
  slot on :: <class>, required-init-keyword: on:, setter: #f;
end;

define class <shift> (<action>)
  slot state :: <integer>, required-init-keyword: state:, setter: #f;
end;

define method \= (action1 :: <shift>, action2 :: <shift>) => eq? :: <boolean>;
  action1.state == action2.state;
end;

define class <reduce> (<action>)
  slot production :: <integer>, required-init-keyword: production:, setter: #f;
end;

define method \= (action1 :: <reduce>, action2 :: <reduce>) => eq? :: <boolean>;
  action1.production == action2.production;
end;

define class <accept> (<action>)
end;

define method \= (action1 :: <accept>, action2 :: <accept>)
 => eq? :: <boolean>;
  #t;
end;

// Because <eof-token> encompasses all other token classes, we must keep
// actions for <eof-token> from overwriting other valid actions.  This is an
// ugly special case, but allows us to use the parser generator for an
// application beyond its normal capabilities -- i.e. parsing only a portion
// of a file.  (In practice, the extra code is probably superfluous, as the
// states which acceof <eof-token> don't accept anything else -- but better
// safe than sorry.
//
define method make-action-table(#rest actions)
  let result = make(<self-organizing-list>);
  for (action in actions)
    local
      method process (clas :: <class>, is-eof)
	unless (is-eof & key-exists?(result, clas))
	  result[clas] := action;
	  for (sub in clas.direct-subclasses)
	    process(sub, is-eof);
	  end;
	end unless;
      end;
    process(action.on, action.on == <eof-token>);
  end;
  result;
end;

//----------------------------------------------------------------------
// The actual productions.  The format is
//  production (sub-production-or-<token> .....)
//    Arbitrary dylan code -- variables $r1 - $rn correspond to the
//    sub-productions, and $state is a <parse-state> which is passed into each
//    action routine for record-keeping purposes.
//  %
//----------------------------------------------------------------------

%%
parse-root (interface-def <semicolon-token>)
  // dispose of semi if it exists, but accept EOF instead
  #t;
%

parse-root (interface-def <true-eof-token>)
  #t;
%

interface-def (<define-token> <interface-token> interface-clause-list
               <end-token> <interface-token>)
%

interface-def (<define-token> <interface-token> interface-clause-list
               <end-token>)
%

interface-clause-list (interface-clause-list1 <semicolon-token>)
  $r1;
%

interface-clause-list (interface-clause-list1)
  $r1;
%

interface-clause-list1 (interface-clause-list1 <semicolon-token>
                       interface-clause)
  pair($r3, $r1)
%

interface-clause-list1 (interface-clause)
  list($r1);
%

interface-clause (file-clause)
  $r1;
%

file-clause (<include-token> <string-literal-token> file-option-list)
  if ($state.include-files) 
    parse-error($r1, "More than one #include in interface definition.")
  end if;
  $state.include-files := vector($r2.value);
  $state.container-options := process-container-options($r3);
%

file-clause (<include-token> <lbrace-token> include-file-list <rbrace-token>
file-option-list)
  if ($state.include-files) 
    parse-error($r1, "More than one #include in interface definition.")
  end if;
  $state.include-files := as(<simple-object-vector>, $r3);
  $state.container-options := process-container-options($r5);
%

include-file-list (<string-literal-token>)
  make(<stretchy-vector>, size: 1, fill: $r1.value);
%

include-file-list (include-file-list <comma-token> <string-literal-token>)
  add!($r1, $r3.value);
%

file-option-list ()
  #();
%

file-option-list (file-option-list <comma-token> file-option)
  pair($r3, $r1);
%

file-option (<object-file-token> <string-literal-token>)
  push-last($state.object-files, $r2.value);
  pair(#"object-file", $r2.value);
%

file-option (<mindy-inc-token> <string-literal-token>)
  if ($state.mindy-include-file) 
    parse-error($r1,
                "More than one mindy-include-file: in interface definition.")
  end if;
  pair(#"mindy-file", $state.mindy-include-file := $r2.value);
%

file-option (<define-macro-token> <lbrace-token> macro-definitions
             <rbrace-token>)
  pair(#"macro-definitions", $r3);
%

file-option (<undefine-token> <lbrace-token> macro-undefinitions
             <rbrace-token>)
  pair(#"macro-undefines", $r3);
%

file-option (container-option)
  $r1;
%

macro-definitions (macro-definition)
  list($r1);
%

macro-definitions (macro-definitions <comma-token> macro-definition)
  pair($r3, $r1);
%

macro-definition (<string-literal-token>)
  push-last($state.macro-defines, pair($r1.value, 1));
%

macro-definition (<string-literal-token> <arrow-token> <string-literal-token>)
  push-last($state.macro-defines, pair($r1.value, $r3.value));
%

macro-definition (<string-literal-token> <arrow-token> <integer-token>)
  push-last($state.macro-defines, pair($r1.value, $r3.value));
%

macro-undefinitions (macro-undefinition)
  list($r1);
%

macro-undefinitions (macro-undefinitions <comma-token> macro-undefinition)
  pair($r3, $r1);
%

macro-undefinition (<string-literal-token>)
  push-last($state.macro-undefines, $r1.value);
%

container-option (<name-mapper-token> <identifier-token>)
  list(#"name-mapper", $r2.value);
%

container-option (<import-token> <all-token>)
  list(#"import", #"all");
%

container-option (<import-token> <all-recursive-token>)
  list(#"import", #"all-recursive");
%

container-option (<import-token> <lbrace-token> import-list <rbrace-token>)
  list(#"import", $r3);
%

container-option (<import-token> <string-literal-token> <arrow-token>
                  <all-token>)
  list(#"import-file", $r2, #"all");
%

container-option (<import-token> <string-literal-token> <arrow-token> <none-token>)
  list(#"import-file", $r2, #"none");
%

container-option (<import-token> <string-literal-token> <arrow-token> <lbrace-token> import-list <rbrace-token>)
  list(#"import-file", $r2, $r5);
%

import-list ()
  #();
%

import-list (import-list <comma-token> import)
  pair($r3, $r1);
%

import-list (import)
  list($r1);
%

import (<string-literal-token>)
  $r1.value;
%

import (renaming)
  $r1;
%

renaming (<string-literal-token> <arrow-token> <identifier-token>)
  pair($r1.value, $r3.value);
%

container-option (<prefix-token> <string-literal-token>)
  list(#"prefix", $r2.value);
%

container-option (<exclude-token> <lbrace-token> exclude-list <rbrace-token>)
  list(#"exclude", $r3);
%

exclude-list ()
  #();
%

exclude-list (exclude-list <comma-token> <string-literal-token>)
  pair($r3, $r1);
%

exclude-list (<string-literal-token>)
  list($r1);
%

container-option (<exclude-file-token> <string-literal-token>)
  list(#"exclude-file", list($r2));
%

container-option (<exclude-file-token> <lbrace-token> exclude-list
		  <rbrace-token>)
  list(#"exclude-file", $r3);
%


container-option (<rename-token> <lbrace-token> renaming-list <rbrace-token>)
  list(#"rename", $r3);
%

renaming-list ()
  #();
%

renaming-list (renaming-list <comma-token> renaming)
  pair($r3, $r1);
%

renaming-list (renaming)
  list($r1);
%

container-option (<mapping-token> <lbrace-token> renaming-list <rbrace-token>)
  list(#"mapping", $r3);
%

container-option (<equate-token> <lbrace-token> renaming-list <rbrace-token>)
  list(#"equate", $r3);
%

sealing (<sealed-token>)
  $r1.string-value
%

sealing (<open-token>)
  $r1.string-value
%

sealing (<inline-token>)
  parse-error($r1, "'inline' not handled at present.")
%

container-option (<seal-functions-token> sealing)
  list(#"seal", $r2);
%

container-option (<read-only-token> <boolean-token>)
  list(#"read-only", $r2.value);
%

interface-clause (<function-token> <string-literal-token>
                  function-option-list)
  $state.clauses := add!($state.clauses,
                         make(<function-clause>, 
                              name: $r2.value, options: $r3));
%

interface-clause (<function-token> <string-literal-token> <arrow-token>
                  <identifier-token> function-option-list)
  $state.container-options.rename :=
     pair(pair($r2.value, $r4.value), $state.container-options.rename);
  $state.clauses := add!($state.clauses,
                         make(<function-clause>,
                              name: $r2.value, options: $r5));
%

function-option-list ()
  #();
%

function-option-list (function-option-list <comma-token> function-option)
  pair($r3, $r1);
%

function-option (<map-result-token> <identifier-token>)
  pair(#"map-result", $r2.string-value);
%

function-option (<equate-result-token> <identifier-token>)
  pair(#"equate-result", $r2.string-value);
%

function-option (<ignore-result-token> <boolean-token>)
  pair(#"ignore-result", $r2.value);
%

function-option (<map-argument-token> <lbrace-token> argument
                 <arrow-token> <identifier-token> <rbrace-token>)
  pair(#"map-arg", pair($r3.value, $r5.string-value));
%

function-option (<equate-argument-token> <lbrace-token> argument
                 <arrow-token> <identifier-token> <rbrace-token>)
  pair(#"equate-arg", pair($r3.value, $r5.string-value));
%

function-option (<input-argument-token> argument)
  pair(#"in", $r2.value);
%

function-option (<input-output-argument-token> argument)
  pair(#"in-out", $r2.value);
%

function-option (<output-argument-token> argument)
  pair(#"out", $r2.value);
%

argument (<integer-token>)
  $r1;
%

argument (<identifier-token>)
  $r1;
%

argument (<string-literal-token>)
  $r1;
%

interface-clause (<struct-token> <string-literal-token> structure-option-list)
  let (container-opts, rest) = process-container-options($r3);
  let new-clause = make(<struct-clause>, name: $r2.value, options: rest);
  new-clause.container-options := container-opts;
  $state.clauses := add!($state.clauses, new-clause);
%

interface-clause (<struct-token> <string-literal-token> <arrow-token>
                  <identifier-token> structure-option-list)
  $state.container-options.rename :=
     pair(pair($r2.value, $r4.value), $state.container-options.rename);
  let (container-opts, rest) = process-container-options($r5);
  let new-clause = make(<struct-clause>, name: $r2.value, options: rest);
  new-clause.container-options := container-opts;
  $state.clauses := add!($state.clauses, new-clause);
%

interface-clause (<union-token> <string-literal-token> structure-option-list)
  let (container-opts, rest) = process-container-options($r3);
  let new-clause = make(<union-clause>, name: $r2.value, options: rest);
  new-clause.container-options := container-opts;
  $state.clauses := add!($state.clauses, new-clause);
%

interface-clause (<union-token> <string-literal-token> <arrow-token>
                  <identifier-token> structure-option-list)
  $state.container-options.rename :=
     pair(pair($r2.value, $r4.value), $state.container-options.rename);
  let (container-opts, rest) = process-container-options($r5);
  let new-clause = make(<union-clause>, name: $r2.value, options: rest);
  new-clause.container-options := container-opts;
  $state.clauses := add!($state.clauses, new-clause);
%

structure-option-list ()
  #();
%

structure-option-list (structure-option-list <comma-token> container-option)
  pair($r3, $r1);
%

superclass-list (<identifier-token>)
  list($r1.string-value);
%

superclass-list (superclass-list <comma-token> <identifier-token>)
  pair($r3.string-value, $r1);
%

superclass-option
    (<superclass-token> <lbrace-token> superclass-list <rbrace-token>)
  pair(#"superclass", reverse!($r3));
%

structure-option-list (structure-option-list <comma-token> superclass-option)
  pair($r3, $r1);
%

interface-clause (<pointer-token> <string-literal-token> pointer-option-list)
  let new-clause = make(<pointer-clause>, name: $r2.value, options: $r3);
  $state.clauses := add!($state.clauses, new-clause);
%

interface-clause (<pointer-token> <string-literal-token> <arrow-token>
                  <identifier-token> pointer-option-list)
  $state.container-options.rename :=
     pair(pair($r2.value, $r4.value), $state.container-options.rename);
  let new-clause = make(<pointer-clause>, name: $r2.value, options: $r5);
  $state.clauses := add!($state.clauses, new-clause);
%

pointer-option-list ()
  #();
%

pointer-option-list (structure-option-list <comma-token> superclass-option)
  pair($r3, $r1);
%

interface-clause (<constant-token> <string-literal-token>
                  constant-option-list)
  $state.clauses := add!($state.clauses,
                         make(<constant-clause>, 
                              name: $r2.value, options: $r3));
%

interface-clause (<constant-token> <string-literal-token> <arrow-token>
                  <identifier-token> constant-option-list)
  $state.container-options.rename :=
     pair(pair($r2.value, $r4.value), $state.container-options.rename);
  $state.clauses := add!($state.clauses,
                         make(<constant-clause>,
                              name: $r2.value, options: $r5));
%

constant-option-list ()
  #();
%

constant-option-list (constant-option-list <comma-token> constant-option)
  pair($r3, $r1);
%

constant-option (<value-token> <literal-token>)
  pair(#"value", $r2.string-value);
%

interface-clause (<variable-token> <string-literal-token>
                  variable-option-list)
  $state.clauses := add!($state.clauses,
                         make(<variable-clause>, 
                              name: $r2.value, options: $r3));
%

interface-clause (<variable-token> <string-literal-token> <arrow-token>
                  <identifier-token> variable-option-list)
  $state.container-options.rename :=
     pair(pair($r2.value, $r4.value), $state.container-options.rename);
  $state.clauses := add!($state.clauses,
                         make(<variable-clause>,
                              name: $r2.value, options: $r5));
%

variable-option-list ()
  #();
%

variable-option-list (variable-option-list <comma-token> variable-option)
  pair($r3, $r1);
%

variable-option (<getter-token> <identifier-token>)
  pair(#"getter", $r2.string-value);
%

variable-option (<setter-token> <identifier-token>)
  pair(#"setter", $r2.string-value);
%

variable-option (<read-only-token> <boolean-token>)
  pair(#"read-only", $r2.value);
%

variable-option (<mapping-token> <identifier-token>)
  pair(#"map", $r2.string-value);
%

variable-option (<equate-token> <identifier-token>)
  pair(#"equate", $r2.string-value);
%

variable-option (<getter-token> sealing)
  pair(#"seal", $r2);
%

%%

//----------------------------------------------------------------------
// More parser boilerplate
//----------------------------------------------------------------------

define method do-action (action :: <accept>, state-stack :: <list>,
			 symbol-stack :: <list>, token :: <token>,
			 parse-state :: <parse-state>)
  unget-token(parse-state.tokenizer, token);
  if (symbol-stack.size ~= 1)
    parse-error(token, "Symbol-stack didn't get reduced all the way?");
  end;
  symbol-stack.head;
end;

define method do-action (action :: <shift>, state-stack :: <list>,
			 symbol-stack :: <list>, token :: <token>,
			 parse-state :: <parse-state>)
  parse-loop(pair(action.state, state-stack),
	     pair(token, symbol-stack),
	     get-token(parse-state.tokenizer),
	     parse-state);
end;

define method do-action (action :: <reduce>, state-stack :: <list>,
			 symbol-stack :: <list>, token :: <token>,
			 parse-state :: <parse-state>)
  let (new-state-stack, new-symbol-stack)
    = *production-table*[action.production](state-stack, symbol-stack,
                                            $state: parse-state);
  parse-loop(new-state-stack, new-symbol-stack, token, parse-state);
end;

define method find-action (table, token)
  let action = element(table, token.object-class, default: #f);
  if (action)
    action;
  else
    parse-error(token, "Parse error at or before %=.", token.string-value);
  end;
end;

define method parse-loop (state-stack :: <list>, symbol-stack :: <list>,
			  token :: <token>, parse-state :: <parse-state>)
  do-action(find-action(*action-table*[state-stack.head], token),
	    state-stack, symbol-stack, token, parse-state);
end;

//----------------------------------------------------------------------
// External interfaces to the parsing engine.
//----------------------------------------------------------------------

// This function processes a single "define interface" form, using the
// tokenizer in "parse-state", and annotates the parse state with the
// information acquired.
//
define method parse (parse-state :: <parse-state>)
  parse-loop(#(0), #(), get-token(parse-state.tokenizer), parse-state);
end;
